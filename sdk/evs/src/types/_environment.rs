// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object that represents an Amazon EVS environment.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Environment {
    /// <p>The unique ID for the environment.</p>
    pub environment_id: ::std::option::Option<::std::string::String>,
    /// <p>The state of an environment.</p>
    pub environment_state: ::std::option::Option<crate::types::EnvironmentState>,
    /// <p>A detailed description of the <code>environmentState</code> of an environment.</p>
    pub state_details: ::std::option::Option<::std::string::String>,
    /// <p>The date and time that the environment was created.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date and time that the environment was modified.</p>
    pub modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) that is associated with the environment.</p>
    pub environment_arn: ::std::option::Option<::std::string::String>,
    /// <p>The name of the environment.</p>
    pub environment_name: ::std::option::Option<::std::string::String>,
    /// <p>The VPC associated with the environment.</p>
    pub vpc_id: ::std::option::Option<::std::string::String>,
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.</p>
    pub service_access_subnet_id: ::std::option::Option<::std::string::String>,
    /// <p>The VCF version of the environment.</p>
    pub vcf_version: ::std::option::Option<crate::types::VcfVersion>,
    /// <p>Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.</p>
    pub terms_accepted: ::std::option::Option<bool>,
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.</p>
    pub license_info: ::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>>,
    /// <p>The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub site_id: ::std::option::Option<::std::string::String>,
    /// <p>Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.</p>
    pub environment_status: ::std::option::Option<crate::types::CheckResult>,
    /// <p>A check on the environment to identify instance health and VMware VCF licensing issues.</p>
    pub checks: ::std::option::Option<::std::vec::Vec<crate::types::Check>>,
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.</p>
    pub connectivity_info: ::std::option::Option<crate::types::ConnectivityInfo>,
    /// <p>The DNS hostnames to be used by the VCF management appliances in your environment.</p>
    /// <p>For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.</p>
    pub vcf_hostnames: ::std::option::Option<crate::types::VcfHostnames>,
    /// <p>The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    /// <p>By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key <code>aws/secretsmanager</code>. You can also specify a customer managed key.</p>
    pub kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.</p>
    pub service_access_security_groups: ::std::option::Option<crate::types::ServiceAccessSecurityGroups>,
    /// <p>The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager.</p>
    /// <p>Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    pub credentials: ::std::option::Option<::std::vec::Vec<crate::types::Secret>>,
}
impl Environment {
    /// <p>The unique ID for the environment.</p>
    pub fn environment_id(&self) -> ::std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>The state of an environment.</p>
    pub fn environment_state(&self) -> ::std::option::Option<&crate::types::EnvironmentState> {
        self.environment_state.as_ref()
    }
    /// <p>A detailed description of the <code>environmentState</code> of an environment.</p>
    pub fn state_details(&self) -> ::std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The date and time that the environment was created.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time that the environment was modified.</p>
    pub fn modified_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.modified_at.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that is associated with the environment.</p>
    pub fn environment_arn(&self) -> ::std::option::Option<&str> {
        self.environment_arn.as_deref()
    }
    /// <p>The name of the environment.</p>
    pub fn environment_name(&self) -> ::std::option::Option<&str> {
        self.environment_name.as_deref()
    }
    /// <p>The VPC associated with the environment.</p>
    pub fn vpc_id(&self) -> ::std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.</p>
    pub fn service_access_subnet_id(&self) -> ::std::option::Option<&str> {
        self.service_access_subnet_id.as_deref()
    }
    /// <p>The VCF version of the environment.</p>
    pub fn vcf_version(&self) -> ::std::option::Option<&crate::types::VcfVersion> {
        self.vcf_version.as_ref()
    }
    /// <p>Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.</p>
    pub fn terms_accepted(&self) -> ::std::option::Option<bool> {
        self.terms_accepted
    }
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.license_info.is_none()`.
    pub fn license_info(&self) -> &[crate::types::LicenseInfo] {
        self.license_info.as_deref().unwrap_or_default()
    }
    /// <p>The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn site_id(&self) -> ::std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.</p>
    pub fn environment_status(&self) -> ::std::option::Option<&crate::types::CheckResult> {
        self.environment_status.as_ref()
    }
    /// <p>A check on the environment to identify instance health and VMware VCF licensing issues.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.checks.is_none()`.
    pub fn checks(&self) -> &[crate::types::Check] {
        self.checks.as_deref().unwrap_or_default()
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.</p>
    pub fn connectivity_info(&self) -> ::std::option::Option<&crate::types::ConnectivityInfo> {
        self.connectivity_info.as_ref()
    }
    /// <p>The DNS hostnames to be used by the VCF management appliances in your environment.</p>
    /// <p>For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.</p>
    pub fn vcf_hostnames(&self) -> ::std::option::Option<&crate::types::VcfHostnames> {
        self.vcf_hostnames.as_ref()
    }
    /// <p>The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    /// <p>By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key <code>aws/secretsmanager</code>. You can also specify a customer managed key.</p>
    pub fn kms_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.</p>
    pub fn service_access_security_groups(&self) -> ::std::option::Option<&crate::types::ServiceAccessSecurityGroups> {
        self.service_access_security_groups.as_ref()
    }
    /// <p>The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager.</p>
    /// <p>Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.credentials.is_none()`.
    pub fn credentials(&self) -> &[crate::types::Secret] {
        self.credentials.as_deref().unwrap_or_default()
    }
}
impl Environment {
    /// Creates a new builder-style object to manufacture [`Environment`](crate::types::Environment).
    pub fn builder() -> crate::types::builders::EnvironmentBuilder {
        crate::types::builders::EnvironmentBuilder::default()
    }
}

/// A builder for [`Environment`](crate::types::Environment).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct EnvironmentBuilder {
    pub(crate) environment_id: ::std::option::Option<::std::string::String>,
    pub(crate) environment_state: ::std::option::Option<crate::types::EnvironmentState>,
    pub(crate) state_details: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) environment_arn: ::std::option::Option<::std::string::String>,
    pub(crate) environment_name: ::std::option::Option<::std::string::String>,
    pub(crate) vpc_id: ::std::option::Option<::std::string::String>,
    pub(crate) service_access_subnet_id: ::std::option::Option<::std::string::String>,
    pub(crate) vcf_version: ::std::option::Option<crate::types::VcfVersion>,
    pub(crate) terms_accepted: ::std::option::Option<bool>,
    pub(crate) license_info: ::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>>,
    pub(crate) site_id: ::std::option::Option<::std::string::String>,
    pub(crate) environment_status: ::std::option::Option<crate::types::CheckResult>,
    pub(crate) checks: ::std::option::Option<::std::vec::Vec<crate::types::Check>>,
    pub(crate) connectivity_info: ::std::option::Option<crate::types::ConnectivityInfo>,
    pub(crate) vcf_hostnames: ::std::option::Option<crate::types::VcfHostnames>,
    pub(crate) kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) service_access_security_groups: ::std::option::Option<crate::types::ServiceAccessSecurityGroups>,
    pub(crate) credentials: ::std::option::Option<::std::vec::Vec<crate::types::Secret>>,
}
impl EnvironmentBuilder {
    /// <p>The unique ID for the environment.</p>
    pub fn environment_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.environment_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique ID for the environment.</p>
    pub fn set_environment_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.environment_id = input;
        self
    }
    /// <p>The unique ID for the environment.</p>
    pub fn get_environment_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.environment_id
    }
    /// <p>The state of an environment.</p>
    pub fn environment_state(mut self, input: crate::types::EnvironmentState) -> Self {
        self.environment_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of an environment.</p>
    pub fn set_environment_state(mut self, input: ::std::option::Option<crate::types::EnvironmentState>) -> Self {
        self.environment_state = input;
        self
    }
    /// <p>The state of an environment.</p>
    pub fn get_environment_state(&self) -> &::std::option::Option<crate::types::EnvironmentState> {
        &self.environment_state
    }
    /// <p>A detailed description of the <code>environmentState</code> of an environment.</p>
    pub fn state_details(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.state_details = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A detailed description of the <code>environmentState</code> of an environment.</p>
    pub fn set_state_details(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.state_details = input;
        self
    }
    /// <p>A detailed description of the <code>environmentState</code> of an environment.</p>
    pub fn get_state_details(&self) -> &::std::option::Option<::std::string::String> {
        &self.state_details
    }
    /// <p>The date and time that the environment was created.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time that the environment was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The date and time that the environment was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The date and time that the environment was modified.</p>
    pub fn modified_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.modified_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time that the environment was modified.</p>
    pub fn set_modified_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.modified_at = input;
        self
    }
    /// <p>The date and time that the environment was modified.</p>
    pub fn get_modified_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.modified_at
    }
    /// <p>The Amazon Resource Name (ARN) that is associated with the environment.</p>
    pub fn environment_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.environment_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) that is associated with the environment.</p>
    pub fn set_environment_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.environment_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) that is associated with the environment.</p>
    pub fn get_environment_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.environment_arn
    }
    /// <p>The name of the environment.</p>
    pub fn environment_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.environment_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the environment.</p>
    pub fn set_environment_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.environment_name = input;
        self
    }
    /// <p>The name of the environment.</p>
    pub fn get_environment_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.environment_name
    }
    /// <p>The VPC associated with the environment.</p>
    pub fn vpc_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vpc_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The VPC associated with the environment.</p>
    pub fn set_vpc_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vpc_id = input;
        self
    }
    /// <p>The VPC associated with the environment.</p>
    pub fn get_vpc_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.vpc_id
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.</p>
    pub fn service_access_subnet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_access_subnet_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.</p>
    pub fn set_service_access_subnet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_access_subnet_id = input;
        self
    }
    /// <p>The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.</p>
    pub fn get_service_access_subnet_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_access_subnet_id
    }
    /// <p>The VCF version of the environment.</p>
    pub fn vcf_version(mut self, input: crate::types::VcfVersion) -> Self {
        self.vcf_version = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VCF version of the environment.</p>
    pub fn set_vcf_version(mut self, input: ::std::option::Option<crate::types::VcfVersion>) -> Self {
        self.vcf_version = input;
        self
    }
    /// <p>The VCF version of the environment.</p>
    pub fn get_vcf_version(&self) -> &::std::option::Option<crate::types::VcfVersion> {
        &self.vcf_version
    }
    /// <p>Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.</p>
    pub fn terms_accepted(mut self, input: bool) -> Self {
        self.terms_accepted = ::std::option::Option::Some(input);
        self
    }
    /// <p>Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.</p>
    pub fn set_terms_accepted(mut self, input: ::std::option::Option<bool>) -> Self {
        self.terms_accepted = input;
        self
    }
    /// <p>Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.</p>
    pub fn get_terms_accepted(&self) -> &::std::option::Option<bool> {
        &self.terms_accepted
    }
    /// Appends an item to `license_info`.
    ///
    /// To override the contents of this collection use [`set_license_info`](Self::set_license_info).
    ///
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.</p>
    pub fn license_info(mut self, input: crate::types::LicenseInfo) -> Self {
        let mut v = self.license_info.unwrap_or_default();
        v.push(input);
        self.license_info = ::std::option::Option::Some(v);
        self
    }
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.</p>
    pub fn set_license_info(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>>) -> Self {
        self.license_info = input;
        self
    }
    /// <p>The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.</p>
    pub fn get_license_info(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LicenseInfo>> {
        &self.license_info
    }
    /// <p>The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn site_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.site_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn set_site_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.site_id = input;
        self
    }
    /// <p>The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.</p>
    pub fn get_site_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.site_id
    }
    /// <p>Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.</p>
    pub fn environment_status(mut self, input: crate::types::CheckResult) -> Self {
        self.environment_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.</p>
    pub fn set_environment_status(mut self, input: ::std::option::Option<crate::types::CheckResult>) -> Self {
        self.environment_status = input;
        self
    }
    /// <p>Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.</p>
    pub fn get_environment_status(&self) -> &::std::option::Option<crate::types::CheckResult> {
        &self.environment_status
    }
    /// Appends an item to `checks`.
    ///
    /// To override the contents of this collection use [`set_checks`](Self::set_checks).
    ///
    /// <p>A check on the environment to identify instance health and VMware VCF licensing issues.</p>
    pub fn checks(mut self, input: crate::types::Check) -> Self {
        let mut v = self.checks.unwrap_or_default();
        v.push(input);
        self.checks = ::std::option::Option::Some(v);
        self
    }
    /// <p>A check on the environment to identify instance health and VMware VCF licensing issues.</p>
    pub fn set_checks(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Check>>) -> Self {
        self.checks = input;
        self
    }
    /// <p>A check on the environment to identify instance health and VMware VCF licensing issues.</p>
    pub fn get_checks(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Check>> {
        &self.checks
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.</p>
    pub fn connectivity_info(mut self, input: crate::types::ConnectivityInfo) -> Self {
        self.connectivity_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.</p>
    pub fn set_connectivity_info(mut self, input: ::std::option::Option<crate::types::ConnectivityInfo>) -> Self {
        self.connectivity_info = input;
        self
    }
    /// <p>The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.</p>
    pub fn get_connectivity_info(&self) -> &::std::option::Option<crate::types::ConnectivityInfo> {
        &self.connectivity_info
    }
    /// <p>The DNS hostnames to be used by the VCF management appliances in your environment.</p>
    /// <p>For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.</p>
    pub fn vcf_hostnames(mut self, input: crate::types::VcfHostnames) -> Self {
        self.vcf_hostnames = ::std::option::Option::Some(input);
        self
    }
    /// <p>The DNS hostnames to be used by the VCF management appliances in your environment.</p>
    /// <p>For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.</p>
    pub fn set_vcf_hostnames(mut self, input: ::std::option::Option<crate::types::VcfHostnames>) -> Self {
        self.vcf_hostnames = input;
        self
    }
    /// <p>The DNS hostnames to be used by the VCF management appliances in your environment.</p>
    /// <p>For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.</p>
    pub fn get_vcf_hostnames(&self) -> &::std::option::Option<crate::types::VcfHostnames> {
        &self.vcf_hostnames
    }
    /// <p>The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    /// <p>By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key <code>aws/secretsmanager</code>. You can also specify a customer managed key.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    /// <p>By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key <code>aws/secretsmanager</code>. You can also specify a customer managed key.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    /// <p>By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key <code>aws/secretsmanager</code>. You can also specify a customer managed key.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_id
    }
    /// <p>The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.</p>
    pub fn service_access_security_groups(mut self, input: crate::types::ServiceAccessSecurityGroups) -> Self {
        self.service_access_security_groups = ::std::option::Option::Some(input);
        self
    }
    /// <p>The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.</p>
    pub fn set_service_access_security_groups(mut self, input: ::std::option::Option<crate::types::ServiceAccessSecurityGroups>) -> Self {
        self.service_access_security_groups = input;
        self
    }
    /// <p>The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.</p>
    pub fn get_service_access_security_groups(&self) -> &::std::option::Option<crate::types::ServiceAccessSecurityGroups> {
        &self.service_access_security_groups
    }
    /// Appends an item to `credentials`.
    ///
    /// To override the contents of this collection use [`set_credentials`](Self::set_credentials).
    ///
    /// <p>The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager.</p>
    /// <p>Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    pub fn credentials(mut self, input: crate::types::Secret) -> Self {
        let mut v = self.credentials.unwrap_or_default();
        v.push(input);
        self.credentials = ::std::option::Option::Some(v);
        self
    }
    /// <p>The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager.</p>
    /// <p>Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    pub fn set_credentials(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Secret>>) -> Self {
        self.credentials = input;
        self
    }
    /// <p>The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager.</p>
    /// <p>Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.</p>
    pub fn get_credentials(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Secret>> {
        &self.credentials
    }
    /// Consumes the builder and constructs a [`Environment`](crate::types::Environment).
    pub fn build(self) -> crate::types::Environment {
        crate::types::Environment {
            environment_id: self.environment_id,
            environment_state: self.environment_state,
            state_details: self.state_details,
            created_at: self.created_at,
            modified_at: self.modified_at,
            environment_arn: self.environment_arn,
            environment_name: self.environment_name,
            vpc_id: self.vpc_id,
            service_access_subnet_id: self.service_access_subnet_id,
            vcf_version: self.vcf_version,
            terms_accepted: self.terms_accepted,
            license_info: self.license_info,
            site_id: self.site_id,
            environment_status: self.environment_status,
            checks: self.checks,
            connectivity_info: self.connectivity_info,
            vcf_hostnames: self.vcf_hostnames,
            kms_key_id: self.kms_key_id,
            service_access_security_groups: self.service_access_security_groups,
            credentials: self.credentials,
        }
    }
}
