// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateDomainConfigurationInput {
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    pub domain_configuration_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the domain.</p>
    pub domain_name: ::std::option::Option<::std::string::String>,
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    pub server_certificate_arns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub validation_certificate_arn: ::std::option::Option<::std::string::String>,
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub authorizer_config: ::std::option::Option<crate::types::AuthorizerConfig>,
    /// <p>The type of service delivered by the endpoint.</p><note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub service_type: ::std::option::Option<crate::types::ServiceType>,
    /// <p>Metadata which can be used to manage the domain configuration.</p><note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>An object that specifies the TLS configuration for a domain.</p>
    pub tls_config: ::std::option::Option<crate::types::TlsConfig>,
    /// <p>The server certificate configuration.</p>
    pub server_certificate_config: ::std::option::Option<crate::types::ServerCertificateConfig>,
    /// <p>An enumerated string that speciﬁes the authentication type.</p>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH_X509</code> - Use custom authentication and authorization with additional details from the X.509 client certificate.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH</code> - Use custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">Custom authentication and authorization</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_X509</code> - Use X.509 client certificates without custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/x509-client-certs.html">X.509 client certificates</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_SIGV4</code> - Use Amazon Web Services Signature Version 4. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">IAM users, groups, and roles</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub authentication_type: ::std::option::Option<crate::types::AuthenticationType>,
    /// <p>An enumerated string that speciﬁes the application-layer protocol.</p>
    /// <ul>
    /// <li>
    /// <p><code>SECURE_MQTT</code> - MQTT over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>MQTT_WSS</code> - MQTT over WebSocket.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>HTTPS</code> - HTTP over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub application_protocol: ::std::option::Option<crate::types::ApplicationProtocol>,
    /// <p>An object that speciﬁes the client certificate conﬁguration for a domain.</p>
    pub client_certificate_config: ::std::option::Option<crate::types::ClientCertificateConfig>,
}
impl CreateDomainConfigurationInput {
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    pub fn domain_configuration_name(&self) -> ::std::option::Option<&str> {
        self.domain_configuration_name.as_deref()
    }
    /// <p>The name of the domain.</p>
    pub fn domain_name(&self) -> ::std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.server_certificate_arns.is_none()`.
    pub fn server_certificate_arns(&self) -> &[::std::string::String] {
        self.server_certificate_arns.as_deref().unwrap_or_default()
    }
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn validation_certificate_arn(&self) -> ::std::option::Option<&str> {
        self.validation_certificate_arn.as_deref()
    }
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub fn authorizer_config(&self) -> ::std::option::Option<&crate::types::AuthorizerConfig> {
        self.authorizer_config.as_ref()
    }
    /// <p>The type of service delivered by the endpoint.</p><note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub fn service_type(&self) -> ::std::option::Option<&crate::types::ServiceType> {
        self.service_type.as_ref()
    }
    /// <p>Metadata which can be used to manage the domain configuration.</p><note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>An object that specifies the TLS configuration for a domain.</p>
    pub fn tls_config(&self) -> ::std::option::Option<&crate::types::TlsConfig> {
        self.tls_config.as_ref()
    }
    /// <p>The server certificate configuration.</p>
    pub fn server_certificate_config(&self) -> ::std::option::Option<&crate::types::ServerCertificateConfig> {
        self.server_certificate_config.as_ref()
    }
    /// <p>An enumerated string that speciﬁes the authentication type.</p>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH_X509</code> - Use custom authentication and authorization with additional details from the X.509 client certificate.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH</code> - Use custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">Custom authentication and authorization</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_X509</code> - Use X.509 client certificates without custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/x509-client-certs.html">X.509 client certificates</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_SIGV4</code> - Use Amazon Web Services Signature Version 4. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">IAM users, groups, and roles</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn authentication_type(&self) -> ::std::option::Option<&crate::types::AuthenticationType> {
        self.authentication_type.as_ref()
    }
    /// <p>An enumerated string that speciﬁes the application-layer protocol.</p>
    /// <ul>
    /// <li>
    /// <p><code>SECURE_MQTT</code> - MQTT over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>MQTT_WSS</code> - MQTT over WebSocket.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>HTTPS</code> - HTTP over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn application_protocol(&self) -> ::std::option::Option<&crate::types::ApplicationProtocol> {
        self.application_protocol.as_ref()
    }
    /// <p>An object that speciﬁes the client certificate conﬁguration for a domain.</p>
    pub fn client_certificate_config(&self) -> ::std::option::Option<&crate::types::ClientCertificateConfig> {
        self.client_certificate_config.as_ref()
    }
}
impl CreateDomainConfigurationInput {
    /// Creates a new builder-style object to manufacture [`CreateDomainConfigurationInput`](crate::operation::create_domain_configuration::CreateDomainConfigurationInput).
    pub fn builder() -> crate::operation::create_domain_configuration::builders::CreateDomainConfigurationInputBuilder {
        crate::operation::create_domain_configuration::builders::CreateDomainConfigurationInputBuilder::default()
    }
}

/// A builder for [`CreateDomainConfigurationInput`](crate::operation::create_domain_configuration::CreateDomainConfigurationInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateDomainConfigurationInputBuilder {
    pub(crate) domain_configuration_name: ::std::option::Option<::std::string::String>,
    pub(crate) domain_name: ::std::option::Option<::std::string::String>,
    pub(crate) server_certificate_arns: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) validation_certificate_arn: ::std::option::Option<::std::string::String>,
    pub(crate) authorizer_config: ::std::option::Option<crate::types::AuthorizerConfig>,
    pub(crate) service_type: ::std::option::Option<crate::types::ServiceType>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) tls_config: ::std::option::Option<crate::types::TlsConfig>,
    pub(crate) server_certificate_config: ::std::option::Option<crate::types::ServerCertificateConfig>,
    pub(crate) authentication_type: ::std::option::Option<crate::types::AuthenticationType>,
    pub(crate) application_protocol: ::std::option::Option<crate::types::ApplicationProtocol>,
    pub(crate) client_certificate_config: ::std::option::Option<crate::types::ClientCertificateConfig>,
}
impl CreateDomainConfigurationInputBuilder {
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    /// This field is required.
    pub fn domain_configuration_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.domain_configuration_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    pub fn set_domain_configuration_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.domain_configuration_name = input;
        self
    }
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    pub fn get_domain_configuration_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.domain_configuration_name
    }
    /// <p>The name of the domain.</p>
    pub fn domain_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.domain_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the domain.</p>
    pub fn set_domain_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.domain_name = input;
        self
    }
    /// <p>The name of the domain.</p>
    pub fn get_domain_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.domain_name
    }
    /// Appends an item to `server_certificate_arns`.
    ///
    /// To override the contents of this collection use [`set_server_certificate_arns`](Self::set_server_certificate_arns).
    ///
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn server_certificate_arns(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.server_certificate_arns.unwrap_or_default();
        v.push(input.into());
        self.server_certificate_arns = ::std::option::Option::Some(v);
        self
    }
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn set_server_certificate_arns(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.server_certificate_arns = input;
        self
    }
    /// <p>The ARNs of the certificates that IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn get_server_certificate_arns(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.server_certificate_arns
    }
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn validation_certificate_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.validation_certificate_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn set_validation_certificate_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.validation_certificate_arn = input;
        self
    }
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for Amazon Web Services-managed domains.</p>
    pub fn get_validation_certificate_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.validation_certificate_arn
    }
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub fn authorizer_config(mut self, input: crate::types::AuthorizerConfig) -> Self {
        self.authorizer_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub fn set_authorizer_config(mut self, input: ::std::option::Option<crate::types::AuthorizerConfig>) -> Self {
        self.authorizer_config = input;
        self
    }
    /// <p>An object that specifies the authorization service for a domain.</p>
    pub fn get_authorizer_config(&self) -> &::std::option::Option<crate::types::AuthorizerConfig> {
        &self.authorizer_config
    }
    /// <p>The type of service delivered by the endpoint.</p><note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub fn service_type(mut self, input: crate::types::ServiceType) -> Self {
        self.service_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of service delivered by the endpoint.</p><note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub fn set_service_type(mut self, input: ::std::option::Option<crate::types::ServiceType>) -> Self {
        self.service_type = input;
        self
    }
    /// <p>The type of service delivered by the endpoint.</p><note>
    /// <p>Amazon Web Services IoT Core currently supports only the <code>DATA</code> service type.</p>
    /// </note>
    pub fn get_service_type(&self) -> &::std::option::Option<crate::types::ServiceType> {
        &self.service_type
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Metadata which can be used to manage the domain configuration.</p><note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>Metadata which can be used to manage the domain configuration.</p><note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Metadata which can be used to manage the domain configuration.</p><note>
    /// <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p>
    /// <p>For the CLI command-line parameter use format: &amp;&amp;tags "key1=value1&amp;key2=value2..."</p>
    /// <p>For the cli-input-json file use format: "tags": "key1=value1&amp;key2=value2..."</p>
    /// </note>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>An object that specifies the TLS configuration for a domain.</p>
    pub fn tls_config(mut self, input: crate::types::TlsConfig) -> Self {
        self.tls_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that specifies the TLS configuration for a domain.</p>
    pub fn set_tls_config(mut self, input: ::std::option::Option<crate::types::TlsConfig>) -> Self {
        self.tls_config = input;
        self
    }
    /// <p>An object that specifies the TLS configuration for a domain.</p>
    pub fn get_tls_config(&self) -> &::std::option::Option<crate::types::TlsConfig> {
        &self.tls_config
    }
    /// <p>The server certificate configuration.</p>
    pub fn server_certificate_config(mut self, input: crate::types::ServerCertificateConfig) -> Self {
        self.server_certificate_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The server certificate configuration.</p>
    pub fn set_server_certificate_config(mut self, input: ::std::option::Option<crate::types::ServerCertificateConfig>) -> Self {
        self.server_certificate_config = input;
        self
    }
    /// <p>The server certificate configuration.</p>
    pub fn get_server_certificate_config(&self) -> &::std::option::Option<crate::types::ServerCertificateConfig> {
        &self.server_certificate_config
    }
    /// <p>An enumerated string that speciﬁes the authentication type.</p>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH_X509</code> - Use custom authentication and authorization with additional details from the X.509 client certificate.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH</code> - Use custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">Custom authentication and authorization</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_X509</code> - Use X.509 client certificates without custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/x509-client-certs.html">X.509 client certificates</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_SIGV4</code> - Use Amazon Web Services Signature Version 4. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">IAM users, groups, and roles</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn authentication_type(mut self, input: crate::types::AuthenticationType) -> Self {
        self.authentication_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>An enumerated string that speciﬁes the authentication type.</p>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH_X509</code> - Use custom authentication and authorization with additional details from the X.509 client certificate.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH</code> - Use custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">Custom authentication and authorization</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_X509</code> - Use X.509 client certificates without custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/x509-client-certs.html">X.509 client certificates</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_SIGV4</code> - Use Amazon Web Services Signature Version 4. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">IAM users, groups, and roles</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn set_authentication_type(mut self, input: ::std::option::Option<crate::types::AuthenticationType>) -> Self {
        self.authentication_type = input;
        self
    }
    /// <p>An enumerated string that speciﬁes the authentication type.</p>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH_X509</code> - Use custom authentication and authorization with additional details from the X.509 client certificate.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>CUSTOM_AUTH</code> - Use custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">Custom authentication and authorization</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_X509</code> - Use X.509 client certificates without custom authentication and authorization. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/x509-client-certs.html">X.509 client certificates</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>AWS_SIGV4</code> - Use Amazon Web Services Signature Version 4. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/custom-authentication.html">IAM users, groups, and roles</a>.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify authentication type. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn get_authentication_type(&self) -> &::std::option::Option<crate::types::AuthenticationType> {
        &self.authentication_type
    }
    /// <p>An enumerated string that speciﬁes the application-layer protocol.</p>
    /// <ul>
    /// <li>
    /// <p><code>SECURE_MQTT</code> - MQTT over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>MQTT_WSS</code> - MQTT over WebSocket.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>HTTPS</code> - HTTP over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn application_protocol(mut self, input: crate::types::ApplicationProtocol) -> Self {
        self.application_protocol = ::std::option::Option::Some(input);
        self
    }
    /// <p>An enumerated string that speciﬁes the application-layer protocol.</p>
    /// <ul>
    /// <li>
    /// <p><code>SECURE_MQTT</code> - MQTT over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>MQTT_WSS</code> - MQTT over WebSocket.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>HTTPS</code> - HTTP over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn set_application_protocol(mut self, input: ::std::option::Option<crate::types::ApplicationProtocol>) -> Self {
        self.application_protocol = input;
        self
    }
    /// <p>An enumerated string that speciﬁes the application-layer protocol.</p>
    /// <ul>
    /// <li>
    /// <p><code>SECURE_MQTT</code> - MQTT over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>MQTT_WSS</code> - MQTT over WebSocket.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>HTTPS</code> - HTTP over TLS.</p></li>
    /// </ul>
    /// <ul>
    /// <li>
    /// <p><code>DEFAULT</code> - Use a combination of port and Application Layer Protocol Negotiation (ALPN) to specify application_layer protocol. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/protocols.html">Device communication protocols</a>.</p></li>
    /// </ul>
    pub fn get_application_protocol(&self) -> &::std::option::Option<crate::types::ApplicationProtocol> {
        &self.application_protocol
    }
    /// <p>An object that speciﬁes the client certificate conﬁguration for a domain.</p>
    pub fn client_certificate_config(mut self, input: crate::types::ClientCertificateConfig) -> Self {
        self.client_certificate_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that speciﬁes the client certificate conﬁguration for a domain.</p>
    pub fn set_client_certificate_config(mut self, input: ::std::option::Option<crate::types::ClientCertificateConfig>) -> Self {
        self.client_certificate_config = input;
        self
    }
    /// <p>An object that speciﬁes the client certificate conﬁguration for a domain.</p>
    pub fn get_client_certificate_config(&self) -> &::std::option::Option<crate::types::ClientCertificateConfig> {
        &self.client_certificate_config
    }
    /// Consumes the builder and constructs a [`CreateDomainConfigurationInput`](crate::operation::create_domain_configuration::CreateDomainConfigurationInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_domain_configuration::CreateDomainConfigurationInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::create_domain_configuration::CreateDomainConfigurationInput {
            domain_configuration_name: self.domain_configuration_name,
            domain_name: self.domain_name,
            server_certificate_arns: self.server_certificate_arns,
            validation_certificate_arn: self.validation_certificate_arn,
            authorizer_config: self.authorizer_config,
            service_type: self.service_type,
            tags: self.tags,
            tls_config: self.tls_config,
            server_certificate_config: self.server_certificate_config,
            authentication_type: self.authentication_type,
            application_protocol: self.application_protocol,
            client_certificate_config: self.client_certificate_config,
        })
    }
}
