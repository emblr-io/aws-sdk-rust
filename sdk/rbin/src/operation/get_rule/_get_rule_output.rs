// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub identifier: ::std::option::Option<::std::string::String>,
    /// <p>The retention rule description.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The resource type retained by the retention rule.</p>
    pub resource_type: ::std::option::Option<crate::types::ResourceType>,
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub retention_period: ::std::option::Option<crate::types::RetentionPeriod>,
    /// <p>\[Tag-level retention rules only\] Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub resource_tags: ::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>>,
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub status: ::std::option::Option<crate::types::RuleStatus>,
    /// <p>Information about the retention rule lock configuration.</p>
    pub lock_configuration: ::std::option::Option<crate::types::LockConfiguration>,
    /// <p>\[Region-level retention rules only\] The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub lock_state: ::std::option::Option<crate::types::LockState>,
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub lock_end_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub rule_arn: ::std::option::Option<::std::string::String>,
    /// <p>\[Region-level retention rules only\] Information about the exclusion tags used to identify resources that are to be excluded, or ignored, by the retention rule.</p>
    pub exclude_resource_tags: ::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>>,
    _request_id: Option<String>,
}
impl GetRuleOutput {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(&self) -> ::std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The retention rule description.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(&self) -> ::std::option::Option<&crate::types::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(&self) -> ::std::option::Option<&crate::types::RetentionPeriod> {
        self.retention_period.as_ref()
    }
    /// <p>\[Tag-level retention rules only\] Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.resource_tags.is_none()`.
    pub fn resource_tags(&self) -> &[crate::types::ResourceTag] {
        self.resource_tags.as_deref().unwrap_or_default()
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::RuleStatus> {
        self.status.as_ref()
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn lock_configuration(&self) -> ::std::option::Option<&crate::types::LockConfiguration> {
        self.lock_configuration.as_ref()
    }
    /// <p>\[Region-level retention rules only\] The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn lock_state(&self) -> ::std::option::Option<&crate::types::LockState> {
        self.lock_state.as_ref()
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn lock_end_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.lock_end_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn rule_arn(&self) -> ::std::option::Option<&str> {
        self.rule_arn.as_deref()
    }
    /// <p>\[Region-level retention rules only\] Information about the exclusion tags used to identify resources that are to be excluded, or ignored, by the retention rule.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.exclude_resource_tags.is_none()`.
    pub fn exclude_resource_tags(&self) -> &[crate::types::ResourceTag] {
        self.exclude_resource_tags.as_deref().unwrap_or_default()
    }
}
impl ::aws_types::request_id::RequestId for GetRuleOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetRuleOutput {
    /// Creates a new builder-style object to manufacture [`GetRuleOutput`](crate::operation::get_rule::GetRuleOutput).
    pub fn builder() -> crate::operation::get_rule::builders::GetRuleOutputBuilder {
        crate::operation::get_rule::builders::GetRuleOutputBuilder::default()
    }
}

/// A builder for [`GetRuleOutput`](crate::operation::get_rule::GetRuleOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GetRuleOutputBuilder {
    pub(crate) identifier: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) resource_type: ::std::option::Option<crate::types::ResourceType>,
    pub(crate) retention_period: ::std::option::Option<crate::types::RetentionPeriod>,
    pub(crate) resource_tags: ::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>>,
    pub(crate) status: ::std::option::Option<crate::types::RuleStatus>,
    pub(crate) lock_configuration: ::std::option::Option<crate::types::LockConfiguration>,
    pub(crate) lock_state: ::std::option::Option<crate::types::LockState>,
    pub(crate) lock_end_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) rule_arn: ::std::option::Option<::std::string::String>,
    pub(crate) exclude_resource_tags: ::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>>,
    _request_id: Option<String>,
}
impl GetRuleOutputBuilder {
    /// <p>The unique ID of the retention rule.</p>
    pub fn identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique ID of the retention rule.</p>
    pub fn set_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.identifier = input;
        self
    }
    /// <p>The unique ID of the retention rule.</p>
    pub fn get_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.identifier
    }
    /// <p>The retention rule description.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The retention rule description.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The retention rule description.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn resource_type(mut self, input: crate::types::ResourceType) -> Self {
        self.resource_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn set_resource_type(mut self, input: ::std::option::Option<crate::types::ResourceType>) -> Self {
        self.resource_type = input;
        self
    }
    /// <p>The resource type retained by the retention rule.</p>
    pub fn get_resource_type(&self) -> &::std::option::Option<crate::types::ResourceType> {
        &self.resource_type
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn retention_period(mut self, input: crate::types::RetentionPeriod) -> Self {
        self.retention_period = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn set_retention_period(mut self, input: ::std::option::Option<crate::types::RetentionPeriod>) -> Self {
        self.retention_period = input;
        self
    }
    /// <p>Information about the retention period for which the retention rule is to retain resources.</p>
    pub fn get_retention_period(&self) -> &::std::option::Option<crate::types::RetentionPeriod> {
        &self.retention_period
    }
    /// Appends an item to `resource_tags`.
    ///
    /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
    ///
    /// <p>\[Tag-level retention rules only\] Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn resource_tags(mut self, input: crate::types::ResourceTag) -> Self {
        let mut v = self.resource_tags.unwrap_or_default();
        v.push(input);
        self.resource_tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>\[Tag-level retention rules only\] Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn set_resource_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>>) -> Self {
        self.resource_tags = input;
        self
    }
    /// <p>\[Tag-level retention rules only\] Information about the resource tags used to identify resources that are retained by the retention rule.</p>
    pub fn get_resource_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>> {
        &self.resource_tags
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn status(mut self, input: crate::types::RuleStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::RuleStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The state of the retention rule. Only retention rules that are in the <code>available</code> state retain resources.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::RuleStatus> {
        &self.status
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn lock_configuration(mut self, input: crate::types::LockConfiguration) -> Self {
        self.lock_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn set_lock_configuration(mut self, input: ::std::option::Option<crate::types::LockConfiguration>) -> Self {
        self.lock_configuration = input;
        self
    }
    /// <p>Information about the retention rule lock configuration.</p>
    pub fn get_lock_configuration(&self) -> &::std::option::Option<crate::types::LockConfiguration> {
        &self.lock_configuration
    }
    /// <p>\[Region-level retention rules only\] The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn lock_state(mut self, input: crate::types::LockState) -> Self {
        self.lock_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>\[Region-level retention rules only\] The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn set_lock_state(mut self, input: ::std::option::Option<crate::types::LockState>) -> Self {
        self.lock_state = input;
        self
    }
    /// <p>\[Region-level retention rules only\] The lock state for the retention rule.</p>
    /// <ul>
    /// <li>
    /// <p><code>locked</code> - The retention rule is locked and can't be modified or deleted.</p></li>
    /// <li>
    /// <p><code>pending_unlock</code> - The retention rule has been unlocked but it is still within the unlock delay period. The retention rule can be modified or deleted only after the unlock delay period has expired.</p></li>
    /// <li>
    /// <p><code>unlocked</code> - The retention rule is unlocked and it can be modified or deleted by any user with the required permissions.</p></li>
    /// <li>
    /// <p><code>null</code> - The retention rule has never been locked. Once a retention rule has been locked, it can transition between the <code>locked</code> and <code>unlocked</code> states only; it can never transition back to <code>null</code>.</p></li>
    /// </ul>
    pub fn get_lock_state(&self) -> &::std::option::Option<crate::types::LockState> {
        &self.lock_state
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn lock_end_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.lock_end_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn set_lock_end_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.lock_end_time = input;
        self
    }
    /// <p>The date and time at which the unlock delay is set to expire. Only returned for retention rules that have been unlocked and that are still within the unlock delay period.</p>
    pub fn get_lock_end_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.lock_end_time
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn rule_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.rule_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn set_rule_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.rule_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the retention rule.</p>
    pub fn get_rule_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.rule_arn
    }
    /// Appends an item to `exclude_resource_tags`.
    ///
    /// To override the contents of this collection use [`set_exclude_resource_tags`](Self::set_exclude_resource_tags).
    ///
    /// <p>\[Region-level retention rules only\] Information about the exclusion tags used to identify resources that are to be excluded, or ignored, by the retention rule.</p>
    pub fn exclude_resource_tags(mut self, input: crate::types::ResourceTag) -> Self {
        let mut v = self.exclude_resource_tags.unwrap_or_default();
        v.push(input);
        self.exclude_resource_tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>\[Region-level retention rules only\] Information about the exclusion tags used to identify resources that are to be excluded, or ignored, by the retention rule.</p>
    pub fn set_exclude_resource_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>>) -> Self {
        self.exclude_resource_tags = input;
        self
    }
    /// <p>\[Region-level retention rules only\] Information about the exclusion tags used to identify resources that are to be excluded, or ignored, by the retention rule.</p>
    pub fn get_exclude_resource_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ResourceTag>> {
        &self.exclude_resource_tags
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetRuleOutput`](crate::operation::get_rule::GetRuleOutput).
    pub fn build(self) -> crate::operation::get_rule::GetRuleOutput {
        crate::operation::get_rule::GetRuleOutput {
            identifier: self.identifier,
            description: self.description,
            resource_type: self.resource_type,
            retention_period: self.retention_period,
            resource_tags: self.resource_tags,
            status: self.status,
            lock_configuration: self.lock_configuration,
            lock_state: self.lock_state,
            lock_end_time: self.lock_end_time,
            rule_arn: self.rule_arn,
            exclude_resource_tags: self.exclude_resource_tags,
            _request_id: self._request_id,
        }
    }
}
