// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateChannelInput {
    /// <p>The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.</p>
    pub channel_group_name: ::std::option::Option<::std::string::String>,
    /// <p>The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.</p>
    pub channel_name: ::std::option::Option<::std::string::String>,
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior.</p>
    /// <p>The allowed values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>HLS</code> - The HLS streaming specification (which defines M3U8 manifests and TS segments).</p></li>
    /// <li>
    /// <p><code>CMAF</code> - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).</p></li>
    /// </ul>
    pub input_type: ::std::option::Option<crate::types::InputType>,
    /// <p>Enter any descriptive text that helps you to identify the channel.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub input_switch_configuration: ::std::option::Option<crate::types::InputSwitchConfiguration>,
    /// <p>The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub output_header_configuration: ::std::option::Option<crate::types::OutputHeaderConfiguration>,
    /// <p>A comma-separated list of tag key:value pairs that you define. For example:</p>
    /// <p><code>"Key1": "Value1",</code></p>
    /// <p><code>"Key2": "Value2"</code></p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateChannelInput {
    /// <p>The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.</p>
    pub fn channel_group_name(&self) -> ::std::option::Option<&str> {
        self.channel_group_name.as_deref()
    }
    /// <p>The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.</p>
    pub fn channel_name(&self) -> ::std::option::Option<&str> {
        self.channel_name.as_deref()
    }
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior.</p>
    /// <p>The allowed values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>HLS</code> - The HLS streaming specification (which defines M3U8 manifests and TS segments).</p></li>
    /// <li>
    /// <p><code>CMAF</code> - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).</p></li>
    /// </ul>
    pub fn input_type(&self) -> ::std::option::Option<&crate::types::InputType> {
        self.input_type.as_ref()
    }
    /// <p>Enter any descriptive text that helps you to identify the channel.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn input_switch_configuration(&self) -> ::std::option::Option<&crate::types::InputSwitchConfiguration> {
        self.input_switch_configuration.as_ref()
    }
    /// <p>The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn output_header_configuration(&self) -> ::std::option::Option<&crate::types::OutputHeaderConfiguration> {
        self.output_header_configuration.as_ref()
    }
    /// <p>A comma-separated list of tag key:value pairs that you define. For example:</p>
    /// <p><code>"Key1": "Value1",</code></p>
    /// <p><code>"Key2": "Value2"</code></p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl CreateChannelInput {
    /// Creates a new builder-style object to manufacture [`CreateChannelInput`](crate::operation::create_channel::CreateChannelInput).
    pub fn builder() -> crate::operation::create_channel::builders::CreateChannelInputBuilder {
        crate::operation::create_channel::builders::CreateChannelInputBuilder::default()
    }
}

/// A builder for [`CreateChannelInput`](crate::operation::create_channel::CreateChannelInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateChannelInputBuilder {
    pub(crate) channel_group_name: ::std::option::Option<::std::string::String>,
    pub(crate) channel_name: ::std::option::Option<::std::string::String>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) input_type: ::std::option::Option<crate::types::InputType>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) input_switch_configuration: ::std::option::Option<crate::types::InputSwitchConfiguration>,
    pub(crate) output_header_configuration: ::std::option::Option<crate::types::OutputHeaderConfiguration>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateChannelInputBuilder {
    /// <p>The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.</p>
    /// This field is required.
    pub fn channel_group_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.channel_group_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.</p>
    pub fn set_channel_group_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.channel_group_name = input;
        self
    }
    /// <p>The name that describes the channel group. The name is the primary identifier for the channel group, and must be unique for your account in the AWS Region.</p>
    pub fn get_channel_group_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.channel_group_name
    }
    /// <p>The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.</p>
    /// This field is required.
    pub fn channel_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.channel_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.</p>
    pub fn set_channel_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.channel_name = input;
        self
    }
    /// <p>The name that describes the channel. The name is the primary identifier for the channel, and must be unique for your account in the AWS Region and channel group. You can't change the name after you create the channel.</p>
    pub fn get_channel_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.channel_name
    }
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior.</p>
    /// <p>The allowed values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>HLS</code> - The HLS streaming specification (which defines M3U8 manifests and TS segments).</p></li>
    /// <li>
    /// <p><code>CMAF</code> - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).</p></li>
    /// </ul>
    pub fn input_type(mut self, input: crate::types::InputType) -> Self {
        self.input_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior.</p>
    /// <p>The allowed values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>HLS</code> - The HLS streaming specification (which defines M3U8 manifests and TS segments).</p></li>
    /// <li>
    /// <p><code>CMAF</code> - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).</p></li>
    /// </ul>
    pub fn set_input_type(mut self, input: ::std::option::Option<crate::types::InputType>) -> Self {
        self.input_type = input;
        self
    }
    /// <p>The input type will be an immutable field which will be used to define whether the channel will allow CMAF ingest or HLS ingest. If unprovided, it will default to HLS to preserve current behavior.</p>
    /// <p>The allowed values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>HLS</code> - The HLS streaming specification (which defines M3U8 manifests and TS segments).</p></li>
    /// <li>
    /// <p><code>CMAF</code> - The DASH-IF CMAF Ingest specification (which defines CMAF segments with optional DASH manifests).</p></li>
    /// </ul>
    pub fn get_input_type(&self) -> &::std::option::Option<crate::types::InputType> {
        &self.input_type
    }
    /// <p>Enter any descriptive text that helps you to identify the channel.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Enter any descriptive text that helps you to identify the channel.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>Enter any descriptive text that helps you to identify the channel.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn input_switch_configuration(mut self, input: crate::types::InputSwitchConfiguration) -> Self {
        self.input_switch_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn set_input_switch_configuration(mut self, input: ::std::option::Option<crate::types::InputSwitchConfiguration>) -> Self {
        self.input_switch_configuration = input;
        self
    }
    /// <p>The configuration for input switching based on the media quality confidence score (MQCS) as provided from AWS Elemental MediaLive. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn get_input_switch_configuration(&self) -> &::std::option::Option<crate::types::InputSwitchConfiguration> {
        &self.input_switch_configuration
    }
    /// <p>The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn output_header_configuration(mut self, input: crate::types::OutputHeaderConfiguration) -> Self {
        self.output_header_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn set_output_header_configuration(mut self, input: ::std::option::Option<crate::types::OutputHeaderConfiguration>) -> Self {
        self.output_header_configuration = input;
        self
    }
    /// <p>The settings for what common media server data (CMSD) headers AWS Elemental MediaPackage includes in responses to the CDN. This setting is valid only when <code>InputType</code> is <code>CMAF</code>.</p>
    pub fn get_output_header_configuration(&self) -> &::std::option::Option<crate::types::OutputHeaderConfiguration> {
        &self.output_header_configuration
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A comma-separated list of tag key:value pairs that you define. For example:</p>
    /// <p><code>"Key1": "Value1",</code></p>
    /// <p><code>"Key2": "Value2"</code></p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A comma-separated list of tag key:value pairs that you define. For example:</p>
    /// <p><code>"Key1": "Value1",</code></p>
    /// <p><code>"Key2": "Value2"</code></p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A comma-separated list of tag key:value pairs that you define. For example:</p>
    /// <p><code>"Key1": "Value1",</code></p>
    /// <p><code>"Key2": "Value2"</code></p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateChannelInput`](crate::operation::create_channel::CreateChannelInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_channel::CreateChannelInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_channel::CreateChannelInput {
            channel_group_name: self.channel_group_name,
            channel_name: self.channel_name,
            client_token: self.client_token,
            input_type: self.input_type,
            description: self.description,
            input_switch_configuration: self.input_switch_configuration,
            output_header_configuration: self.output_header_configuration,
            tags: self.tags,
        })
    }
}
