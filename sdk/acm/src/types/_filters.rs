// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>This structure can be used in the <code>ListCertificates</code> action to filter the output of the certificate list.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Filters {
    /// <p>Specify one or more <code>ExtendedKeyUsage</code> extension values.</p>
    pub extended_key_usage: ::std::option::Option<::std::vec::Vec<crate::types::ExtendedKeyUsageName>>,
    /// <p>Specify one or more <code>KeyUsage</code> extension values.</p>
    pub key_usage: ::std::option::Option<::std::vec::Vec<crate::types::KeyUsageName>>,
    /// <p>Specify one or more algorithms that can be used to generate key pairs.</p>
    /// <p>Default filtering returns only <code>RSA_1024</code> and <code>RSA_2048</code> certificates that have at least one domain. To return other certificate types, provide the desired type signatures in a comma-separated list. For example, <code>"keyTypes": \["RSA_2048","RSA_4096"\]</code> returns both <code>RSA_2048</code> and <code>RSA_4096</code> certificates.</p>
    pub key_types: ::std::option::Option<::std::vec::Vec<crate::types::KeyAlgorithm>>,
    /// <p>Specify <code>ENABLED</code> or <code>DISABLED</code> to identify certificates that can be exported.</p>
    pub export_option: ::std::option::Option<crate::types::CertificateExport>,
    /// <p>Identifies the Amazon Web Services service that manages the certificate issued by ACM.</p>
    pub managed_by: ::std::option::Option<crate::types::CertificateManagedBy>,
}
impl Filters {
    /// <p>Specify one or more <code>ExtendedKeyUsage</code> extension values.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.extended_key_usage.is_none()`.
    pub fn extended_key_usage(&self) -> &[crate::types::ExtendedKeyUsageName] {
        self.extended_key_usage.as_deref().unwrap_or_default()
    }
    /// <p>Specify one or more <code>KeyUsage</code> extension values.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.key_usage.is_none()`.
    pub fn key_usage(&self) -> &[crate::types::KeyUsageName] {
        self.key_usage.as_deref().unwrap_or_default()
    }
    /// <p>Specify one or more algorithms that can be used to generate key pairs.</p>
    /// <p>Default filtering returns only <code>RSA_1024</code> and <code>RSA_2048</code> certificates that have at least one domain. To return other certificate types, provide the desired type signatures in a comma-separated list. For example, <code>"keyTypes": \["RSA_2048","RSA_4096"\]</code> returns both <code>RSA_2048</code> and <code>RSA_4096</code> certificates.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.key_types.is_none()`.
    pub fn key_types(&self) -> &[crate::types::KeyAlgorithm] {
        self.key_types.as_deref().unwrap_or_default()
    }
    /// <p>Specify <code>ENABLED</code> or <code>DISABLED</code> to identify certificates that can be exported.</p>
    pub fn export_option(&self) -> ::std::option::Option<&crate::types::CertificateExport> {
        self.export_option.as_ref()
    }
    /// <p>Identifies the Amazon Web Services service that manages the certificate issued by ACM.</p>
    pub fn managed_by(&self) -> ::std::option::Option<&crate::types::CertificateManagedBy> {
        self.managed_by.as_ref()
    }
}
impl Filters {
    /// Creates a new builder-style object to manufacture [`Filters`](crate::types::Filters).
    pub fn builder() -> crate::types::builders::FiltersBuilder {
        crate::types::builders::FiltersBuilder::default()
    }
}

/// A builder for [`Filters`](crate::types::Filters).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct FiltersBuilder {
    pub(crate) extended_key_usage: ::std::option::Option<::std::vec::Vec<crate::types::ExtendedKeyUsageName>>,
    pub(crate) key_usage: ::std::option::Option<::std::vec::Vec<crate::types::KeyUsageName>>,
    pub(crate) key_types: ::std::option::Option<::std::vec::Vec<crate::types::KeyAlgorithm>>,
    pub(crate) export_option: ::std::option::Option<crate::types::CertificateExport>,
    pub(crate) managed_by: ::std::option::Option<crate::types::CertificateManagedBy>,
}
impl FiltersBuilder {
    /// Appends an item to `extended_key_usage`.
    ///
    /// To override the contents of this collection use [`set_extended_key_usage`](Self::set_extended_key_usage).
    ///
    /// <p>Specify one or more <code>ExtendedKeyUsage</code> extension values.</p>
    pub fn extended_key_usage(mut self, input: crate::types::ExtendedKeyUsageName) -> Self {
        let mut v = self.extended_key_usage.unwrap_or_default();
        v.push(input);
        self.extended_key_usage = ::std::option::Option::Some(v);
        self
    }
    /// <p>Specify one or more <code>ExtendedKeyUsage</code> extension values.</p>
    pub fn set_extended_key_usage(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ExtendedKeyUsageName>>) -> Self {
        self.extended_key_usage = input;
        self
    }
    /// <p>Specify one or more <code>ExtendedKeyUsage</code> extension values.</p>
    pub fn get_extended_key_usage(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ExtendedKeyUsageName>> {
        &self.extended_key_usage
    }
    /// Appends an item to `key_usage`.
    ///
    /// To override the contents of this collection use [`set_key_usage`](Self::set_key_usage).
    ///
    /// <p>Specify one or more <code>KeyUsage</code> extension values.</p>
    pub fn key_usage(mut self, input: crate::types::KeyUsageName) -> Self {
        let mut v = self.key_usage.unwrap_or_default();
        v.push(input);
        self.key_usage = ::std::option::Option::Some(v);
        self
    }
    /// <p>Specify one or more <code>KeyUsage</code> extension values.</p>
    pub fn set_key_usage(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::KeyUsageName>>) -> Self {
        self.key_usage = input;
        self
    }
    /// <p>Specify one or more <code>KeyUsage</code> extension values.</p>
    pub fn get_key_usage(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::KeyUsageName>> {
        &self.key_usage
    }
    /// Appends an item to `key_types`.
    ///
    /// To override the contents of this collection use [`set_key_types`](Self::set_key_types).
    ///
    /// <p>Specify one or more algorithms that can be used to generate key pairs.</p>
    /// <p>Default filtering returns only <code>RSA_1024</code> and <code>RSA_2048</code> certificates that have at least one domain. To return other certificate types, provide the desired type signatures in a comma-separated list. For example, <code>"keyTypes": \["RSA_2048","RSA_4096"\]</code> returns both <code>RSA_2048</code> and <code>RSA_4096</code> certificates.</p>
    pub fn key_types(mut self, input: crate::types::KeyAlgorithm) -> Self {
        let mut v = self.key_types.unwrap_or_default();
        v.push(input);
        self.key_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>Specify one or more algorithms that can be used to generate key pairs.</p>
    /// <p>Default filtering returns only <code>RSA_1024</code> and <code>RSA_2048</code> certificates that have at least one domain. To return other certificate types, provide the desired type signatures in a comma-separated list. For example, <code>"keyTypes": \["RSA_2048","RSA_4096"\]</code> returns both <code>RSA_2048</code> and <code>RSA_4096</code> certificates.</p>
    pub fn set_key_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::KeyAlgorithm>>) -> Self {
        self.key_types = input;
        self
    }
    /// <p>Specify one or more algorithms that can be used to generate key pairs.</p>
    /// <p>Default filtering returns only <code>RSA_1024</code> and <code>RSA_2048</code> certificates that have at least one domain. To return other certificate types, provide the desired type signatures in a comma-separated list. For example, <code>"keyTypes": \["RSA_2048","RSA_4096"\]</code> returns both <code>RSA_2048</code> and <code>RSA_4096</code> certificates.</p>
    pub fn get_key_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::KeyAlgorithm>> {
        &self.key_types
    }
    /// <p>Specify <code>ENABLED</code> or <code>DISABLED</code> to identify certificates that can be exported.</p>
    pub fn export_option(mut self, input: crate::types::CertificateExport) -> Self {
        self.export_option = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify <code>ENABLED</code> or <code>DISABLED</code> to identify certificates that can be exported.</p>
    pub fn set_export_option(mut self, input: ::std::option::Option<crate::types::CertificateExport>) -> Self {
        self.export_option = input;
        self
    }
    /// <p>Specify <code>ENABLED</code> or <code>DISABLED</code> to identify certificates that can be exported.</p>
    pub fn get_export_option(&self) -> &::std::option::Option<crate::types::CertificateExport> {
        &self.export_option
    }
    /// <p>Identifies the Amazon Web Services service that manages the certificate issued by ACM.</p>
    pub fn managed_by(mut self, input: crate::types::CertificateManagedBy) -> Self {
        self.managed_by = ::std::option::Option::Some(input);
        self
    }
    /// <p>Identifies the Amazon Web Services service that manages the certificate issued by ACM.</p>
    pub fn set_managed_by(mut self, input: ::std::option::Option<crate::types::CertificateManagedBy>) -> Self {
        self.managed_by = input;
        self
    }
    /// <p>Identifies the Amazon Web Services service that manages the certificate issued by ACM.</p>
    pub fn get_managed_by(&self) -> &::std::option::Option<crate::types::CertificateManagedBy> {
        &self.managed_by
    }
    /// Consumes the builder and constructs a [`Filters`](crate::types::Filters).
    pub fn build(self) -> crate::types::Filters {
        crate::types::Filters {
            extended_key_usage: self.extended_key_usage,
            key_usage: self.key_usage,
            key_types: self.key_types,
            export_option: self.export_option,
            managed_by: self.managed_by,
        }
    }
}
