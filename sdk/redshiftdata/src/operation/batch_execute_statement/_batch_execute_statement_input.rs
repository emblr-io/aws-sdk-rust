// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct BatchExecuteStatementInput {
    /// <p>One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.</p>
    pub sqls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.</p>
    pub cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.</p>
    pub secret_arn: ::std::option::Option<::std::string::String>,
    /// <p>The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.</p>
    pub db_user: ::std::option::Option<::std::string::String>,
    /// <p>The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.</p>
    pub database: ::std::option::Option<::std::string::String>,
    /// <p>A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.</p>
    pub with_event: ::std::option::Option<bool>,
    /// <p>The name of the SQL statements. You can name the SQL statements when you create them to identify the query.</p>
    pub statement_name: ::std::option::Option<::std::string::String>,
    /// <p>The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.</p>
    pub workgroup_name: ::std::option::Option<::std::string::String>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.</p>
    pub session_keep_alive_seconds: ::std::option::Option<i32>,
    /// <p>The session identifier of the query.</p>
    pub session_id: ::std::option::Option<::std::string::String>,
    /// <p>The data format of the result of the SQL statement. If no format is specified, the default is JSON.</p>
    pub result_format: ::std::option::Option<crate::types::ResultFormatString>,
}
impl BatchExecuteStatementInput {
    /// <p>One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.sqls.is_none()`.
    pub fn sqls(&self) -> &[::std::string::String] {
        self.sqls.as_deref().unwrap_or_default()
    }
    /// <p>The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.cluster_identifier.as_deref()
    }
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.</p>
    pub fn secret_arn(&self) -> ::std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
    /// <p>The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.</p>
    pub fn db_user(&self) -> ::std::option::Option<&str> {
        self.db_user.as_deref()
    }
    /// <p>The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn database(&self) -> ::std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.</p>
    pub fn with_event(&self) -> ::std::option::Option<bool> {
        self.with_event
    }
    /// <p>The name of the SQL statements. You can name the SQL statements when you create them to identify the query.</p>
    pub fn statement_name(&self) -> ::std::option::Option<&str> {
        self.statement_name.as_deref()
    }
    /// <p>The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn workgroup_name(&self) -> ::std::option::Option<&str> {
        self.workgroup_name.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.</p>
    pub fn session_keep_alive_seconds(&self) -> ::std::option::Option<i32> {
        self.session_keep_alive_seconds
    }
    /// <p>The session identifier of the query.</p>
    pub fn session_id(&self) -> ::std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The data format of the result of the SQL statement. If no format is specified, the default is JSON.</p>
    pub fn result_format(&self) -> ::std::option::Option<&crate::types::ResultFormatString> {
        self.result_format.as_ref()
    }
}
impl BatchExecuteStatementInput {
    /// Creates a new builder-style object to manufacture [`BatchExecuteStatementInput`](crate::operation::batch_execute_statement::BatchExecuteStatementInput).
    pub fn builder() -> crate::operation::batch_execute_statement::builders::BatchExecuteStatementInputBuilder {
        crate::operation::batch_execute_statement::builders::BatchExecuteStatementInputBuilder::default()
    }
}

/// A builder for [`BatchExecuteStatementInput`](crate::operation::batch_execute_statement::BatchExecuteStatementInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct BatchExecuteStatementInputBuilder {
    pub(crate) sqls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) secret_arn: ::std::option::Option<::std::string::String>,
    pub(crate) db_user: ::std::option::Option<::std::string::String>,
    pub(crate) database: ::std::option::Option<::std::string::String>,
    pub(crate) with_event: ::std::option::Option<bool>,
    pub(crate) statement_name: ::std::option::Option<::std::string::String>,
    pub(crate) workgroup_name: ::std::option::Option<::std::string::String>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) session_keep_alive_seconds: ::std::option::Option<i32>,
    pub(crate) session_id: ::std::option::Option<::std::string::String>,
    pub(crate) result_format: ::std::option::Option<crate::types::ResultFormatString>,
}
impl BatchExecuteStatementInputBuilder {
    /// Appends an item to `sqls`.
    ///
    /// To override the contents of this collection use [`set_sqls`](Self::set_sqls).
    ///
    /// <p>One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.</p>
    pub fn sqls(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.sqls.unwrap_or_default();
        v.push(input.into());
        self.sqls = ::std::option::Option::Some(v);
        self
    }
    /// <p>One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.</p>
    pub fn set_sqls(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.sqls = input;
        self
    }
    /// <p>One or more SQL statements to run. The SQL statements are run as a single transaction. They run serially in the order of the array. Subsequent SQL statements don't start until the previous statement in the array completes. If any SQL statement fails, then because they are run as one transaction, all work is rolled back.</p>
    pub fn get_sqls(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.sqls
    }
    /// <p>The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn set_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_identifier = input;
        self
    }
    /// <p>The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn get_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_identifier
    }
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.</p>
    pub fn secret_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.secret_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.</p>
    pub fn set_secret_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.secret_arn = input;
        self
    }
    /// <p>The name or ARN of the secret that enables access to the database. This parameter is required when authenticating using Secrets Manager.</p>
    pub fn get_secret_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.secret_arn
    }
    /// <p>The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.</p>
    pub fn db_user(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_user = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.</p>
    pub fn set_db_user(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_user = input;
        self
    }
    /// <p>The database user name. This parameter is required when connecting to a cluster as a database user and authenticating using temporary credentials.</p>
    pub fn get_db_user(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_user
    }
    /// <p>The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn database(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn set_database(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database = input;
        self
    }
    /// <p>The name of the database. This parameter is required when authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn get_database(&self) -> &::std::option::Option<::std::string::String> {
        &self.database
    }
    /// <p>A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.</p>
    pub fn with_event(mut self, input: bool) -> Self {
        self.with_event = ::std::option::Option::Some(input);
        self
    }
    /// <p>A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.</p>
    pub fn set_with_event(mut self, input: ::std::option::Option<bool>) -> Self {
        self.with_event = input;
        self
    }
    /// <p>A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statements run.</p>
    pub fn get_with_event(&self) -> &::std::option::Option<bool> {
        &self.with_event
    }
    /// <p>The name of the SQL statements. You can name the SQL statements when you create them to identify the query.</p>
    pub fn statement_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.statement_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the SQL statements. You can name the SQL statements when you create them to identify the query.</p>
    pub fn set_statement_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.statement_name = input;
        self
    }
    /// <p>The name of the SQL statements. You can name the SQL statements when you create them to identify the query.</p>
    pub fn get_statement_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.statement_name
    }
    /// <p>The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn workgroup_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.workgroup_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn set_workgroup_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.workgroup_name = input;
        self
    }
    /// <p>The serverless workgroup name or Amazon Resource Name (ARN). This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.</p>
    pub fn get_workgroup_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.workgroup_name
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.</p>
    pub fn session_keep_alive_seconds(mut self, input: i32) -> Self {
        self.session_keep_alive_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.</p>
    pub fn set_session_keep_alive_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.session_keep_alive_seconds = input;
        self
    }
    /// <p>The number of seconds to keep the session alive after the query finishes. The maximum time a session can keep alive is 24 hours. After 24 hours, the session is forced closed and the query is terminated.</p>
    pub fn get_session_keep_alive_seconds(&self) -> &::std::option::Option<i32> {
        &self.session_keep_alive_seconds
    }
    /// <p>The session identifier of the query.</p>
    pub fn session_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.session_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The session identifier of the query.</p>
    pub fn set_session_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.session_id = input;
        self
    }
    /// <p>The session identifier of the query.</p>
    pub fn get_session_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.session_id
    }
    /// <p>The data format of the result of the SQL statement. If no format is specified, the default is JSON.</p>
    pub fn result_format(mut self, input: crate::types::ResultFormatString) -> Self {
        self.result_format = ::std::option::Option::Some(input);
        self
    }
    /// <p>The data format of the result of the SQL statement. If no format is specified, the default is JSON.</p>
    pub fn set_result_format(mut self, input: ::std::option::Option<crate::types::ResultFormatString>) -> Self {
        self.result_format = input;
        self
    }
    /// <p>The data format of the result of the SQL statement. If no format is specified, the default is JSON.</p>
    pub fn get_result_format(&self) -> &::std::option::Option<crate::types::ResultFormatString> {
        &self.result_format
    }
    /// Consumes the builder and constructs a [`BatchExecuteStatementInput`](crate::operation::batch_execute_statement::BatchExecuteStatementInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::batch_execute_statement::BatchExecuteStatementInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::batch_execute_statement::BatchExecuteStatementInput {
            sqls: self.sqls,
            cluster_identifier: self.cluster_identifier,
            secret_arn: self.secret_arn,
            db_user: self.db_user,
            database: self.database,
            with_event: self.with_event,
            statement_name: self.statement_name,
            workgroup_name: self.workgroup_name,
            client_token: self.client_token,
            session_keep_alive_seconds: self.session_keep_alive_seconds,
            session_id: self.session_id,
            result_format: self.result_format,
        })
    }
}
