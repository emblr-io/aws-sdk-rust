// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CreateManagedLoginBrandingInput {
    /// <p>The ID of the user pool where you want to create a new branding style.</p>
    pub user_pool_id: ::std::option::Option<::std::string::String>,
    /// <p>The app client that you want to create the branding style for. Each style is linked to an app client until you delete it.</p>
    pub client_id: ::std::option::Option<::std::string::String>,
    /// <p>When true, applies the default branding style options. These default options are managed by Amazon Cognito. You can modify them later in the branding designer.</p>
    /// <p>When you specify <code>true</code> for this option, you must also omit values for <code>Settings</code> and <code>Assets</code> in the request.</p>
    pub use_cognito_provided_values: ::std::option::Option<bool>,
    /// <p>A JSON file, encoded as a <code>Document</code> type, with the the settings that you want to apply to your style.</p>
    pub settings: ::std::option::Option<::aws_smithy_types::Document>,
    /// <p>An array of image files that you want to apply to functions like backgrounds, logos, and icons. Each object must also indicate whether it is for dark mode, light mode, or browser-adaptive mode.</p>
    pub assets: ::std::option::Option<::std::vec::Vec<crate::types::AssetType>>,
}
impl CreateManagedLoginBrandingInput {
    /// <p>The ID of the user pool where you want to create a new branding style.</p>
    pub fn user_pool_id(&self) -> ::std::option::Option<&str> {
        self.user_pool_id.as_deref()
    }
    /// <p>The app client that you want to create the branding style for. Each style is linked to an app client until you delete it.</p>
    pub fn client_id(&self) -> ::std::option::Option<&str> {
        self.client_id.as_deref()
    }
    /// <p>When true, applies the default branding style options. These default options are managed by Amazon Cognito. You can modify them later in the branding designer.</p>
    /// <p>When you specify <code>true</code> for this option, you must also omit values for <code>Settings</code> and <code>Assets</code> in the request.</p>
    pub fn use_cognito_provided_values(&self) -> ::std::option::Option<bool> {
        self.use_cognito_provided_values
    }
    /// <p>A JSON file, encoded as a <code>Document</code> type, with the the settings that you want to apply to your style.</p>
    pub fn settings(&self) -> ::std::option::Option<&::aws_smithy_types::Document> {
        self.settings.as_ref()
    }
    /// <p>An array of image files that you want to apply to functions like backgrounds, logos, and icons. Each object must also indicate whether it is for dark mode, light mode, or browser-adaptive mode.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.assets.is_none()`.
    pub fn assets(&self) -> &[crate::types::AssetType] {
        self.assets.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for CreateManagedLoginBrandingInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreateManagedLoginBrandingInput");
        formatter.field("user_pool_id", &self.user_pool_id);
        formatter.field("client_id", &"*** Sensitive Data Redacted ***");
        formatter.field("use_cognito_provided_values", &self.use_cognito_provided_values);
        formatter.field("settings", &self.settings);
        formatter.field("assets", &self.assets);
        formatter.finish()
    }
}
impl CreateManagedLoginBrandingInput {
    /// Creates a new builder-style object to manufacture [`CreateManagedLoginBrandingInput`](crate::operation::create_managed_login_branding::CreateManagedLoginBrandingInput).
    pub fn builder() -> crate::operation::create_managed_login_branding::builders::CreateManagedLoginBrandingInputBuilder {
        crate::operation::create_managed_login_branding::builders::CreateManagedLoginBrandingInputBuilder::default()
    }
}

/// A builder for [`CreateManagedLoginBrandingInput`](crate::operation::create_managed_login_branding::CreateManagedLoginBrandingInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct CreateManagedLoginBrandingInputBuilder {
    pub(crate) user_pool_id: ::std::option::Option<::std::string::String>,
    pub(crate) client_id: ::std::option::Option<::std::string::String>,
    pub(crate) use_cognito_provided_values: ::std::option::Option<bool>,
    pub(crate) settings: ::std::option::Option<::aws_smithy_types::Document>,
    pub(crate) assets: ::std::option::Option<::std::vec::Vec<crate::types::AssetType>>,
}
impl CreateManagedLoginBrandingInputBuilder {
    /// <p>The ID of the user pool where you want to create a new branding style.</p>
    /// This field is required.
    pub fn user_pool_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user_pool_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the user pool where you want to create a new branding style.</p>
    pub fn set_user_pool_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user_pool_id = input;
        self
    }
    /// <p>The ID of the user pool where you want to create a new branding style.</p>
    pub fn get_user_pool_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.user_pool_id
    }
    /// <p>The app client that you want to create the branding style for. Each style is linked to an app client until you delete it.</p>
    /// This field is required.
    pub fn client_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The app client that you want to create the branding style for. Each style is linked to an app client until you delete it.</p>
    pub fn set_client_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_id = input;
        self
    }
    /// <p>The app client that you want to create the branding style for. Each style is linked to an app client until you delete it.</p>
    pub fn get_client_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_id
    }
    /// <p>When true, applies the default branding style options. These default options are managed by Amazon Cognito. You can modify them later in the branding designer.</p>
    /// <p>When you specify <code>true</code> for this option, you must also omit values for <code>Settings</code> and <code>Assets</code> in the request.</p>
    pub fn use_cognito_provided_values(mut self, input: bool) -> Self {
        self.use_cognito_provided_values = ::std::option::Option::Some(input);
        self
    }
    /// <p>When true, applies the default branding style options. These default options are managed by Amazon Cognito. You can modify them later in the branding designer.</p>
    /// <p>When you specify <code>true</code> for this option, you must also omit values for <code>Settings</code> and <code>Assets</code> in the request.</p>
    pub fn set_use_cognito_provided_values(mut self, input: ::std::option::Option<bool>) -> Self {
        self.use_cognito_provided_values = input;
        self
    }
    /// <p>When true, applies the default branding style options. These default options are managed by Amazon Cognito. You can modify them later in the branding designer.</p>
    /// <p>When you specify <code>true</code> for this option, you must also omit values for <code>Settings</code> and <code>Assets</code> in the request.</p>
    pub fn get_use_cognito_provided_values(&self) -> &::std::option::Option<bool> {
        &self.use_cognito_provided_values
    }
    /// <p>A JSON file, encoded as a <code>Document</code> type, with the the settings that you want to apply to your style.</p>
    pub fn settings(mut self, input: ::aws_smithy_types::Document) -> Self {
        self.settings = ::std::option::Option::Some(input);
        self
    }
    /// <p>A JSON file, encoded as a <code>Document</code> type, with the the settings that you want to apply to your style.</p>
    pub fn set_settings(mut self, input: ::std::option::Option<::aws_smithy_types::Document>) -> Self {
        self.settings = input;
        self
    }
    /// <p>A JSON file, encoded as a <code>Document</code> type, with the the settings that you want to apply to your style.</p>
    pub fn get_settings(&self) -> &::std::option::Option<::aws_smithy_types::Document> {
        &self.settings
    }
    /// Appends an item to `assets`.
    ///
    /// To override the contents of this collection use [`set_assets`](Self::set_assets).
    ///
    /// <p>An array of image files that you want to apply to functions like backgrounds, logos, and icons. Each object must also indicate whether it is for dark mode, light mode, or browser-adaptive mode.</p>
    pub fn assets(mut self, input: crate::types::AssetType) -> Self {
        let mut v = self.assets.unwrap_or_default();
        v.push(input);
        self.assets = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of image files that you want to apply to functions like backgrounds, logos, and icons. Each object must also indicate whether it is for dark mode, light mode, or browser-adaptive mode.</p>
    pub fn set_assets(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AssetType>>) -> Self {
        self.assets = input;
        self
    }
    /// <p>An array of image files that you want to apply to functions like backgrounds, logos, and icons. Each object must also indicate whether it is for dark mode, light mode, or browser-adaptive mode.</p>
    pub fn get_assets(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AssetType>> {
        &self.assets
    }
    /// Consumes the builder and constructs a [`CreateManagedLoginBrandingInput`](crate::operation::create_managed_login_branding::CreateManagedLoginBrandingInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_managed_login_branding::CreateManagedLoginBrandingInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::create_managed_login_branding::CreateManagedLoginBrandingInput {
            user_pool_id: self.user_pool_id,
            client_id: self.client_id,
            use_cognito_provided_values: self.use_cognito_provided_values,
            settings: self.settings,
            assets: self.assets,
        })
    }
}
impl ::std::fmt::Debug for CreateManagedLoginBrandingInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreateManagedLoginBrandingInputBuilder");
        formatter.field("user_pool_id", &self.user_pool_id);
        formatter.field("client_id", &"*** Sensitive Data Redacted ***");
        formatter.field("use_cognito_provided_values", &self.use_cognito_provided_values);
        formatter.field("settings", &self.settings);
        formatter.field("assets", &self.assets);
        formatter.finish()
    }
}
