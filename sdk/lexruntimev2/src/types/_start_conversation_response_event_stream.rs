// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a stream of events between Amazon Lex V2 and your application.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum StartConversationResponseEventStream {
    /// <p>An event sent from Amazon Lex V2 to your client application containing audio to play to the user.</p>
    AudioResponseEvent(crate::types::AudioResponseEvent),
    /// <p>Event that Amazon Lex V2 sends to indicate that the stream is still open between the client application and Amazon Lex V2</p>
    HeartbeatEvent(crate::types::HeartbeatEvent),
    /// <p>Event sent from Amazon Lex V2 to the client application containing the current state of the conversation between the user and Amazon Lex V2.</p>
    IntentResultEvent(crate::types::IntentResultEvent),
    /// <p>Event sent from Amazon Lex V2 to indicate to the client application should stop playback of audio. For example, if the client is playing a prompt that asks for the user's telephone number, the user might start to say the phone number before the prompt is complete. Amazon Lex V2 sends this event to the client application to indicate that the user is responding and that Amazon Lex V2 is processing their input.</p>
    PlaybackInterruptionEvent(crate::types::PlaybackInterruptionEvent),
    /// <p>The event sent from Amazon Lex V2 to your application with text to present to the user.</p>
    TextResponseEvent(crate::types::TextResponseEvent),
    /// <p>Event sent from Amazon Lex V2 to your client application that contains a transcript of voice audio.</p>
    TranscriptEvent(crate::types::TranscriptEvent),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl StartConversationResponseEventStream {
    /// Tries to convert the enum instance into [`AudioResponseEvent`](crate::types::StartConversationResponseEventStream::AudioResponseEvent), extracting the inner [`AudioResponseEvent`](crate::types::AudioResponseEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_audio_response_event(&self) -> ::std::result::Result<&crate::types::AudioResponseEvent, &Self> {
        if let StartConversationResponseEventStream::AudioResponseEvent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AudioResponseEvent`](crate::types::StartConversationResponseEventStream::AudioResponseEvent).
    pub fn is_audio_response_event(&self) -> bool {
        self.as_audio_response_event().is_ok()
    }
    /// Tries to convert the enum instance into [`HeartbeatEvent`](crate::types::StartConversationResponseEventStream::HeartbeatEvent), extracting the inner [`HeartbeatEvent`](crate::types::HeartbeatEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_heartbeat_event(&self) -> ::std::result::Result<&crate::types::HeartbeatEvent, &Self> {
        if let StartConversationResponseEventStream::HeartbeatEvent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`HeartbeatEvent`](crate::types::StartConversationResponseEventStream::HeartbeatEvent).
    pub fn is_heartbeat_event(&self) -> bool {
        self.as_heartbeat_event().is_ok()
    }
    /// Tries to convert the enum instance into [`IntentResultEvent`](crate::types::StartConversationResponseEventStream::IntentResultEvent), extracting the inner [`IntentResultEvent`](crate::types::IntentResultEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_intent_result_event(&self) -> ::std::result::Result<&crate::types::IntentResultEvent, &Self> {
        if let StartConversationResponseEventStream::IntentResultEvent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`IntentResultEvent`](crate::types::StartConversationResponseEventStream::IntentResultEvent).
    pub fn is_intent_result_event(&self) -> bool {
        self.as_intent_result_event().is_ok()
    }
    /// Tries to convert the enum instance into [`PlaybackInterruptionEvent`](crate::types::StartConversationResponseEventStream::PlaybackInterruptionEvent), extracting the inner [`PlaybackInterruptionEvent`](crate::types::PlaybackInterruptionEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_playback_interruption_event(&self) -> ::std::result::Result<&crate::types::PlaybackInterruptionEvent, &Self> {
        if let StartConversationResponseEventStream::PlaybackInterruptionEvent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`PlaybackInterruptionEvent`](crate::types::StartConversationResponseEventStream::PlaybackInterruptionEvent).
    pub fn is_playback_interruption_event(&self) -> bool {
        self.as_playback_interruption_event().is_ok()
    }
    /// Tries to convert the enum instance into [`TextResponseEvent`](crate::types::StartConversationResponseEventStream::TextResponseEvent), extracting the inner [`TextResponseEvent`](crate::types::TextResponseEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_text_response_event(&self) -> ::std::result::Result<&crate::types::TextResponseEvent, &Self> {
        if let StartConversationResponseEventStream::TextResponseEvent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TextResponseEvent`](crate::types::StartConversationResponseEventStream::TextResponseEvent).
    pub fn is_text_response_event(&self) -> bool {
        self.as_text_response_event().is_ok()
    }
    /// Tries to convert the enum instance into [`TranscriptEvent`](crate::types::StartConversationResponseEventStream::TranscriptEvent), extracting the inner [`TranscriptEvent`](crate::types::TranscriptEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_transcript_event(&self) -> ::std::result::Result<&crate::types::TranscriptEvent, &Self> {
        if let StartConversationResponseEventStream::TranscriptEvent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TranscriptEvent`](crate::types::StartConversationResponseEventStream::TranscriptEvent).
    pub fn is_transcript_event(&self) -> bool {
        self.as_transcript_event().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
