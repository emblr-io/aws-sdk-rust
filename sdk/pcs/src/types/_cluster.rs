// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The cluster resource and configuration.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Cluster {
    /// <p>The name that identifies the cluster.</p>
    pub name: ::std::string::String,
    /// <p>The generated unique ID of the cluster.</p>
    pub id: ::std::string::String,
    /// <p>The unique Amazon Resource Name (ARN) of the cluster.</p>
    pub arn: ::std::string::String,
    /// <p>The provisioning status of the cluster.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the cluster.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub status: crate::types::ClusterStatus,
    /// <p>The date and time the resource was created.</p>
    pub created_at: ::aws_smithy_types::DateTime,
    /// <p>The date and time the resource was modified.</p>
    pub modified_at: ::aws_smithy_types::DateTime,
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub scheduler: ::std::option::Option<crate::types::Scheduler>,
    /// <p>The size of the cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub size: crate::types::Size,
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub slurm_configuration: ::std::option::Option<crate::types::ClusterSlurmConfiguration>,
    /// <p>The networking configuration for the cluster's control plane.</p>
    pub networking: ::std::option::Option<crate::types::Networking>,
    /// <p>The list of endpoints available for interaction with the scheduler.</p>
    pub endpoints: ::std::option::Option<::std::vec::Vec<crate::types::Endpoint>>,
    /// <p>The list of errors that occurred during cluster provisioning.</p>
    pub error_info: ::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>>,
}
impl Cluster {
    /// <p>The name that identifies the cluster.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The generated unique ID of the cluster.</p>
    pub fn id(&self) -> &str {
        use std::ops::Deref;
        self.id.deref()
    }
    /// <p>The unique Amazon Resource Name (ARN) of the cluster.</p>
    pub fn arn(&self) -> &str {
        use std::ops::Deref;
        self.arn.deref()
    }
    /// <p>The provisioning status of the cluster.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the cluster.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub fn status(&self) -> &crate::types::ClusterStatus {
        &self.status
    }
    /// <p>The date and time the resource was created.</p>
    pub fn created_at(&self) -> &::aws_smithy_types::DateTime {
        &self.created_at
    }
    /// <p>The date and time the resource was modified.</p>
    pub fn modified_at(&self) -> &::aws_smithy_types::DateTime {
        &self.modified_at
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn scheduler(&self) -> ::std::option::Option<&crate::types::Scheduler> {
        self.scheduler.as_ref()
    }
    /// <p>The size of the cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn size(&self) -> &crate::types::Size {
        &self.size
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn slurm_configuration(&self) -> ::std::option::Option<&crate::types::ClusterSlurmConfiguration> {
        self.slurm_configuration.as_ref()
    }
    /// <p>The networking configuration for the cluster's control plane.</p>
    pub fn networking(&self) -> ::std::option::Option<&crate::types::Networking> {
        self.networking.as_ref()
    }
    /// <p>The list of endpoints available for interaction with the scheduler.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.endpoints.is_none()`.
    pub fn endpoints(&self) -> &[crate::types::Endpoint] {
        self.endpoints.as_deref().unwrap_or_default()
    }
    /// <p>The list of errors that occurred during cluster provisioning.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.error_info.is_none()`.
    pub fn error_info(&self) -> &[crate::types::ErrorInfo] {
        self.error_info.as_deref().unwrap_or_default()
    }
}
impl Cluster {
    /// Creates a new builder-style object to manufacture [`Cluster`](crate::types::Cluster).
    pub fn builder() -> crate::types::builders::ClusterBuilder {
        crate::types::builders::ClusterBuilder::default()
    }
}

/// A builder for [`Cluster`](crate::types::Cluster).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ClusterBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ClusterStatus>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) scheduler: ::std::option::Option<crate::types::Scheduler>,
    pub(crate) size: ::std::option::Option<crate::types::Size>,
    pub(crate) slurm_configuration: ::std::option::Option<crate::types::ClusterSlurmConfiguration>,
    pub(crate) networking: ::std::option::Option<crate::types::Networking>,
    pub(crate) endpoints: ::std::option::Option<::std::vec::Vec<crate::types::Endpoint>>,
    pub(crate) error_info: ::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>>,
}
impl ClusterBuilder {
    /// <p>The name that identifies the cluster.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name that identifies the cluster.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name that identifies the cluster.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The generated unique ID of the cluster.</p>
    /// This field is required.
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The generated unique ID of the cluster.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The generated unique ID of the cluster.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>The unique Amazon Resource Name (ARN) of the cluster.</p>
    /// This field is required.
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique Amazon Resource Name (ARN) of the cluster.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The unique Amazon Resource Name (ARN) of the cluster.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The provisioning status of the cluster.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the cluster.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    /// This field is required.
    pub fn status(mut self, input: crate::types::ClusterStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The provisioning status of the cluster.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the cluster.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ClusterStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The provisioning status of the cluster.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the cluster.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ClusterStatus> {
        &self.status
    }
    /// <p>The date and time the resource was created.</p>
    /// This field is required.
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the resource was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The date and time the resource was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The date and time the resource was modified.</p>
    /// This field is required.
    pub fn modified_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.modified_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the resource was modified.</p>
    pub fn set_modified_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.modified_at = input;
        self
    }
    /// <p>The date and time the resource was modified.</p>
    pub fn get_modified_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.modified_at
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    /// This field is required.
    pub fn scheduler(mut self, input: crate::types::Scheduler) -> Self {
        self.scheduler = ::std::option::Option::Some(input);
        self
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn set_scheduler(mut self, input: ::std::option::Option<crate::types::Scheduler>) -> Self {
        self.scheduler = input;
        self
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn get_scheduler(&self) -> &::std::option::Option<crate::types::Scheduler> {
        &self.scheduler
    }
    /// <p>The size of the cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    /// This field is required.
    pub fn size(mut self, input: crate::types::Size) -> Self {
        self.size = ::std::option::Option::Some(input);
        self
    }
    /// <p>The size of the cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn set_size(mut self, input: ::std::option::Option<crate::types::Size>) -> Self {
        self.size = input;
        self
    }
    /// <p>The size of the cluster.</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn get_size(&self) -> &::std::option::Option<crate::types::Size> {
        &self.size
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn slurm_configuration(mut self, input: crate::types::ClusterSlurmConfiguration) -> Self {
        self.slurm_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn set_slurm_configuration(mut self, input: ::std::option::Option<crate::types::ClusterSlurmConfiguration>) -> Self {
        self.slurm_configuration = input;
        self
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn get_slurm_configuration(&self) -> &::std::option::Option<crate::types::ClusterSlurmConfiguration> {
        &self.slurm_configuration
    }
    /// <p>The networking configuration for the cluster's control plane.</p>
    /// This field is required.
    pub fn networking(mut self, input: crate::types::Networking) -> Self {
        self.networking = ::std::option::Option::Some(input);
        self
    }
    /// <p>The networking configuration for the cluster's control plane.</p>
    pub fn set_networking(mut self, input: ::std::option::Option<crate::types::Networking>) -> Self {
        self.networking = input;
        self
    }
    /// <p>The networking configuration for the cluster's control plane.</p>
    pub fn get_networking(&self) -> &::std::option::Option<crate::types::Networking> {
        &self.networking
    }
    /// Appends an item to `endpoints`.
    ///
    /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
    ///
    /// <p>The list of endpoints available for interaction with the scheduler.</p>
    pub fn endpoints(mut self, input: crate::types::Endpoint) -> Self {
        let mut v = self.endpoints.unwrap_or_default();
        v.push(input);
        self.endpoints = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of endpoints available for interaction with the scheduler.</p>
    pub fn set_endpoints(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Endpoint>>) -> Self {
        self.endpoints = input;
        self
    }
    /// <p>The list of endpoints available for interaction with the scheduler.</p>
    pub fn get_endpoints(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Endpoint>> {
        &self.endpoints
    }
    /// Appends an item to `error_info`.
    ///
    /// To override the contents of this collection use [`set_error_info`](Self::set_error_info).
    ///
    /// <p>The list of errors that occurred during cluster provisioning.</p>
    pub fn error_info(mut self, input: crate::types::ErrorInfo) -> Self {
        let mut v = self.error_info.unwrap_or_default();
        v.push(input);
        self.error_info = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of errors that occurred during cluster provisioning.</p>
    pub fn set_error_info(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>>) -> Self {
        self.error_info = input;
        self
    }
    /// <p>The list of errors that occurred during cluster provisioning.</p>
    pub fn get_error_info(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>> {
        &self.error_info
    }
    /// Consumes the builder and constructs a [`Cluster`](crate::types::Cluster).
    /// This method will fail if any of the following fields are not set:
    /// - [`name`](crate::types::builders::ClusterBuilder::name)
    /// - [`id`](crate::types::builders::ClusterBuilder::id)
    /// - [`arn`](crate::types::builders::ClusterBuilder::arn)
    /// - [`status`](crate::types::builders::ClusterBuilder::status)
    /// - [`created_at`](crate::types::builders::ClusterBuilder::created_at)
    /// - [`modified_at`](crate::types::builders::ClusterBuilder::modified_at)
    /// - [`size`](crate::types::builders::ClusterBuilder::size)
    pub fn build(self) -> ::std::result::Result<crate::types::Cluster, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::Cluster {
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building Cluster",
                )
            })?,
            id: self.id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field("id", "id was not specified but it is required when building Cluster")
            })?,
            arn: self.arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "arn",
                    "arn was not specified but it is required when building Cluster",
                )
            })?,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building Cluster",
                )
            })?,
            created_at: self.created_at.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "created_at",
                    "created_at was not specified but it is required when building Cluster",
                )
            })?,
            modified_at: self.modified_at.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "modified_at",
                    "modified_at was not specified but it is required when building Cluster",
                )
            })?,
            scheduler: self.scheduler,
            size: self.size.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "size",
                    "size was not specified but it is required when building Cluster",
                )
            })?,
            slurm_configuration: self.slurm_configuration,
            networking: self.networking,
            endpoints: self.endpoints,
            error_info: self.error_info,
        })
    }
}
