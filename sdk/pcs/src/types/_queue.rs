// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A queue resource.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Queue {
    /// <p>The name that identifies the queue.</p>
    pub name: ::std::string::String,
    /// <p>The generated unique ID of the queue.</p>
    pub id: ::std::string::String,
    /// <p>The unique Amazon Resource Name (ARN) of the queue.</p>
    pub arn: ::std::string::String,
    /// <p>The ID of the cluster of the queue.</p>
    pub cluster_id: ::std::string::String,
    /// <p>The date and time the resource was created.</p>
    pub created_at: ::aws_smithy_types::DateTime,
    /// <p>The date and time the resource was modified.</p>
    pub modified_at: ::aws_smithy_types::DateTime,
    /// <p>The provisioning status of the queue.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the queue.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub status: crate::types::QueueStatus,
    /// <p>The list of compute node group configurations associated with the queue. Queues assign jobs to associated compute node groups.</p>
    pub compute_node_group_configurations: ::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>,
    /// <p>The list of errors that occurred during queue provisioning.</p>
    pub error_info: ::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>>,
}
impl Queue {
    /// <p>The name that identifies the queue.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The generated unique ID of the queue.</p>
    pub fn id(&self) -> &str {
        use std::ops::Deref;
        self.id.deref()
    }
    /// <p>The unique Amazon Resource Name (ARN) of the queue.</p>
    pub fn arn(&self) -> &str {
        use std::ops::Deref;
        self.arn.deref()
    }
    /// <p>The ID of the cluster of the queue.</p>
    pub fn cluster_id(&self) -> &str {
        use std::ops::Deref;
        self.cluster_id.deref()
    }
    /// <p>The date and time the resource was created.</p>
    pub fn created_at(&self) -> &::aws_smithy_types::DateTime {
        &self.created_at
    }
    /// <p>The date and time the resource was modified.</p>
    pub fn modified_at(&self) -> &::aws_smithy_types::DateTime {
        &self.modified_at
    }
    /// <p>The provisioning status of the queue.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the queue.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub fn status(&self) -> &crate::types::QueueStatus {
        &self.status
    }
    /// <p>The list of compute node group configurations associated with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn compute_node_group_configurations(&self) -> &[crate::types::ComputeNodeGroupConfiguration] {
        use std::ops::Deref;
        self.compute_node_group_configurations.deref()
    }
    /// <p>The list of errors that occurred during queue provisioning.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.error_info.is_none()`.
    pub fn error_info(&self) -> &[crate::types::ErrorInfo] {
        self.error_info.as_deref().unwrap_or_default()
    }
}
impl Queue {
    /// Creates a new builder-style object to manufacture [`Queue`](crate::types::Queue).
    pub fn builder() -> crate::types::builders::QueueBuilder {
        crate::types::builders::QueueBuilder::default()
    }
}

/// A builder for [`Queue`](crate::types::Queue).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct QueueBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_id: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) status: ::std::option::Option<crate::types::QueueStatus>,
    pub(crate) compute_node_group_configurations: ::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>>,
    pub(crate) error_info: ::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>>,
}
impl QueueBuilder {
    /// <p>The name that identifies the queue.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name that identifies the queue.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name that identifies the queue.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The generated unique ID of the queue.</p>
    /// This field is required.
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The generated unique ID of the queue.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The generated unique ID of the queue.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>The unique Amazon Resource Name (ARN) of the queue.</p>
    /// This field is required.
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique Amazon Resource Name (ARN) of the queue.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The unique Amazon Resource Name (ARN) of the queue.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The ID of the cluster of the queue.</p>
    /// This field is required.
    pub fn cluster_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the cluster of the queue.</p>
    pub fn set_cluster_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_id = input;
        self
    }
    /// <p>The ID of the cluster of the queue.</p>
    pub fn get_cluster_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_id
    }
    /// <p>The date and time the resource was created.</p>
    /// This field is required.
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the resource was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The date and time the resource was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The date and time the resource was modified.</p>
    /// This field is required.
    pub fn modified_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.modified_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the resource was modified.</p>
    pub fn set_modified_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.modified_at = input;
        self
    }
    /// <p>The date and time the resource was modified.</p>
    pub fn get_modified_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.modified_at
    }
    /// <p>The provisioning status of the queue.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the queue.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    /// This field is required.
    pub fn status(mut self, input: crate::types::QueueStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The provisioning status of the queue.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the queue.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::QueueStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The provisioning status of the queue.</p><note>
    /// <p>The provisioning status doesn't indicate the overall health of the queue.</p>
    /// </note> <important>
    /// <p>The resource enters the <code>SUSPENDING</code> and <code>SUSPENDED</code> states when the scheduler is beyond end of life and we have suspended the cluster. When in these states, you can't use the cluster. The cluster controller is down and all compute instances are terminated. The resources still count toward your service quotas. You can delete a resource if its status is <code>SUSPENDED</code>. For more information, see <a href="https://docs.aws.amazon.com/pcs/latest/userguide/slurm-versions_faq.html">Frequently asked questions about Slurm versions in PCS</a> in the <i>PCS User Guide</i>.</p>
    /// </important>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::QueueStatus> {
        &self.status
    }
    /// Appends an item to `compute_node_group_configurations`.
    ///
    /// To override the contents of this collection use [`set_compute_node_group_configurations`](Self::set_compute_node_group_configurations).
    ///
    /// <p>The list of compute node group configurations associated with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn compute_node_group_configurations(mut self, input: crate::types::ComputeNodeGroupConfiguration) -> Self {
        let mut v = self.compute_node_group_configurations.unwrap_or_default();
        v.push(input);
        self.compute_node_group_configurations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of compute node group configurations associated with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn set_compute_node_group_configurations(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>>,
    ) -> Self {
        self.compute_node_group_configurations = input;
        self
    }
    /// <p>The list of compute node group configurations associated with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn get_compute_node_group_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>> {
        &self.compute_node_group_configurations
    }
    /// Appends an item to `error_info`.
    ///
    /// To override the contents of this collection use [`set_error_info`](Self::set_error_info).
    ///
    /// <p>The list of errors that occurred during queue provisioning.</p>
    pub fn error_info(mut self, input: crate::types::ErrorInfo) -> Self {
        let mut v = self.error_info.unwrap_or_default();
        v.push(input);
        self.error_info = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of errors that occurred during queue provisioning.</p>
    pub fn set_error_info(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>>) -> Self {
        self.error_info = input;
        self
    }
    /// <p>The list of errors that occurred during queue provisioning.</p>
    pub fn get_error_info(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ErrorInfo>> {
        &self.error_info
    }
    /// Consumes the builder and constructs a [`Queue`](crate::types::Queue).
    /// This method will fail if any of the following fields are not set:
    /// - [`name`](crate::types::builders::QueueBuilder::name)
    /// - [`id`](crate::types::builders::QueueBuilder::id)
    /// - [`arn`](crate::types::builders::QueueBuilder::arn)
    /// - [`cluster_id`](crate::types::builders::QueueBuilder::cluster_id)
    /// - [`created_at`](crate::types::builders::QueueBuilder::created_at)
    /// - [`modified_at`](crate::types::builders::QueueBuilder::modified_at)
    /// - [`status`](crate::types::builders::QueueBuilder::status)
    /// - [`compute_node_group_configurations`](crate::types::builders::QueueBuilder::compute_node_group_configurations)
    pub fn build(self) -> ::std::result::Result<crate::types::Queue, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::Queue {
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building Queue",
                )
            })?,
            id: self.id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field("id", "id was not specified but it is required when building Queue")
            })?,
            arn: self.arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field("arn", "arn was not specified but it is required when building Queue")
            })?,
            cluster_id: self.cluster_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "cluster_id",
                    "cluster_id was not specified but it is required when building Queue",
                )
            })?,
            created_at: self.created_at.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "created_at",
                    "created_at was not specified but it is required when building Queue",
                )
            })?,
            modified_at: self.modified_at.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "modified_at",
                    "modified_at was not specified but it is required when building Queue",
                )
            })?,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building Queue",
                )
            })?,
            compute_node_group_configurations: self.compute_node_group_configurations.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "compute_node_group_configurations",
                    "compute_node_group_configurations was not specified but it is required when building Queue",
                )
            })?,
            error_info: self.error_info,
        })
    }
}
