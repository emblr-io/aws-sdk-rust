// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateClusterInput {
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub cluster_name: ::std::option::Option<::std::string::String>,
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub scheduler: ::std::option::Option<crate::types::SchedulerRequest>,
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub size: ::std::option::Option<crate::types::Size>,
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub networking: ::std::option::Option<crate::types::NetworkingRequest>,
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub slurm_configuration: ::std::option::Option<crate::types::ClusterSlurmConfigurationRequest>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateClusterInput {
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub fn cluster_name(&self) -> ::std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn scheduler(&self) -> ::std::option::Option<&crate::types::SchedulerRequest> {
        self.scheduler.as_ref()
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn size(&self) -> ::std::option::Option<&crate::types::Size> {
        self.size.as_ref()
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub fn networking(&self) -> ::std::option::Option<&crate::types::NetworkingRequest> {
        self.networking.as_ref()
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn slurm_configuration(&self) -> ::std::option::Option<&crate::types::ClusterSlurmConfigurationRequest> {
        self.slurm_configuration.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl CreateClusterInput {
    /// Creates a new builder-style object to manufacture [`CreateClusterInput`](crate::operation::create_cluster::CreateClusterInput).
    pub fn builder() -> crate::operation::create_cluster::builders::CreateClusterInputBuilder {
        crate::operation::create_cluster::builders::CreateClusterInputBuilder::default()
    }
}

/// A builder for [`CreateClusterInput`](crate::operation::create_cluster::CreateClusterInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateClusterInputBuilder {
    pub(crate) cluster_name: ::std::option::Option<::std::string::String>,
    pub(crate) scheduler: ::std::option::Option<crate::types::SchedulerRequest>,
    pub(crate) size: ::std::option::Option<crate::types::Size>,
    pub(crate) networking: ::std::option::Option<crate::types::NetworkingRequest>,
    pub(crate) slurm_configuration: ::std::option::Option<crate::types::ClusterSlurmConfigurationRequest>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateClusterInputBuilder {
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    /// This field is required.
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_name
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    /// This field is required.
    pub fn scheduler(mut self, input: crate::types::SchedulerRequest) -> Self {
        self.scheduler = ::std::option::Option::Some(input);
        self
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn set_scheduler(mut self, input: ::std::option::Option<crate::types::SchedulerRequest>) -> Self {
        self.scheduler = input;
        self
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn get_scheduler(&self) -> &::std::option::Option<crate::types::SchedulerRequest> {
        &self.scheduler
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    /// This field is required.
    pub fn size(mut self, input: crate::types::Size) -> Self {
        self.size = ::std::option::Option::Some(input);
        self
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn set_size(mut self, input: ::std::option::Option<crate::types::Size>) -> Self {
        self.size = input;
        self
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn get_size(&self) -> &::std::option::Option<crate::types::Size> {
        &self.size
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    /// This field is required.
    pub fn networking(mut self, input: crate::types::NetworkingRequest) -> Self {
        self.networking = ::std::option::Option::Some(input);
        self
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub fn set_networking(mut self, input: ::std::option::Option<crate::types::NetworkingRequest>) -> Self {
        self.networking = input;
        self
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub fn get_networking(&self) -> &::std::option::Option<crate::types::NetworkingRequest> {
        &self.networking
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn slurm_configuration(mut self, input: crate::types::ClusterSlurmConfigurationRequest) -> Self {
        self.slurm_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn set_slurm_configuration(mut self, input: ::std::option::Option<crate::types::ClusterSlurmConfigurationRequest>) -> Self {
        self.slurm_configuration = input;
        self
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn get_slurm_configuration(&self) -> &::std::option::Option<crate::types::ClusterSlurmConfigurationRequest> {
        &self.slurm_configuration
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateClusterInput`](crate::operation::create_cluster::CreateClusterInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_cluster::CreateClusterInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_cluster::CreateClusterInput {
            cluster_name: self.cluster_name,
            scheduler: self.scheduler,
            size: self.size,
            networking: self.networking,
            slurm_configuration: self.slurm_configuration,
            client_token: self.client_token,
            tags: self.tags,
        })
    }
}
