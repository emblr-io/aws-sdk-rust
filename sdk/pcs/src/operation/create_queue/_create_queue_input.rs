// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateQueueInput {
    /// <p>The name or ID of the cluster for which to create a queue.</p>
    pub cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>A name to identify the queue.</p>
    pub queue_name: ::std::option::Option<::std::string::String>,
    /// <p>The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.</p>
    pub compute_node_group_configurations: ::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateQueueInput {
    /// <p>The name or ID of the cluster for which to create a queue.</p>
    pub fn cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.cluster_identifier.as_deref()
    }
    /// <p>A name to identify the queue.</p>
    pub fn queue_name(&self) -> ::std::option::Option<&str> {
        self.queue_name.as_deref()
    }
    /// <p>The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.compute_node_group_configurations.is_none()`.
    pub fn compute_node_group_configurations(&self) -> &[crate::types::ComputeNodeGroupConfiguration] {
        self.compute_node_group_configurations.as_deref().unwrap_or_default()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl CreateQueueInput {
    /// Creates a new builder-style object to manufacture [`CreateQueueInput`](crate::operation::create_queue::CreateQueueInput).
    pub fn builder() -> crate::operation::create_queue::builders::CreateQueueInputBuilder {
        crate::operation::create_queue::builders::CreateQueueInputBuilder::default()
    }
}

/// A builder for [`CreateQueueInput`](crate::operation::create_queue::CreateQueueInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateQueueInputBuilder {
    pub(crate) cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) queue_name: ::std::option::Option<::std::string::String>,
    pub(crate) compute_node_group_configurations: ::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateQueueInputBuilder {
    /// <p>The name or ID of the cluster for which to create a queue.</p>
    /// This field is required.
    pub fn cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name or ID of the cluster for which to create a queue.</p>
    pub fn set_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_identifier = input;
        self
    }
    /// <p>The name or ID of the cluster for which to create a queue.</p>
    pub fn get_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_identifier
    }
    /// <p>A name to identify the queue.</p>
    /// This field is required.
    pub fn queue_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.queue_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A name to identify the queue.</p>
    pub fn set_queue_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.queue_name = input;
        self
    }
    /// <p>A name to identify the queue.</p>
    pub fn get_queue_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.queue_name
    }
    /// Appends an item to `compute_node_group_configurations`.
    ///
    /// To override the contents of this collection use [`set_compute_node_group_configurations`](Self::set_compute_node_group_configurations).
    ///
    /// <p>The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn compute_node_group_configurations(mut self, input: crate::types::ComputeNodeGroupConfiguration) -> Self {
        let mut v = self.compute_node_group_configurations.unwrap_or_default();
        v.push(input);
        self.compute_node_group_configurations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn set_compute_node_group_configurations(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>>,
    ) -> Self {
        self.compute_node_group_configurations = input;
        self
    }
    /// <p>The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.</p>
    pub fn get_compute_node_group_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ComputeNodeGroupConfiguration>> {
        &self.compute_node_group_configurations
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateQueueInput`](crate::operation::create_queue::CreateQueueInput).
    pub fn build(self) -> ::std::result::Result<crate::operation::create_queue::CreateQueueInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_queue::CreateQueueInput {
            cluster_identifier: self.cluster_identifier,
            queue_name: self.queue_name,
            compute_node_group_configurations: self.compute_node_group_configurations,
            client_token: self.client_token,
            tags: self.tags,
        })
    }
}
