// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListAccessPointsForDirectoryBucketsInput {
    /// <p>The Amazon Web Services account ID that owns the access points.</p>
    pub account_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the directory bucket associated with the access points you want to list.</p>
    pub directory_bucket: ::std::option::Option<::std::string::String>,
    /// <p>If <code>NextToken</code> is returned, there are more access points available than requested in the <code>maxResults</code> value. The value of <code>NextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.</p>
    pub next_token: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of access points that you would like returned in the <code>ListAccessPointsForDirectoryBuckets</code> response. If the directory bucket is associated with more than this number of access points, the results include the pagination token <code>NextToken</code>. Make another call using the <code>NextToken</code> to retrieve more results.</p>
    pub max_results: ::std::option::Option<i32>,
}
impl ListAccessPointsForDirectoryBucketsInput {
    /// <p>The Amazon Web Services account ID that owns the access points.</p>
    pub fn account_id(&self) -> ::std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the directory bucket associated with the access points you want to list.</p>
    pub fn directory_bucket(&self) -> ::std::option::Option<&str> {
        self.directory_bucket.as_deref()
    }
    /// <p>If <code>NextToken</code> is returned, there are more access points available than requested in the <code>maxResults</code> value. The value of <code>NextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of access points that you would like returned in the <code>ListAccessPointsForDirectoryBuckets</code> response. If the directory bucket is associated with more than this number of access points, the results include the pagination token <code>NextToken</code>. Make another call using the <code>NextToken</code> to retrieve more results.</p>
    pub fn max_results(&self) -> ::std::option::Option<i32> {
        self.max_results
    }
}
impl ListAccessPointsForDirectoryBucketsInput {
    /// Creates a new builder-style object to manufacture [`ListAccessPointsForDirectoryBucketsInput`](crate::operation::list_access_points_for_directory_buckets::ListAccessPointsForDirectoryBucketsInput).
    pub fn builder() -> crate::operation::list_access_points_for_directory_buckets::builders::ListAccessPointsForDirectoryBucketsInputBuilder {
        crate::operation::list_access_points_for_directory_buckets::builders::ListAccessPointsForDirectoryBucketsInputBuilder::default()
    }
}

/// A builder for [`ListAccessPointsForDirectoryBucketsInput`](crate::operation::list_access_points_for_directory_buckets::ListAccessPointsForDirectoryBucketsInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ListAccessPointsForDirectoryBucketsInputBuilder {
    pub(crate) account_id: ::std::option::Option<::std::string::String>,
    pub(crate) directory_bucket: ::std::option::Option<::std::string::String>,
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
    pub(crate) max_results: ::std::option::Option<i32>,
}
impl ListAccessPointsForDirectoryBucketsInputBuilder {
    /// <p>The Amazon Web Services account ID that owns the access points.</p>
    /// This field is required.
    pub fn account_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.account_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services account ID that owns the access points.</p>
    pub fn set_account_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.account_id = input;
        self
    }
    /// <p>The Amazon Web Services account ID that owns the access points.</p>
    pub fn get_account_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.account_id
    }
    /// <p>The name of the directory bucket associated with the access points you want to list.</p>
    pub fn directory_bucket(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.directory_bucket = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the directory bucket associated with the access points you want to list.</p>
    pub fn set_directory_bucket(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.directory_bucket = input;
        self
    }
    /// <p>The name of the directory bucket associated with the access points you want to list.</p>
    pub fn get_directory_bucket(&self) -> &::std::option::Option<::std::string::String> {
        &self.directory_bucket
    }
    /// <p>If <code>NextToken</code> is returned, there are more access points available than requested in the <code>maxResults</code> value. The value of <code>NextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If <code>NextToken</code> is returned, there are more access points available than requested in the <code>maxResults</code> value. The value of <code>NextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>If <code>NextToken</code> is returned, there are more access points available than requested in the <code>maxResults</code> value. The value of <code>NextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    /// <p>The maximum number of access points that you would like returned in the <code>ListAccessPointsForDirectoryBuckets</code> response. If the directory bucket is associated with more than this number of access points, the results include the pagination token <code>NextToken</code>. Make another call using the <code>NextToken</code> to retrieve more results.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.max_results = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of access points that you would like returned in the <code>ListAccessPointsForDirectoryBuckets</code> response. If the directory bucket is associated with more than this number of access points, the results include the pagination token <code>NextToken</code>. Make another call using the <code>NextToken</code> to retrieve more results.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_results = input;
        self
    }
    /// <p>The maximum number of access points that you would like returned in the <code>ListAccessPointsForDirectoryBuckets</code> response. If the directory bucket is associated with more than this number of access points, the results include the pagination token <code>NextToken</code>. Make another call using the <code>NextToken</code> to retrieve more results.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        &self.max_results
    }
    /// Consumes the builder and constructs a [`ListAccessPointsForDirectoryBucketsInput`](crate::operation::list_access_points_for_directory_buckets::ListAccessPointsForDirectoryBucketsInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_access_points_for_directory_buckets::ListAccessPointsForDirectoryBucketsInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(
            crate::operation::list_access_points_for_directory_buckets::ListAccessPointsForDirectoryBucketsInput {
                account_id: self.account_id,
                directory_bucket: self.directory_bucket,
                next_token: self.next_token,
                max_results: self.max_results,
            },
        )
    }
}
