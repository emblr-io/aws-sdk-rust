// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateDbShardGroupInput {
    /// <p>The name of the DB shard group.</p>
    pub db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub db_cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether to create standby standby DB data access shard for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB data access shard. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB data access shard in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB data access shard in two different AZs.</p></li>
    /// </ul>
    pub compute_redundancy: ::std::option::Option<i32>,
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub max_acu: ::std::option::Option<f64>,
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub min_acu: ::std::option::Option<f64>,
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub publicly_accessible: ::std::option::Option<bool>,
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateDbShardGroupInput {
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_identifier.as_deref()
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>Specifies whether to create standby standby DB data access shard for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB data access shard. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB data access shard in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB data access shard in two different AZs.</p></li>
    /// </ul>
    pub fn compute_redundancy(&self) -> ::std::option::Option<i32> {
        self.compute_redundancy
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(&self) -> ::std::option::Option<f64> {
        self.max_acu
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn min_acu(&self) -> ::std::option::Option<f64> {
        self.min_acu
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn publicly_accessible(&self) -> ::std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl CreateDbShardGroupInput {
    /// Creates a new builder-style object to manufacture [`CreateDbShardGroupInput`](crate::operation::create_db_shard_group::CreateDbShardGroupInput).
    pub fn builder() -> crate::operation::create_db_shard_group::builders::CreateDbShardGroupInputBuilder {
        crate::operation::create_db_shard_group::builders::CreateDbShardGroupInputBuilder::default()
    }
}

/// A builder for [`CreateDbShardGroupInput`](crate::operation::create_db_shard_group::CreateDbShardGroupInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateDbShardGroupInputBuilder {
    pub(crate) db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) db_cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) compute_redundancy: ::std::option::Option<i32>,
    pub(crate) max_acu: ::std::option::Option<f64>,
    pub(crate) min_acu: ::std::option::Option<f64>,
    pub(crate) publicly_accessible: ::std::option::Option<bool>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateDbShardGroupInputBuilder {
    /// <p>The name of the DB shard group.</p>
    /// This field is required.
    pub fn db_shard_group_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn set_db_shard_group_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_identifier = input;
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn get_db_shard_group_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_identifier
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    /// This field is required.
    pub fn db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn set_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_cluster_identifier = input;
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn get_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_cluster_identifier
    }
    /// <p>Specifies whether to create standby standby DB data access shard for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB data access shard. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB data access shard in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB data access shard in two different AZs.</p></li>
    /// </ul>
    pub fn compute_redundancy(mut self, input: i32) -> Self {
        self.compute_redundancy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to create standby standby DB data access shard for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB data access shard. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB data access shard in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB data access shard in two different AZs.</p></li>
    /// </ul>
    pub fn set_compute_redundancy(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compute_redundancy = input;
        self
    }
    /// <p>Specifies whether to create standby standby DB data access shard for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a DB shard group without a standby DB data access shard. This is the default value.</p></li>
    /// <li>
    /// <p>1 - Creates a DB shard group with a standby DB data access shard in a different Availability Zone (AZ).</p></li>
    /// <li>
    /// <p>2 - Creates a DB shard group with two standby DB data access shard in two different AZs.</p></li>
    /// </ul>
    pub fn get_compute_redundancy(&self) -> &::std::option::Option<i32> {
        &self.compute_redundancy
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    /// This field is required.
    pub fn max_acu(mut self, input: f64) -> Self {
        self.max_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_max_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.max_acu = input;
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_max_acu(&self) -> &::std::option::Option<f64> {
        &self.max_acu
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn min_acu(mut self, input: f64) -> Self {
        self.min_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_min_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.min_acu = input;
        self
    }
    /// <p>The minimum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_min_acu(&self) -> &::std::option::Option<f64> {
        &self.min_acu
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.publicly_accessible = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.publicly_accessible = input;
        self
    }
    /// <p>Specifies whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access is not permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>Default: The default behavior varies depending on whether <code>DBSubnetGroupName</code> is specified.</p>
    /// <p>If <code>DBSubnetGroupName</code> isn't specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the default VPC in the target Region doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the default VPC in the target Region has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    /// <p>If <code>DBSubnetGroupName</code> is specified, and <code>PubliclyAccessible</code> isn't specified, the following applies:</p>
    /// <ul>
    /// <li>
    /// <p>If the subnets are part of a VPC that doesn’t have an internet gateway attached to it, the DB shard group is private.</p></li>
    /// <li>
    /// <p>If the subnets are part of a VPC that has an internet gateway attached to it, the DB shard group is public.</p></li>
    /// </ul>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        &self.publicly_accessible
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of tags.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS resources</a> in the <i>Amazon RDS User Guide</i> or <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.html">Tagging Amazon Aurora and Amazon RDS resources</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateDbShardGroupInput`](crate::operation::create_db_shard_group::CreateDbShardGroupInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_db_shard_group::CreateDbShardGroupInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::create_db_shard_group::CreateDbShardGroupInput {
            db_shard_group_identifier: self.db_shard_group_identifier,
            db_cluster_identifier: self.db_cluster_identifier,
            compute_redundancy: self.compute_redundancy,
            max_acu: self.max_acu,
            min_acu: self.min_acu,
            publicly_accessible: self.publicly_accessible,
            tags: self.tags,
        })
    }
}
