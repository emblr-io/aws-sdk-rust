// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle and Network Firewall removes the flow entry from its flow table. Existing connections and flows are not impacted when you update this value. Only new connections after you update this value are impacted.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct FlowTimeouts {
    /// <p>The number of seconds that can pass without any TCP traffic sent through the firewall before the firewall determines that the connection is idle. After the idle timeout passes, data packets are dropped, however, the next TCP SYN packet is considered a new flow and is processed by the firewall. Clients or targets can use TCP keepalive packets to reset the idle timeout.</p>
    /// <p>You can define the <code>TcpIdleTimeoutSeconds</code> value to be between 60 and 6000 seconds. If no value is provided, it defaults to 350 seconds.</p>
    pub tcp_idle_timeout_seconds: ::std::option::Option<i32>,
}
impl FlowTimeouts {
    /// <p>The number of seconds that can pass without any TCP traffic sent through the firewall before the firewall determines that the connection is idle. After the idle timeout passes, data packets are dropped, however, the next TCP SYN packet is considered a new flow and is processed by the firewall. Clients or targets can use TCP keepalive packets to reset the idle timeout.</p>
    /// <p>You can define the <code>TcpIdleTimeoutSeconds</code> value to be between 60 and 6000 seconds. If no value is provided, it defaults to 350 seconds.</p>
    pub fn tcp_idle_timeout_seconds(&self) -> ::std::option::Option<i32> {
        self.tcp_idle_timeout_seconds
    }
}
impl FlowTimeouts {
    /// Creates a new builder-style object to manufacture [`FlowTimeouts`](crate::types::FlowTimeouts).
    pub fn builder() -> crate::types::builders::FlowTimeoutsBuilder {
        crate::types::builders::FlowTimeoutsBuilder::default()
    }
}

/// A builder for [`FlowTimeouts`](crate::types::FlowTimeouts).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct FlowTimeoutsBuilder {
    pub(crate) tcp_idle_timeout_seconds: ::std::option::Option<i32>,
}
impl FlowTimeoutsBuilder {
    /// <p>The number of seconds that can pass without any TCP traffic sent through the firewall before the firewall determines that the connection is idle. After the idle timeout passes, data packets are dropped, however, the next TCP SYN packet is considered a new flow and is processed by the firewall. Clients or targets can use TCP keepalive packets to reset the idle timeout.</p>
    /// <p>You can define the <code>TcpIdleTimeoutSeconds</code> value to be between 60 and 6000 seconds. If no value is provided, it defaults to 350 seconds.</p>
    pub fn tcp_idle_timeout_seconds(mut self, input: i32) -> Self {
        self.tcp_idle_timeout_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of seconds that can pass without any TCP traffic sent through the firewall before the firewall determines that the connection is idle. After the idle timeout passes, data packets are dropped, however, the next TCP SYN packet is considered a new flow and is processed by the firewall. Clients or targets can use TCP keepalive packets to reset the idle timeout.</p>
    /// <p>You can define the <code>TcpIdleTimeoutSeconds</code> value to be between 60 and 6000 seconds. If no value is provided, it defaults to 350 seconds.</p>
    pub fn set_tcp_idle_timeout_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.tcp_idle_timeout_seconds = input;
        self
    }
    /// <p>The number of seconds that can pass without any TCP traffic sent through the firewall before the firewall determines that the connection is idle. After the idle timeout passes, data packets are dropped, however, the next TCP SYN packet is considered a new flow and is processed by the firewall. Clients or targets can use TCP keepalive packets to reset the idle timeout.</p>
    /// <p>You can define the <code>TcpIdleTimeoutSeconds</code> value to be between 60 and 6000 seconds. If no value is provided, it defaults to 350 seconds.</p>
    pub fn get_tcp_idle_timeout_seconds(&self) -> &::std::option::Option<i32> {
        &self.tcp_idle_timeout_seconds
    }
    /// Consumes the builder and constructs a [`FlowTimeouts`](crate::types::FlowTimeouts).
    pub fn build(self) -> crate::types::FlowTimeouts {
        crate::types::FlowTimeouts {
            tcp_idle_timeout_seconds: self.tcp_idle_timeout_seconds,
        }
    }
}
