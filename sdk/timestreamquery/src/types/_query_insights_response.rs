// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides various insights and metrics related to the query that you executed.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct QueryInsightsResponse {
    /// <p>Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.</p>
    pub query_spatial_coverage: ::std::option::Option<crate::types::QuerySpatialCoverage>,
    /// <p>Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:</p>
    /// <ul>
    /// <li>
    /// <p>Add missing time-predicates.</p></li>
    /// <li>
    /// <p>Remove functions around the time predicates.</p></li>
    /// <li>
    /// <p>Add time predicates to all the sub-queries.</p></li>
    /// </ul>
    pub query_temporal_range: ::std::option::Option<crate::types::QueryTemporalRange>,
    /// <p>Indicates the number of tables in the query.</p>
    pub query_table_count: ::std::option::Option<i64>,
    /// <p>Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.</p>
    pub output_rows: ::std::option::Option<i64>,
    /// <p>Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.</p>
    pub output_bytes: ::std::option::Option<i64>,
    /// <p>Indicates the partitions created by the <code>Unload</code> operation.</p>
    pub unload_partition_count: ::std::option::Option<i64>,
    /// <p>Indicates the rows written by the <code>Unload</code> query.</p>
    pub unload_written_rows: ::std::option::Option<i64>,
    /// <p>Indicates the size, in bytes, written by the <code>Unload</code> operation.</p>
    pub unload_written_bytes: ::std::option::Option<i64>,
}
impl QueryInsightsResponse {
    /// <p>Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.</p>
    pub fn query_spatial_coverage(&self) -> ::std::option::Option<&crate::types::QuerySpatialCoverage> {
        self.query_spatial_coverage.as_ref()
    }
    /// <p>Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:</p>
    /// <ul>
    /// <li>
    /// <p>Add missing time-predicates.</p></li>
    /// <li>
    /// <p>Remove functions around the time predicates.</p></li>
    /// <li>
    /// <p>Add time predicates to all the sub-queries.</p></li>
    /// </ul>
    pub fn query_temporal_range(&self) -> ::std::option::Option<&crate::types::QueryTemporalRange> {
        self.query_temporal_range.as_ref()
    }
    /// <p>Indicates the number of tables in the query.</p>
    pub fn query_table_count(&self) -> ::std::option::Option<i64> {
        self.query_table_count
    }
    /// <p>Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.</p>
    pub fn output_rows(&self) -> ::std::option::Option<i64> {
        self.output_rows
    }
    /// <p>Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.</p>
    pub fn output_bytes(&self) -> ::std::option::Option<i64> {
        self.output_bytes
    }
    /// <p>Indicates the partitions created by the <code>Unload</code> operation.</p>
    pub fn unload_partition_count(&self) -> ::std::option::Option<i64> {
        self.unload_partition_count
    }
    /// <p>Indicates the rows written by the <code>Unload</code> query.</p>
    pub fn unload_written_rows(&self) -> ::std::option::Option<i64> {
        self.unload_written_rows
    }
    /// <p>Indicates the size, in bytes, written by the <code>Unload</code> operation.</p>
    pub fn unload_written_bytes(&self) -> ::std::option::Option<i64> {
        self.unload_written_bytes
    }
}
impl QueryInsightsResponse {
    /// Creates a new builder-style object to manufacture [`QueryInsightsResponse`](crate::types::QueryInsightsResponse).
    pub fn builder() -> crate::types::builders::QueryInsightsResponseBuilder {
        crate::types::builders::QueryInsightsResponseBuilder::default()
    }
}

/// A builder for [`QueryInsightsResponse`](crate::types::QueryInsightsResponse).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct QueryInsightsResponseBuilder {
    pub(crate) query_spatial_coverage: ::std::option::Option<crate::types::QuerySpatialCoverage>,
    pub(crate) query_temporal_range: ::std::option::Option<crate::types::QueryTemporalRange>,
    pub(crate) query_table_count: ::std::option::Option<i64>,
    pub(crate) output_rows: ::std::option::Option<i64>,
    pub(crate) output_bytes: ::std::option::Option<i64>,
    pub(crate) unload_partition_count: ::std::option::Option<i64>,
    pub(crate) unload_written_rows: ::std::option::Option<i64>,
    pub(crate) unload_written_bytes: ::std::option::Option<i64>,
}
impl QueryInsightsResponseBuilder {
    /// <p>Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.</p>
    pub fn query_spatial_coverage(mut self, input: crate::types::QuerySpatialCoverage) -> Self {
        self.query_spatial_coverage = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.</p>
    pub fn set_query_spatial_coverage(mut self, input: ::std::option::Option<crate::types::QuerySpatialCoverage>) -> Self {
        self.query_spatial_coverage = input;
        self
    }
    /// <p>Provides insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.</p>
    pub fn get_query_spatial_coverage(&self) -> &::std::option::Option<crate::types::QuerySpatialCoverage> {
        &self.query_spatial_coverage
    }
    /// <p>Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:</p>
    /// <ul>
    /// <li>
    /// <p>Add missing time-predicates.</p></li>
    /// <li>
    /// <p>Remove functions around the time predicates.</p></li>
    /// <li>
    /// <p>Add time predicates to all the sub-queries.</p></li>
    /// </ul>
    pub fn query_temporal_range(mut self, input: crate::types::QueryTemporalRange) -> Self {
        self.query_temporal_range = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:</p>
    /// <ul>
    /// <li>
    /// <p>Add missing time-predicates.</p></li>
    /// <li>
    /// <p>Remove functions around the time predicates.</p></li>
    /// <li>
    /// <p>Add time predicates to all the sub-queries.</p></li>
    /// </ul>
    pub fn set_query_temporal_range(mut self, input: ::std::option::Option<crate::types::QueryTemporalRange>) -> Self {
        self.query_temporal_range = input;
        self
    }
    /// <p>Provides insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning:</p>
    /// <ul>
    /// <li>
    /// <p>Add missing time-predicates.</p></li>
    /// <li>
    /// <p>Remove functions around the time predicates.</p></li>
    /// <li>
    /// <p>Add time predicates to all the sub-queries.</p></li>
    /// </ul>
    pub fn get_query_temporal_range(&self) -> &::std::option::Option<crate::types::QueryTemporalRange> {
        &self.query_temporal_range
    }
    /// <p>Indicates the number of tables in the query.</p>
    pub fn query_table_count(mut self, input: i64) -> Self {
        self.query_table_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the number of tables in the query.</p>
    pub fn set_query_table_count(mut self, input: ::std::option::Option<i64>) -> Self {
        self.query_table_count = input;
        self
    }
    /// <p>Indicates the number of tables in the query.</p>
    pub fn get_query_table_count(&self) -> &::std::option::Option<i64> {
        &self.query_table_count
    }
    /// <p>Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.</p>
    pub fn output_rows(mut self, input: i64) -> Self {
        self.output_rows = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.</p>
    pub fn set_output_rows(mut self, input: ::std::option::Option<i64>) -> Self {
        self.output_rows = input;
        self
    }
    /// <p>Indicates the total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.</p>
    pub fn get_output_rows(&self) -> &::std::option::Option<i64> {
        &self.output_rows
    }
    /// <p>Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.</p>
    pub fn output_bytes(mut self, input: i64) -> Self {
        self.output_bytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.</p>
    pub fn set_output_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
        self.output_bytes = input;
        self
    }
    /// <p>Indicates the size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.</p>
    pub fn get_output_bytes(&self) -> &::std::option::Option<i64> {
        &self.output_bytes
    }
    /// <p>Indicates the partitions created by the <code>Unload</code> operation.</p>
    pub fn unload_partition_count(mut self, input: i64) -> Self {
        self.unload_partition_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the partitions created by the <code>Unload</code> operation.</p>
    pub fn set_unload_partition_count(mut self, input: ::std::option::Option<i64>) -> Self {
        self.unload_partition_count = input;
        self
    }
    /// <p>Indicates the partitions created by the <code>Unload</code> operation.</p>
    pub fn get_unload_partition_count(&self) -> &::std::option::Option<i64> {
        &self.unload_partition_count
    }
    /// <p>Indicates the rows written by the <code>Unload</code> query.</p>
    pub fn unload_written_rows(mut self, input: i64) -> Self {
        self.unload_written_rows = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the rows written by the <code>Unload</code> query.</p>
    pub fn set_unload_written_rows(mut self, input: ::std::option::Option<i64>) -> Self {
        self.unload_written_rows = input;
        self
    }
    /// <p>Indicates the rows written by the <code>Unload</code> query.</p>
    pub fn get_unload_written_rows(&self) -> &::std::option::Option<i64> {
        &self.unload_written_rows
    }
    /// <p>Indicates the size, in bytes, written by the <code>Unload</code> operation.</p>
    pub fn unload_written_bytes(mut self, input: i64) -> Self {
        self.unload_written_bytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the size, in bytes, written by the <code>Unload</code> operation.</p>
    pub fn set_unload_written_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
        self.unload_written_bytes = input;
        self
    }
    /// <p>Indicates the size, in bytes, written by the <code>Unload</code> operation.</p>
    pub fn get_unload_written_bytes(&self) -> &::std::option::Option<i64> {
        &self.unload_written_bytes
    }
    /// Consumes the builder and constructs a [`QueryInsightsResponse`](crate::types::QueryInsightsResponse).
    pub fn build(self) -> crate::types::QueryInsightsResponse {
        crate::types::QueryInsightsResponse {
            query_spatial_coverage: self.query_spatial_coverage,
            query_temporal_range: self.query_temporal_range,
            query_table_count: self.query_table_count,
            output_rows: self.output_rows,
            output_bytes: self.output_bytes,
            unload_partition_count: self.unload_partition_count,
            unload_written_rows: self.unload_written_rows,
            unload_written_bytes: self.unload_written_bytes,
        }
    }
}
