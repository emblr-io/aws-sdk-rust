// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StartImportTaskInput {
    /// <p>Options for how to perform an import.</p>
    pub import_options: ::std::option::Option<crate::types::ImportOptions>,
    /// <p>If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.</p>
    pub fail_on_error: ::std::option::Option<bool>,
    /// <p>A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.</p>
    pub source: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.</p>
    pub format: ::std::option::Option<crate::types::Format>,
    /// <p>The parquet type of the import task.</p>
    pub parquet_type: ::std::option::Option<crate::types::ParquetType>,
    /// <p>The method to handle blank nodes in the dataset. Currently, only <code>convertToIri</code> is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is <code>ntriples</code>. For more information, see <a href="https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling">Handling RDF values</a>.</p>
    pub blank_node_handling: ::std::option::Option<crate::types::BlankNodeHandling>,
    /// <p>The unique identifier of the Neptune Analytics graph.</p>
    pub graph_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the IAM role that will allow access to the data that is to be imported.</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
}
impl StartImportTaskInput {
    /// <p>Options for how to perform an import.</p>
    pub fn import_options(&self) -> ::std::option::Option<&crate::types::ImportOptions> {
        self.import_options.as_ref()
    }
    /// <p>If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.</p>
    pub fn fail_on_error(&self) -> ::std::option::Option<bool> {
        self.fail_on_error
    }
    /// <p>A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.</p>
    pub fn source(&self) -> ::std::option::Option<&str> {
        self.source.as_deref()
    }
    /// <p>Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.</p>
    pub fn format(&self) -> ::std::option::Option<&crate::types::Format> {
        self.format.as_ref()
    }
    /// <p>The parquet type of the import task.</p>
    pub fn parquet_type(&self) -> ::std::option::Option<&crate::types::ParquetType> {
        self.parquet_type.as_ref()
    }
    /// <p>The method to handle blank nodes in the dataset. Currently, only <code>convertToIri</code> is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is <code>ntriples</code>. For more information, see <a href="https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling">Handling RDF values</a>.</p>
    pub fn blank_node_handling(&self) -> ::std::option::Option<&crate::types::BlankNodeHandling> {
        self.blank_node_handling.as_ref()
    }
    /// <p>The unique identifier of the Neptune Analytics graph.</p>
    pub fn graph_identifier(&self) -> ::std::option::Option<&str> {
        self.graph_identifier.as_deref()
    }
    /// <p>The ARN of the IAM role that will allow access to the data that is to be imported.</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl StartImportTaskInput {
    /// Creates a new builder-style object to manufacture [`StartImportTaskInput`](crate::operation::start_import_task::StartImportTaskInput).
    pub fn builder() -> crate::operation::start_import_task::builders::StartImportTaskInputBuilder {
        crate::operation::start_import_task::builders::StartImportTaskInputBuilder::default()
    }
}

/// A builder for [`StartImportTaskInput`](crate::operation::start_import_task::StartImportTaskInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct StartImportTaskInputBuilder {
    pub(crate) import_options: ::std::option::Option<crate::types::ImportOptions>,
    pub(crate) fail_on_error: ::std::option::Option<bool>,
    pub(crate) source: ::std::option::Option<::std::string::String>,
    pub(crate) format: ::std::option::Option<crate::types::Format>,
    pub(crate) parquet_type: ::std::option::Option<crate::types::ParquetType>,
    pub(crate) blank_node_handling: ::std::option::Option<crate::types::BlankNodeHandling>,
    pub(crate) graph_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
}
impl StartImportTaskInputBuilder {
    /// <p>Options for how to perform an import.</p>
    pub fn import_options(mut self, input: crate::types::ImportOptions) -> Self {
        self.import_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Options for how to perform an import.</p>
    pub fn set_import_options(mut self, input: ::std::option::Option<crate::types::ImportOptions>) -> Self {
        self.import_options = input;
        self
    }
    /// <p>Options for how to perform an import.</p>
    pub fn get_import_options(&self) -> &::std::option::Option<crate::types::ImportOptions> {
        &self.import_options
    }
    /// <p>If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.</p>
    pub fn fail_on_error(mut self, input: bool) -> Self {
        self.fail_on_error = ::std::option::Option::Some(input);
        self
    }
    /// <p>If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.</p>
    pub fn set_fail_on_error(mut self, input: ::std::option::Option<bool>) -> Self {
        self.fail_on_error = input;
        self
    }
    /// <p>If set to true, the task halts when an import error is encountered. If set to false, the task skips the data that caused the error and continues if possible.</p>
    pub fn get_fail_on_error(&self) -> &::std::option::Option<bool> {
        &self.fail_on_error
    }
    /// <p>A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.</p>
    /// This field is required.
    pub fn source(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.</p>
    pub fn set_source(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source = input;
        self
    }
    /// <p>A URL identifying the location of the data to be imported. This can be an Amazon S3 path, or can point to a Neptune database endpoint or snapshot.</p>
    pub fn get_source(&self) -> &::std::option::Option<::std::string::String> {
        &self.source
    }
    /// <p>Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.</p>
    pub fn format(mut self, input: crate::types::Format) -> Self {
        self.format = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.</p>
    pub fn set_format(mut self, input: ::std::option::Option<crate::types::Format>) -> Self {
        self.format = input;
        self
    }
    /// <p>Specifies the format of Amazon S3 data to be imported. Valid values are CSV, which identifies the Gremlin CSV format or OPENCYPHER, which identies the openCypher load format.</p>
    pub fn get_format(&self) -> &::std::option::Option<crate::types::Format> {
        &self.format
    }
    /// <p>The parquet type of the import task.</p>
    pub fn parquet_type(mut self, input: crate::types::ParquetType) -> Self {
        self.parquet_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The parquet type of the import task.</p>
    pub fn set_parquet_type(mut self, input: ::std::option::Option<crate::types::ParquetType>) -> Self {
        self.parquet_type = input;
        self
    }
    /// <p>The parquet type of the import task.</p>
    pub fn get_parquet_type(&self) -> &::std::option::Option<crate::types::ParquetType> {
        &self.parquet_type
    }
    /// <p>The method to handle blank nodes in the dataset. Currently, only <code>convertToIri</code> is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is <code>ntriples</code>. For more information, see <a href="https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling">Handling RDF values</a>.</p>
    pub fn blank_node_handling(mut self, input: crate::types::BlankNodeHandling) -> Self {
        self.blank_node_handling = ::std::option::Option::Some(input);
        self
    }
    /// <p>The method to handle blank nodes in the dataset. Currently, only <code>convertToIri</code> is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is <code>ntriples</code>. For more information, see <a href="https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling">Handling RDF values</a>.</p>
    pub fn set_blank_node_handling(mut self, input: ::std::option::Option<crate::types::BlankNodeHandling>) -> Self {
        self.blank_node_handling = input;
        self
    }
    /// <p>The method to handle blank nodes in the dataset. Currently, only <code>convertToIri</code> is supported, meaning blank nodes are converted to unique IRIs at load time. Must be provided when format is <code>ntriples</code>. For more information, see <a href="https://docs.aws.amazon.com/neptune-analytics/latest/userguide/using-rdf-data.html#rdf-handling">Handling RDF values</a>.</p>
    pub fn get_blank_node_handling(&self) -> &::std::option::Option<crate::types::BlankNodeHandling> {
        &self.blank_node_handling
    }
    /// <p>The unique identifier of the Neptune Analytics graph.</p>
    /// This field is required.
    pub fn graph_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.graph_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Neptune Analytics graph.</p>
    pub fn set_graph_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.graph_identifier = input;
        self
    }
    /// <p>The unique identifier of the Neptune Analytics graph.</p>
    pub fn get_graph_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.graph_identifier
    }
    /// <p>The ARN of the IAM role that will allow access to the data that is to be imported.</p>
    /// This field is required.
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the IAM role that will allow access to the data that is to be imported.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The ARN of the IAM role that will allow access to the data that is to be imported.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// Consumes the builder and constructs a [`StartImportTaskInput`](crate::operation::start_import_task::StartImportTaskInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::start_import_task::StartImportTaskInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::start_import_task::StartImportTaskInput {
            import_options: self.import_options,
            fail_on_error: self.fail_on_error,
            source: self.source,
            format: self.format,
            parquet_type: self.parquet_type,
            blank_node_handling: self.blank_node_handling,
            graph_identifier: self.graph_identifier,
            role_arn: self.role_arn,
        })
    }
}
