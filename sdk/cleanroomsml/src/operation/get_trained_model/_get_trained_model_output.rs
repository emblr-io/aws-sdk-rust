// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetTrainedModelOutput {
    /// <p>The membership ID of the member that created the trained model.</p>
    pub membership_identifier: ::std::string::String,
    /// <p>The collaboration ID of the collaboration that contains the trained model.</p>
    pub collaboration_identifier: ::std::string::String,
    /// <p>The Amazon Resource Name (ARN) of the trained model.</p>
    pub trained_model_arn: ::std::string::String,
    /// <p>The version identifier of the trained model. This unique identifier distinguishes this version from other versions of the same trained model.</p>
    pub version_identifier: ::std::option::Option<::std::string::String>,
    /// <p>Information about the incremental training data channels used to create this version of the trained model. This includes details about the base model that was used for incremental training and the channel configuration.</p>
    pub incremental_training_data_channels: ::std::option::Option<::std::vec::Vec<crate::types::IncrementalTrainingDataChannelOutput>>,
    /// <p>The name of the trained model.</p>
    pub name: ::std::string::String,
    /// <p>The description of the trained model.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The status of the trained model.</p>
    pub status: crate::types::TrainedModelStatus,
    /// <p>Details about the status of a resource.</p>
    pub status_details: ::std::option::Option<crate::types::StatusDetails>,
    /// <p>The Amazon Resource Name (ARN) of the configured model algorithm association that was used to create the trained model.</p>
    pub configured_model_algorithm_association_arn: ::std::string::String,
    /// <p>The EC2 resource configuration that was used to create the trained model.</p>
    pub resource_config: ::std::option::Option<crate::types::ResourceConfig>,
    /// <p>The input mode that was used for accessing the training data when this trained model was created. This indicates how the training data was made available to the training algorithm.</p>
    pub training_input_mode: ::std::option::Option<crate::types::TrainingInputMode>,
    /// <p>The stopping condition that was used to terminate model training.</p>
    pub stopping_condition: ::std::option::Option<crate::types::StoppingCondition>,
    /// <p>The status of the model metrics.</p>
    pub metrics_status: ::std::option::Option<crate::types::MetricsStatus>,
    /// <p>Details about the metrics status for the trained model.</p>
    pub metrics_status_details: ::std::option::Option<::std::string::String>,
    /// <p>The logs status for the trained model.</p>
    pub logs_status: ::std::option::Option<crate::types::LogsStatus>,
    /// <p>Details about the logs status for the trained model.</p>
    pub logs_status_details: ::std::option::Option<::std::string::String>,
    /// <p>Information about the training image container.</p>
    pub training_container_image_digest: ::std::option::Option<::std::string::String>,
    /// <p>The time at which the trained model was created.</p>
    pub create_time: ::aws_smithy_types::DateTime,
    /// <p>The most recent time at which the trained model was updated.</p>
    pub update_time: ::aws_smithy_types::DateTime,
    /// <p>The hyperparameters that were used to create the trained model.</p>
    pub hyperparameters: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The EC2 environment that was used to create the trained model.</p>
    pub environment: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and associated data.</p>
    pub kms_key_arn: ::std::option::Option<::std::string::String>,
    /// <p>The optional metadata that you applied to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource - 50.</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length - 128 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>Maximum value length - 256 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p></li>
    /// <li>
    /// <p>Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The data channels that were used for the trained model.</p>
    pub data_channels: ::std::vec::Vec<crate::types::ModelTrainingDataChannel>,
    _request_id: Option<String>,
}
impl GetTrainedModelOutput {
    /// <p>The membership ID of the member that created the trained model.</p>
    pub fn membership_identifier(&self) -> &str {
        use std::ops::Deref;
        self.membership_identifier.deref()
    }
    /// <p>The collaboration ID of the collaboration that contains the trained model.</p>
    pub fn collaboration_identifier(&self) -> &str {
        use std::ops::Deref;
        self.collaboration_identifier.deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the trained model.</p>
    pub fn trained_model_arn(&self) -> &str {
        use std::ops::Deref;
        self.trained_model_arn.deref()
    }
    /// <p>The version identifier of the trained model. This unique identifier distinguishes this version from other versions of the same trained model.</p>
    pub fn version_identifier(&self) -> ::std::option::Option<&str> {
        self.version_identifier.as_deref()
    }
    /// <p>Information about the incremental training data channels used to create this version of the trained model. This includes details about the base model that was used for incremental training and the channel configuration.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.incremental_training_data_channels.is_none()`.
    pub fn incremental_training_data_channels(&self) -> &[crate::types::IncrementalTrainingDataChannelOutput] {
        self.incremental_training_data_channels.as_deref().unwrap_or_default()
    }
    /// <p>The name of the trained model.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The description of the trained model.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The status of the trained model.</p>
    pub fn status(&self) -> &crate::types::TrainedModelStatus {
        &self.status
    }
    /// <p>Details about the status of a resource.</p>
    pub fn status_details(&self) -> ::std::option::Option<&crate::types::StatusDetails> {
        self.status_details.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the configured model algorithm association that was used to create the trained model.</p>
    pub fn configured_model_algorithm_association_arn(&self) -> &str {
        use std::ops::Deref;
        self.configured_model_algorithm_association_arn.deref()
    }
    /// <p>The EC2 resource configuration that was used to create the trained model.</p>
    pub fn resource_config(&self) -> ::std::option::Option<&crate::types::ResourceConfig> {
        self.resource_config.as_ref()
    }
    /// <p>The input mode that was used for accessing the training data when this trained model was created. This indicates how the training data was made available to the training algorithm.</p>
    pub fn training_input_mode(&self) -> ::std::option::Option<&crate::types::TrainingInputMode> {
        self.training_input_mode.as_ref()
    }
    /// <p>The stopping condition that was used to terminate model training.</p>
    pub fn stopping_condition(&self) -> ::std::option::Option<&crate::types::StoppingCondition> {
        self.stopping_condition.as_ref()
    }
    /// <p>The status of the model metrics.</p>
    pub fn metrics_status(&self) -> ::std::option::Option<&crate::types::MetricsStatus> {
        self.metrics_status.as_ref()
    }
    /// <p>Details about the metrics status for the trained model.</p>
    pub fn metrics_status_details(&self) -> ::std::option::Option<&str> {
        self.metrics_status_details.as_deref()
    }
    /// <p>The logs status for the trained model.</p>
    pub fn logs_status(&self) -> ::std::option::Option<&crate::types::LogsStatus> {
        self.logs_status.as_ref()
    }
    /// <p>Details about the logs status for the trained model.</p>
    pub fn logs_status_details(&self) -> ::std::option::Option<&str> {
        self.logs_status_details.as_deref()
    }
    /// <p>Information about the training image container.</p>
    pub fn training_container_image_digest(&self) -> ::std::option::Option<&str> {
        self.training_container_image_digest.as_deref()
    }
    /// <p>The time at which the trained model was created.</p>
    pub fn create_time(&self) -> &::aws_smithy_types::DateTime {
        &self.create_time
    }
    /// <p>The most recent time at which the trained model was updated.</p>
    pub fn update_time(&self) -> &::aws_smithy_types::DateTime {
        &self.update_time
    }
    /// <p>The hyperparameters that were used to create the trained model.</p>
    pub fn hyperparameters(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.hyperparameters.as_ref()
    }
    /// <p>The EC2 environment that was used to create the trained model.</p>
    pub fn environment(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.environment.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and associated data.</p>
    pub fn kms_key_arn(&self) -> ::std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
    /// <p>The optional metadata that you applied to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource - 50.</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length - 128 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>Maximum value length - 256 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p></li>
    /// <li>
    /// <p>Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The data channels that were used for the trained model.</p>
    pub fn data_channels(&self) -> &[crate::types::ModelTrainingDataChannel] {
        use std::ops::Deref;
        self.data_channels.deref()
    }
}
impl ::aws_types::request_id::RequestId for GetTrainedModelOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetTrainedModelOutput {
    /// Creates a new builder-style object to manufacture [`GetTrainedModelOutput`](crate::operation::get_trained_model::GetTrainedModelOutput).
    pub fn builder() -> crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder {
        crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::default()
    }
}

/// A builder for [`GetTrainedModelOutput`](crate::operation::get_trained_model::GetTrainedModelOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GetTrainedModelOutputBuilder {
    pub(crate) membership_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) collaboration_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) trained_model_arn: ::std::option::Option<::std::string::String>,
    pub(crate) version_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) incremental_training_data_channels: ::std::option::Option<::std::vec::Vec<crate::types::IncrementalTrainingDataChannelOutput>>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::TrainedModelStatus>,
    pub(crate) status_details: ::std::option::Option<crate::types::StatusDetails>,
    pub(crate) configured_model_algorithm_association_arn: ::std::option::Option<::std::string::String>,
    pub(crate) resource_config: ::std::option::Option<crate::types::ResourceConfig>,
    pub(crate) training_input_mode: ::std::option::Option<crate::types::TrainingInputMode>,
    pub(crate) stopping_condition: ::std::option::Option<crate::types::StoppingCondition>,
    pub(crate) metrics_status: ::std::option::Option<crate::types::MetricsStatus>,
    pub(crate) metrics_status_details: ::std::option::Option<::std::string::String>,
    pub(crate) logs_status: ::std::option::Option<crate::types::LogsStatus>,
    pub(crate) logs_status_details: ::std::option::Option<::std::string::String>,
    pub(crate) training_container_image_digest: ::std::option::Option<::std::string::String>,
    pub(crate) create_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) update_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) hyperparameters: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) environment: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) kms_key_arn: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) data_channels: ::std::option::Option<::std::vec::Vec<crate::types::ModelTrainingDataChannel>>,
    _request_id: Option<String>,
}
impl GetTrainedModelOutputBuilder {
    /// <p>The membership ID of the member that created the trained model.</p>
    /// This field is required.
    pub fn membership_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.membership_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The membership ID of the member that created the trained model.</p>
    pub fn set_membership_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.membership_identifier = input;
        self
    }
    /// <p>The membership ID of the member that created the trained model.</p>
    pub fn get_membership_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.membership_identifier
    }
    /// <p>The collaboration ID of the collaboration that contains the trained model.</p>
    /// This field is required.
    pub fn collaboration_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.collaboration_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The collaboration ID of the collaboration that contains the trained model.</p>
    pub fn set_collaboration_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.collaboration_identifier = input;
        self
    }
    /// <p>The collaboration ID of the collaboration that contains the trained model.</p>
    pub fn get_collaboration_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.collaboration_identifier
    }
    /// <p>The Amazon Resource Name (ARN) of the trained model.</p>
    /// This field is required.
    pub fn trained_model_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.trained_model_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the trained model.</p>
    pub fn set_trained_model_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.trained_model_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the trained model.</p>
    pub fn get_trained_model_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.trained_model_arn
    }
    /// <p>The version identifier of the trained model. This unique identifier distinguishes this version from other versions of the same trained model.</p>
    pub fn version_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.version_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version identifier of the trained model. This unique identifier distinguishes this version from other versions of the same trained model.</p>
    pub fn set_version_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.version_identifier = input;
        self
    }
    /// <p>The version identifier of the trained model. This unique identifier distinguishes this version from other versions of the same trained model.</p>
    pub fn get_version_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.version_identifier
    }
    /// Appends an item to `incremental_training_data_channels`.
    ///
    /// To override the contents of this collection use [`set_incremental_training_data_channels`](Self::set_incremental_training_data_channels).
    ///
    /// <p>Information about the incremental training data channels used to create this version of the trained model. This includes details about the base model that was used for incremental training and the channel configuration.</p>
    pub fn incremental_training_data_channels(mut self, input: crate::types::IncrementalTrainingDataChannelOutput) -> Self {
        let mut v = self.incremental_training_data_channels.unwrap_or_default();
        v.push(input);
        self.incremental_training_data_channels = ::std::option::Option::Some(v);
        self
    }
    /// <p>Information about the incremental training data channels used to create this version of the trained model. This includes details about the base model that was used for incremental training and the channel configuration.</p>
    pub fn set_incremental_training_data_channels(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::IncrementalTrainingDataChannelOutput>>,
    ) -> Self {
        self.incremental_training_data_channels = input;
        self
    }
    /// <p>Information about the incremental training data channels used to create this version of the trained model. This includes details about the base model that was used for incremental training and the channel configuration.</p>
    pub fn get_incremental_training_data_channels(
        &self,
    ) -> &::std::option::Option<::std::vec::Vec<crate::types::IncrementalTrainingDataChannelOutput>> {
        &self.incremental_training_data_channels
    }
    /// <p>The name of the trained model.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the trained model.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the trained model.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The description of the trained model.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the trained model.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the trained model.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The status of the trained model.</p>
    /// This field is required.
    pub fn status(mut self, input: crate::types::TrainedModelStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the trained model.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::TrainedModelStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the trained model.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::TrainedModelStatus> {
        &self.status
    }
    /// <p>Details about the status of a resource.</p>
    pub fn status_details(mut self, input: crate::types::StatusDetails) -> Self {
        self.status_details = ::std::option::Option::Some(input);
        self
    }
    /// <p>Details about the status of a resource.</p>
    pub fn set_status_details(mut self, input: ::std::option::Option<crate::types::StatusDetails>) -> Self {
        self.status_details = input;
        self
    }
    /// <p>Details about the status of a resource.</p>
    pub fn get_status_details(&self) -> &::std::option::Option<crate::types::StatusDetails> {
        &self.status_details
    }
    /// <p>The Amazon Resource Name (ARN) of the configured model algorithm association that was used to create the trained model.</p>
    /// This field is required.
    pub fn configured_model_algorithm_association_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.configured_model_algorithm_association_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the configured model algorithm association that was used to create the trained model.</p>
    pub fn set_configured_model_algorithm_association_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.configured_model_algorithm_association_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the configured model algorithm association that was used to create the trained model.</p>
    pub fn get_configured_model_algorithm_association_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.configured_model_algorithm_association_arn
    }
    /// <p>The EC2 resource configuration that was used to create the trained model.</p>
    pub fn resource_config(mut self, input: crate::types::ResourceConfig) -> Self {
        self.resource_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The EC2 resource configuration that was used to create the trained model.</p>
    pub fn set_resource_config(mut self, input: ::std::option::Option<crate::types::ResourceConfig>) -> Self {
        self.resource_config = input;
        self
    }
    /// <p>The EC2 resource configuration that was used to create the trained model.</p>
    pub fn get_resource_config(&self) -> &::std::option::Option<crate::types::ResourceConfig> {
        &self.resource_config
    }
    /// <p>The input mode that was used for accessing the training data when this trained model was created. This indicates how the training data was made available to the training algorithm.</p>
    pub fn training_input_mode(mut self, input: crate::types::TrainingInputMode) -> Self {
        self.training_input_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>The input mode that was used for accessing the training data when this trained model was created. This indicates how the training data was made available to the training algorithm.</p>
    pub fn set_training_input_mode(mut self, input: ::std::option::Option<crate::types::TrainingInputMode>) -> Self {
        self.training_input_mode = input;
        self
    }
    /// <p>The input mode that was used for accessing the training data when this trained model was created. This indicates how the training data was made available to the training algorithm.</p>
    pub fn get_training_input_mode(&self) -> &::std::option::Option<crate::types::TrainingInputMode> {
        &self.training_input_mode
    }
    /// <p>The stopping condition that was used to terminate model training.</p>
    pub fn stopping_condition(mut self, input: crate::types::StoppingCondition) -> Self {
        self.stopping_condition = ::std::option::Option::Some(input);
        self
    }
    /// <p>The stopping condition that was used to terminate model training.</p>
    pub fn set_stopping_condition(mut self, input: ::std::option::Option<crate::types::StoppingCondition>) -> Self {
        self.stopping_condition = input;
        self
    }
    /// <p>The stopping condition that was used to terminate model training.</p>
    pub fn get_stopping_condition(&self) -> &::std::option::Option<crate::types::StoppingCondition> {
        &self.stopping_condition
    }
    /// <p>The status of the model metrics.</p>
    pub fn metrics_status(mut self, input: crate::types::MetricsStatus) -> Self {
        self.metrics_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the model metrics.</p>
    pub fn set_metrics_status(mut self, input: ::std::option::Option<crate::types::MetricsStatus>) -> Self {
        self.metrics_status = input;
        self
    }
    /// <p>The status of the model metrics.</p>
    pub fn get_metrics_status(&self) -> &::std::option::Option<crate::types::MetricsStatus> {
        &self.metrics_status
    }
    /// <p>Details about the metrics status for the trained model.</p>
    pub fn metrics_status_details(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.metrics_status_details = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Details about the metrics status for the trained model.</p>
    pub fn set_metrics_status_details(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.metrics_status_details = input;
        self
    }
    /// <p>Details about the metrics status for the trained model.</p>
    pub fn get_metrics_status_details(&self) -> &::std::option::Option<::std::string::String> {
        &self.metrics_status_details
    }
    /// <p>The logs status for the trained model.</p>
    pub fn logs_status(mut self, input: crate::types::LogsStatus) -> Self {
        self.logs_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The logs status for the trained model.</p>
    pub fn set_logs_status(mut self, input: ::std::option::Option<crate::types::LogsStatus>) -> Self {
        self.logs_status = input;
        self
    }
    /// <p>The logs status for the trained model.</p>
    pub fn get_logs_status(&self) -> &::std::option::Option<crate::types::LogsStatus> {
        &self.logs_status
    }
    /// <p>Details about the logs status for the trained model.</p>
    pub fn logs_status_details(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.logs_status_details = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Details about the logs status for the trained model.</p>
    pub fn set_logs_status_details(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.logs_status_details = input;
        self
    }
    /// <p>Details about the logs status for the trained model.</p>
    pub fn get_logs_status_details(&self) -> &::std::option::Option<::std::string::String> {
        &self.logs_status_details
    }
    /// <p>Information about the training image container.</p>
    pub fn training_container_image_digest(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.training_container_image_digest = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Information about the training image container.</p>
    pub fn set_training_container_image_digest(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.training_container_image_digest = input;
        self
    }
    /// <p>Information about the training image container.</p>
    pub fn get_training_container_image_digest(&self) -> &::std::option::Option<::std::string::String> {
        &self.training_container_image_digest
    }
    /// <p>The time at which the trained model was created.</p>
    /// This field is required.
    pub fn create_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.create_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time at which the trained model was created.</p>
    pub fn set_create_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.create_time = input;
        self
    }
    /// <p>The time at which the trained model was created.</p>
    pub fn get_create_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.create_time
    }
    /// <p>The most recent time at which the trained model was updated.</p>
    /// This field is required.
    pub fn update_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.update_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The most recent time at which the trained model was updated.</p>
    pub fn set_update_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.update_time = input;
        self
    }
    /// <p>The most recent time at which the trained model was updated.</p>
    pub fn get_update_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.update_time
    }
    /// Adds a key-value pair to `hyperparameters`.
    ///
    /// To override the contents of this collection use [`set_hyperparameters`](Self::set_hyperparameters).
    ///
    /// <p>The hyperparameters that were used to create the trained model.</p>
    pub fn hyperparameters(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.hyperparameters.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.hyperparameters = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The hyperparameters that were used to create the trained model.</p>
    pub fn set_hyperparameters(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.hyperparameters = input;
        self
    }
    /// <p>The hyperparameters that were used to create the trained model.</p>
    pub fn get_hyperparameters(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.hyperparameters
    }
    /// Adds a key-value pair to `environment`.
    ///
    /// To override the contents of this collection use [`set_environment`](Self::set_environment).
    ///
    /// <p>The EC2 environment that was used to create the trained model.</p>
    pub fn environment(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.environment.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.environment = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The EC2 environment that was used to create the trained model.</p>
    pub fn set_environment(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.environment = input;
        self
    }
    /// <p>The EC2 environment that was used to create the trained model.</p>
    pub fn get_environment(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.environment
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and associated data.</p>
    pub fn kms_key_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and associated data.</p>
    pub fn set_kms_key_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and associated data.</p>
    pub fn get_kms_key_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_arn
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The optional metadata that you applied to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource - 50.</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length - 128 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>Maximum value length - 256 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p></li>
    /// <li>
    /// <p>Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The optional metadata that you applied to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource - 50.</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length - 128 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>Maximum value length - 256 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p></li>
    /// <li>
    /// <p>Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The optional metadata that you applied to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per resource - 50.</p></li>
    /// <li>
    /// <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p></li>
    /// <li>
    /// <p>Maximum key length - 128 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>Maximum value length - 256 Unicode characters in UTF-8.</p></li>
    /// <li>
    /// <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p></li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p></li>
    /// <li>
    /// <p>Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.</p></li>
    /// </ul>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Appends an item to `data_channels`.
    ///
    /// To override the contents of this collection use [`set_data_channels`](Self::set_data_channels).
    ///
    /// <p>The data channels that were used for the trained model.</p>
    pub fn data_channels(mut self, input: crate::types::ModelTrainingDataChannel) -> Self {
        let mut v = self.data_channels.unwrap_or_default();
        v.push(input);
        self.data_channels = ::std::option::Option::Some(v);
        self
    }
    /// <p>The data channels that were used for the trained model.</p>
    pub fn set_data_channels(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ModelTrainingDataChannel>>) -> Self {
        self.data_channels = input;
        self
    }
    /// <p>The data channels that were used for the trained model.</p>
    pub fn get_data_channels(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ModelTrainingDataChannel>> {
        &self.data_channels
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetTrainedModelOutput`](crate::operation::get_trained_model::GetTrainedModelOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`membership_identifier`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::membership_identifier)
    /// - [`collaboration_identifier`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::collaboration_identifier)
    /// - [`trained_model_arn`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::trained_model_arn)
    /// - [`name`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::name)
    /// - [`status`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::status)
    /// - [`configured_model_algorithm_association_arn`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::configured_model_algorithm_association_arn)
    /// - [`create_time`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::create_time)
    /// - [`update_time`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::update_time)
    /// - [`data_channels`](crate::operation::get_trained_model::builders::GetTrainedModelOutputBuilder::data_channels)
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::get_trained_model::GetTrainedModelOutput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::get_trained_model::GetTrainedModelOutput {
            membership_identifier: self.membership_identifier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "membership_identifier",
                    "membership_identifier was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            collaboration_identifier: self.collaboration_identifier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "collaboration_identifier",
                    "collaboration_identifier was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            trained_model_arn: self.trained_model_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "trained_model_arn",
                    "trained_model_arn was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            version_identifier: self.version_identifier,
            incremental_training_data_channels: self.incremental_training_data_channels,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            description: self.description,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            status_details: self.status_details,
            configured_model_algorithm_association_arn: self.configured_model_algorithm_association_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "configured_model_algorithm_association_arn",
                    "configured_model_algorithm_association_arn was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            resource_config: self.resource_config,
            training_input_mode: self.training_input_mode,
            stopping_condition: self.stopping_condition,
            metrics_status: self.metrics_status,
            metrics_status_details: self.metrics_status_details,
            logs_status: self.logs_status,
            logs_status_details: self.logs_status_details,
            training_container_image_digest: self.training_container_image_digest,
            create_time: self.create_time.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "create_time",
                    "create_time was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            update_time: self.update_time.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "update_time",
                    "update_time was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            hyperparameters: self.hyperparameters,
            environment: self.environment,
            kms_key_arn: self.kms_key_arn,
            tags: self.tags,
            data_channels: self.data_channels.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "data_channels",
                    "data_channels was not specified but it is required when building GetTrainedModelOutput",
                )
            })?,
            _request_id: self._request_id,
        })
    }
}
