// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct UpdateFleetInput {
    /// <p>The unique token which the server uses to recognize retries of the same request.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The farm ID to update.</p>
    pub farm_id: ::std::option::Option<::std::string::String>,
    /// <p>The fleet ID to update.</p>
    pub fleet_id: ::std::option::Option<::std::string::String>,
    /// <p>The display name of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The description of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The IAM role ARN that the fleet's workers assume while running jobs.</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The minimum number of workers in the fleet.</p>
    pub min_worker_count: ::std::option::Option<i32>,
    /// <p>The maximum number of workers in the fleet.</p>
    /// <p>Deadline Cloud limits the number of workers to less than or equal to the fleet's maximum worker count. The service maintains eventual consistency for the worker count. If you make multiple rapid calls to <code>CreateWorker</code> before the field updates, you might exceed your fleet's maximum worker count. For example, if your <code>maxWorkerCount</code> is 10 and you currently have 9 workers, making two quick <code>CreateWorker</code> calls might successfully create 2 workers instead of 1, resulting in 11 total workers.</p>
    pub max_worker_count: ::std::option::Option<i32>,
    /// <p>The fleet configuration to update.</p>
    pub configuration: ::std::option::Option<crate::types::FleetConfiguration>,
    /// <p>Provides a script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet.</p>
    pub host_configuration: ::std::option::Option<crate::types::HostConfiguration>,
}
impl UpdateFleetInput {
    /// <p>The unique token which the server uses to recognize retries of the same request.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The farm ID to update.</p>
    pub fn farm_id(&self) -> ::std::option::Option<&str> {
        self.farm_id.as_deref()
    }
    /// <p>The fleet ID to update.</p>
    pub fn fleet_id(&self) -> ::std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p>The display name of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The description of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The IAM role ARN that the fleet's workers assume while running jobs.</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The minimum number of workers in the fleet.</p>
    pub fn min_worker_count(&self) -> ::std::option::Option<i32> {
        self.min_worker_count
    }
    /// <p>The maximum number of workers in the fleet.</p>
    /// <p>Deadline Cloud limits the number of workers to less than or equal to the fleet's maximum worker count. The service maintains eventual consistency for the worker count. If you make multiple rapid calls to <code>CreateWorker</code> before the field updates, you might exceed your fleet's maximum worker count. For example, if your <code>maxWorkerCount</code> is 10 and you currently have 9 workers, making two quick <code>CreateWorker</code> calls might successfully create 2 workers instead of 1, resulting in 11 total workers.</p>
    pub fn max_worker_count(&self) -> ::std::option::Option<i32> {
        self.max_worker_count
    }
    /// <p>The fleet configuration to update.</p>
    pub fn configuration(&self) -> ::std::option::Option<&crate::types::FleetConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>Provides a script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet.</p>
    pub fn host_configuration(&self) -> ::std::option::Option<&crate::types::HostConfiguration> {
        self.host_configuration.as_ref()
    }
}
impl ::std::fmt::Debug for UpdateFleetInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFleetInput");
        formatter.field("client_token", &self.client_token);
        formatter.field("farm_id", &self.farm_id);
        formatter.field("fleet_id", &self.fleet_id);
        formatter.field("display_name", &self.display_name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("min_worker_count", &self.min_worker_count);
        formatter.field("max_worker_count", &self.max_worker_count);
        formatter.field("configuration", &self.configuration);
        formatter.field("host_configuration", &self.host_configuration);
        formatter.finish()
    }
}
impl UpdateFleetInput {
    /// Creates a new builder-style object to manufacture [`UpdateFleetInput`](crate::operation::update_fleet::UpdateFleetInput).
    pub fn builder() -> crate::operation::update_fleet::builders::UpdateFleetInputBuilder {
        crate::operation::update_fleet::builders::UpdateFleetInputBuilder::default()
    }
}

/// A builder for [`UpdateFleetInput`](crate::operation::update_fleet::UpdateFleetInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct UpdateFleetInputBuilder {
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) farm_id: ::std::option::Option<::std::string::String>,
    pub(crate) fleet_id: ::std::option::Option<::std::string::String>,
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) min_worker_count: ::std::option::Option<i32>,
    pub(crate) max_worker_count: ::std::option::Option<i32>,
    pub(crate) configuration: ::std::option::Option<crate::types::FleetConfiguration>,
    pub(crate) host_configuration: ::std::option::Option<crate::types::HostConfiguration>,
}
impl UpdateFleetInputBuilder {
    /// <p>The unique token which the server uses to recognize retries of the same request.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique token which the server uses to recognize retries of the same request.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>The unique token which the server uses to recognize retries of the same request.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The farm ID to update.</p>
    /// This field is required.
    pub fn farm_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.farm_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The farm ID to update.</p>
    pub fn set_farm_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.farm_id = input;
        self
    }
    /// <p>The farm ID to update.</p>
    pub fn get_farm_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.farm_id
    }
    /// <p>The fleet ID to update.</p>
    /// This field is required.
    pub fn fleet_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The fleet ID to update.</p>
    pub fn set_fleet_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_id = input;
        self
    }
    /// <p>The fleet ID to update.</p>
    pub fn get_fleet_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_id
    }
    /// <p>The display name of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The display name of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The display name of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The description of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the fleet to update.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The IAM role ARN that the fleet's workers assume while running jobs.</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IAM role ARN that the fleet's workers assume while running jobs.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The IAM role ARN that the fleet's workers assume while running jobs.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// <p>The minimum number of workers in the fleet.</p>
    pub fn min_worker_count(mut self, input: i32) -> Self {
        self.min_worker_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum number of workers in the fleet.</p>
    pub fn set_min_worker_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.min_worker_count = input;
        self
    }
    /// <p>The minimum number of workers in the fleet.</p>
    pub fn get_min_worker_count(&self) -> &::std::option::Option<i32> {
        &self.min_worker_count
    }
    /// <p>The maximum number of workers in the fleet.</p>
    /// <p>Deadline Cloud limits the number of workers to less than or equal to the fleet's maximum worker count. The service maintains eventual consistency for the worker count. If you make multiple rapid calls to <code>CreateWorker</code> before the field updates, you might exceed your fleet's maximum worker count. For example, if your <code>maxWorkerCount</code> is 10 and you currently have 9 workers, making two quick <code>CreateWorker</code> calls might successfully create 2 workers instead of 1, resulting in 11 total workers.</p>
    pub fn max_worker_count(mut self, input: i32) -> Self {
        self.max_worker_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of workers in the fleet.</p>
    /// <p>Deadline Cloud limits the number of workers to less than or equal to the fleet's maximum worker count. The service maintains eventual consistency for the worker count. If you make multiple rapid calls to <code>CreateWorker</code> before the field updates, you might exceed your fleet's maximum worker count. For example, if your <code>maxWorkerCount</code> is 10 and you currently have 9 workers, making two quick <code>CreateWorker</code> calls might successfully create 2 workers instead of 1, resulting in 11 total workers.</p>
    pub fn set_max_worker_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_worker_count = input;
        self
    }
    /// <p>The maximum number of workers in the fleet.</p>
    /// <p>Deadline Cloud limits the number of workers to less than or equal to the fleet's maximum worker count. The service maintains eventual consistency for the worker count. If you make multiple rapid calls to <code>CreateWorker</code> before the field updates, you might exceed your fleet's maximum worker count. For example, if your <code>maxWorkerCount</code> is 10 and you currently have 9 workers, making two quick <code>CreateWorker</code> calls might successfully create 2 workers instead of 1, resulting in 11 total workers.</p>
    pub fn get_max_worker_count(&self) -> &::std::option::Option<i32> {
        &self.max_worker_count
    }
    /// <p>The fleet configuration to update.</p>
    pub fn configuration(mut self, input: crate::types::FleetConfiguration) -> Self {
        self.configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The fleet configuration to update.</p>
    pub fn set_configuration(mut self, input: ::std::option::Option<crate::types::FleetConfiguration>) -> Self {
        self.configuration = input;
        self
    }
    /// <p>The fleet configuration to update.</p>
    pub fn get_configuration(&self) -> &::std::option::Option<crate::types::FleetConfiguration> {
        &self.configuration
    }
    /// <p>Provides a script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet.</p>
    pub fn host_configuration(mut self, input: crate::types::HostConfiguration) -> Self {
        self.host_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides a script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet.</p>
    pub fn set_host_configuration(mut self, input: ::std::option::Option<crate::types::HostConfiguration>) -> Self {
        self.host_configuration = input;
        self
    }
    /// <p>Provides a script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet.</p>
    pub fn get_host_configuration(&self) -> &::std::option::Option<crate::types::HostConfiguration> {
        &self.host_configuration
    }
    /// Consumes the builder and constructs a [`UpdateFleetInput`](crate::operation::update_fleet::UpdateFleetInput).
    pub fn build(self) -> ::std::result::Result<crate::operation::update_fleet::UpdateFleetInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::update_fleet::UpdateFleetInput {
            client_token: self.client_token,
            farm_id: self.farm_id,
            fleet_id: self.fleet_id,
            display_name: self.display_name,
            description: self.description,
            role_arn: self.role_arn,
            min_worker_count: self.min_worker_count,
            max_worker_count: self.max_worker_count,
            configuration: self.configuration,
            host_configuration: self.host_configuration,
        })
    }
}
impl ::std::fmt::Debug for UpdateFleetInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFleetInputBuilder");
        formatter.field("client_token", &self.client_token);
        formatter.field("farm_id", &self.farm_id);
        formatter.field("fleet_id", &self.fleet_id);
        formatter.field("display_name", &self.display_name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("min_worker_count", &self.min_worker_count);
        formatter.field("max_worker_count", &self.max_worker_count);
        formatter.field("configuration", &self.configuration);
        formatter.field("host_configuration", &self.host_configuration);
        formatter.finish()
    }
}
