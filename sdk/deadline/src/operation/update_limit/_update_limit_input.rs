// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct UpdateLimitInput {
    /// <p>The unique identifier of the farm that contains the limit.</p>
    pub farm_id: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the limit to update.</p>
    pub limit_id: ::std::option::Option<::std::string::String>,
    /// <p>The new display name of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The new description of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available.</p>
    /// <p>If more than the new maximum number is currently in use, running jobs finish but no new jobs are started until the number of resources in use is below the new maximum number.</p>
    /// <p>The <code>maxCount</code> must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.</p>
    pub max_count: ::std::option::Option<i32>,
}
impl UpdateLimitInput {
    /// <p>The unique identifier of the farm that contains the limit.</p>
    pub fn farm_id(&self) -> ::std::option::Option<&str> {
        self.farm_id.as_deref()
    }
    /// <p>The unique identifier of the limit to update.</p>
    pub fn limit_id(&self) -> ::std::option::Option<&str> {
        self.limit_id.as_deref()
    }
    /// <p>The new display name of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The new description of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available.</p>
    /// <p>If more than the new maximum number is currently in use, running jobs finish but no new jobs are started until the number of resources in use is below the new maximum number.</p>
    /// <p>The <code>maxCount</code> must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.</p>
    pub fn max_count(&self) -> ::std::option::Option<i32> {
        self.max_count
    }
}
impl ::std::fmt::Debug for UpdateLimitInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLimitInput");
        formatter.field("farm_id", &self.farm_id);
        formatter.field("limit_id", &self.limit_id);
        formatter.field("display_name", &self.display_name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("max_count", &self.max_count);
        formatter.finish()
    }
}
impl UpdateLimitInput {
    /// Creates a new builder-style object to manufacture [`UpdateLimitInput`](crate::operation::update_limit::UpdateLimitInput).
    pub fn builder() -> crate::operation::update_limit::builders::UpdateLimitInputBuilder {
        crate::operation::update_limit::builders::UpdateLimitInputBuilder::default()
    }
}

/// A builder for [`UpdateLimitInput`](crate::operation::update_limit::UpdateLimitInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct UpdateLimitInputBuilder {
    pub(crate) farm_id: ::std::option::Option<::std::string::String>,
    pub(crate) limit_id: ::std::option::Option<::std::string::String>,
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) max_count: ::std::option::Option<i32>,
}
impl UpdateLimitInputBuilder {
    /// <p>The unique identifier of the farm that contains the limit.</p>
    /// This field is required.
    pub fn farm_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.farm_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the farm that contains the limit.</p>
    pub fn set_farm_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.farm_id = input;
        self
    }
    /// <p>The unique identifier of the farm that contains the limit.</p>
    pub fn get_farm_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.farm_id
    }
    /// <p>The unique identifier of the limit to update.</p>
    /// This field is required.
    pub fn limit_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.limit_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the limit to update.</p>
    pub fn set_limit_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.limit_id = input;
        self
    }
    /// <p>The unique identifier of the limit to update.</p>
    pub fn get_limit_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.limit_id
    }
    /// <p>The new display name of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The new display name of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The new display name of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The new description of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The new description of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The new description of the limit.</p><important>
    /// <p>This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.</p>
    /// </important>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available.</p>
    /// <p>If more than the new maximum number is currently in use, running jobs finish but no new jobs are started until the number of resources in use is below the new maximum number.</p>
    /// <p>The <code>maxCount</code> must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.</p>
    pub fn max_count(mut self, input: i32) -> Self {
        self.max_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available.</p>
    /// <p>If more than the new maximum number is currently in use, running jobs finish but no new jobs are started until the number of resources in use is below the new maximum number.</p>
    /// <p>The <code>maxCount</code> must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.</p>
    pub fn set_max_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_count = input;
        self
    }
    /// <p>The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available.</p>
    /// <p>If more than the new maximum number is currently in use, running jobs finish but no new jobs are started until the number of resources in use is below the new maximum number.</p>
    /// <p>The <code>maxCount</code> must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.</p>
    pub fn get_max_count(&self) -> &::std::option::Option<i32> {
        &self.max_count
    }
    /// Consumes the builder and constructs a [`UpdateLimitInput`](crate::operation::update_limit::UpdateLimitInput).
    pub fn build(self) -> ::std::result::Result<crate::operation::update_limit::UpdateLimitInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::update_limit::UpdateLimitInput {
            farm_id: self.farm_id,
            limit_id: self.limit_id,
            display_name: self.display_name,
            description: self.description,
            max_count: self.max_count,
        })
    }
}
impl ::std::fmt::Debug for UpdateLimitInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLimitInputBuilder");
        formatter.field("farm_id", &self.farm_id);
        formatter.field("limit_id", &self.limit_id);
        formatter.field("display_name", &self.display_name);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("max_count", &self.max_count);
        formatter.finish()
    }
}
