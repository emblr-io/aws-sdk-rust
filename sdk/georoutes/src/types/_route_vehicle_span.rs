// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Span computed for the requested SpanAdditionalFeatures.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RouteVehicleSpan {
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub best_case_duration: i64,
    /// <p>Access attributes for a car corresponding to the span.</p>
    pub car_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanCarAccessAttribute>>,
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub country: ::std::option::Option<::std::string::String>,
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub distance: i64,
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub duration: i64,
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub dynamic_speed: ::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails>,
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub functional_classification: ::std::option::Option<i32>,
    /// <p>Attributes corresponding to a gate. The gate is present at the end of the returned span.</p>
    pub gate: ::std::option::Option<crate::types::RouteSpanGateAttribute>,
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub geometry_offset: ::std::option::Option<i32>,
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub incidents: ::std::option::Option<::std::vec::Vec<i32>>,
    /// <p>Provides an array of names of the vehicle span in available languages.</p>
    pub names: ::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>>,
    /// <p>Notices are additional information returned that indicate issues that occurred during route calculation.</p>
    pub notices: ::std::option::Option<::std::vec::Vec<i32>>,
    /// <p>Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.</p>
    pub railway_crossing: ::std::option::Option<crate::types::RouteSpanRailwayCrossingAttribute>,
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub region: ::std::option::Option<::std::string::String>,
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub road_attributes: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>>,
    /// <p>Designated route name or number corresponding to the span.</p>
    pub route_numbers: ::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>>,
    /// <p>Access attributes for a scooter corresponding to the span.</p>
    pub scooter_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanScooterAccessAttribute>>,
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub speed_limit: ::std::option::Option<crate::types::RouteSpanSpeedLimitDetails>,
    /// <p>Toll systems are authorities that collect payments for the toll.</p>
    pub toll_systems: ::std::option::Option<::std::vec::Vec<i32>>,
    /// <p>Access attributes for a truck corresponding to the span.</p>
    pub truck_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanTruckAccessAttribute>>,
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub truck_road_types: ::std::option::Option<::std::vec::Vec<i32>>,
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub typical_duration: i64,
    /// <p>Zones corresponding to this leg of the route.</p>
    pub zones: ::std::option::Option<::std::vec::Vec<i32>>,
}
impl RouteVehicleSpan {
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn best_case_duration(&self) -> i64 {
        self.best_case_duration
    }
    /// <p>Access attributes for a car corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.car_access.is_none()`.
    pub fn car_access(&self) -> &[crate::types::RouteSpanCarAccessAttribute] {
        self.car_access.as_deref().unwrap_or_default()
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn country(&self) -> ::std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn distance(&self) -> i64 {
        self.distance
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn duration(&self) -> i64 {
        self.duration
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn dynamic_speed(&self) -> ::std::option::Option<&crate::types::RouteSpanDynamicSpeedDetails> {
        self.dynamic_speed.as_ref()
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn functional_classification(&self) -> ::std::option::Option<i32> {
        self.functional_classification
    }
    /// <p>Attributes corresponding to a gate. The gate is present at the end of the returned span.</p>
    pub fn gate(&self) -> ::std::option::Option<&crate::types::RouteSpanGateAttribute> {
        self.gate.as_ref()
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn geometry_offset(&self) -> ::std::option::Option<i32> {
        self.geometry_offset
    }
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.incidents.is_none()`.
    pub fn incidents(&self) -> &[i32] {
        self.incidents.as_deref().unwrap_or_default()
    }
    /// <p>Provides an array of names of the vehicle span in available languages.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.names.is_none()`.
    pub fn names(&self) -> &[crate::types::LocalizedString] {
        self.names.as_deref().unwrap_or_default()
    }
    /// <p>Notices are additional information returned that indicate issues that occurred during route calculation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.notices.is_none()`.
    pub fn notices(&self) -> &[i32] {
        self.notices.as_deref().unwrap_or_default()
    }
    /// <p>Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.</p>
    pub fn railway_crossing(&self) -> ::std::option::Option<&crate::types::RouteSpanRailwayCrossingAttribute> {
        self.railway_crossing.as_ref()
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn region(&self) -> ::std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>Attributes for the road segment corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.road_attributes.is_none()`.
    pub fn road_attributes(&self) -> &[crate::types::RouteSpanRoadAttribute] {
        self.road_attributes.as_deref().unwrap_or_default()
    }
    /// <p>Designated route name or number corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.route_numbers.is_none()`.
    pub fn route_numbers(&self) -> &[crate::types::RouteNumber] {
        self.route_numbers.as_deref().unwrap_or_default()
    }
    /// <p>Access attributes for a scooter corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.scooter_access.is_none()`.
    pub fn scooter_access(&self) -> &[crate::types::RouteSpanScooterAccessAttribute] {
        self.scooter_access.as_deref().unwrap_or_default()
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn speed_limit(&self) -> ::std::option::Option<&crate::types::RouteSpanSpeedLimitDetails> {
        self.speed_limit.as_ref()
    }
    /// <p>Toll systems are authorities that collect payments for the toll.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.toll_systems.is_none()`.
    pub fn toll_systems(&self) -> &[i32] {
        self.toll_systems.as_deref().unwrap_or_default()
    }
    /// <p>Access attributes for a truck corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.truck_access.is_none()`.
    pub fn truck_access(&self) -> &[crate::types::RouteSpanTruckAccessAttribute] {
        self.truck_access.as_deref().unwrap_or_default()
    }
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.truck_road_types.is_none()`.
    pub fn truck_road_types(&self) -> &[i32] {
        self.truck_road_types.as_deref().unwrap_or_default()
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn typical_duration(&self) -> i64 {
        self.typical_duration
    }
    /// <p>Zones corresponding to this leg of the route.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.zones.is_none()`.
    pub fn zones(&self) -> &[i32] {
        self.zones.as_deref().unwrap_or_default()
    }
}
impl RouteVehicleSpan {
    /// Creates a new builder-style object to manufacture [`RouteVehicleSpan`](crate::types::RouteVehicleSpan).
    pub fn builder() -> crate::types::builders::RouteVehicleSpanBuilder {
        crate::types::builders::RouteVehicleSpanBuilder::default()
    }
}

/// A builder for [`RouteVehicleSpan`](crate::types::RouteVehicleSpan).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RouteVehicleSpanBuilder {
    pub(crate) best_case_duration: ::std::option::Option<i64>,
    pub(crate) car_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanCarAccessAttribute>>,
    pub(crate) country: ::std::option::Option<::std::string::String>,
    pub(crate) distance: ::std::option::Option<i64>,
    pub(crate) duration: ::std::option::Option<i64>,
    pub(crate) dynamic_speed: ::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails>,
    pub(crate) functional_classification: ::std::option::Option<i32>,
    pub(crate) gate: ::std::option::Option<crate::types::RouteSpanGateAttribute>,
    pub(crate) geometry_offset: ::std::option::Option<i32>,
    pub(crate) incidents: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) names: ::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>>,
    pub(crate) notices: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) railway_crossing: ::std::option::Option<crate::types::RouteSpanRailwayCrossingAttribute>,
    pub(crate) region: ::std::option::Option<::std::string::String>,
    pub(crate) road_attributes: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>>,
    pub(crate) route_numbers: ::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>>,
    pub(crate) scooter_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanScooterAccessAttribute>>,
    pub(crate) speed_limit: ::std::option::Option<crate::types::RouteSpanSpeedLimitDetails>,
    pub(crate) toll_systems: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) truck_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanTruckAccessAttribute>>,
    pub(crate) truck_road_types: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) typical_duration: ::std::option::Option<i64>,
    pub(crate) zones: ::std::option::Option<::std::vec::Vec<i32>>,
}
impl RouteVehicleSpanBuilder {
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn best_case_duration(mut self, input: i64) -> Self {
        self.best_case_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_best_case_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.best_case_duration = input;
        self
    }
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_best_case_duration(&self) -> &::std::option::Option<i64> {
        &self.best_case_duration
    }
    /// Appends an item to `car_access`.
    ///
    /// To override the contents of this collection use [`set_car_access`](Self::set_car_access).
    ///
    /// <p>Access attributes for a car corresponding to the span.</p>
    pub fn car_access(mut self, input: crate::types::RouteSpanCarAccessAttribute) -> Self {
        let mut v = self.car_access.unwrap_or_default();
        v.push(input);
        self.car_access = ::std::option::Option::Some(v);
        self
    }
    /// <p>Access attributes for a car corresponding to the span.</p>
    pub fn set_car_access(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanCarAccessAttribute>>) -> Self {
        self.car_access = input;
        self
    }
    /// <p>Access attributes for a car corresponding to the span.</p>
    pub fn get_car_access(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteSpanCarAccessAttribute>> {
        &self.car_access
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn country(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.country = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn set_country(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.country = input;
        self
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn get_country(&self) -> &::std::option::Option<::std::string::String> {
        &self.country
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn distance(mut self, input: i64) -> Self {
        self.distance = ::std::option::Option::Some(input);
        self
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn set_distance(mut self, input: ::std::option::Option<i64>) -> Self {
        self.distance = input;
        self
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn get_distance(&self) -> &::std::option::Option<i64> {
        &self.distance
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn duration(mut self, input: i64) -> Self {
        self.duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.duration = input;
        self
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_duration(&self) -> &::std::option::Option<i64> {
        &self.duration
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn dynamic_speed(mut self, input: crate::types::RouteSpanDynamicSpeedDetails) -> Self {
        self.dynamic_speed = ::std::option::Option::Some(input);
        self
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn set_dynamic_speed(mut self, input: ::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails>) -> Self {
        self.dynamic_speed = input;
        self
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn get_dynamic_speed(&self) -> &::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails> {
        &self.dynamic_speed
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn functional_classification(mut self, input: i32) -> Self {
        self.functional_classification = ::std::option::Option::Some(input);
        self
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn set_functional_classification(mut self, input: ::std::option::Option<i32>) -> Self {
        self.functional_classification = input;
        self
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn get_functional_classification(&self) -> &::std::option::Option<i32> {
        &self.functional_classification
    }
    /// <p>Attributes corresponding to a gate. The gate is present at the end of the returned span.</p>
    pub fn gate(mut self, input: crate::types::RouteSpanGateAttribute) -> Self {
        self.gate = ::std::option::Option::Some(input);
        self
    }
    /// <p>Attributes corresponding to a gate. The gate is present at the end of the returned span.</p>
    pub fn set_gate(mut self, input: ::std::option::Option<crate::types::RouteSpanGateAttribute>) -> Self {
        self.gate = input;
        self
    }
    /// <p>Attributes corresponding to a gate. The gate is present at the end of the returned span.</p>
    pub fn get_gate(&self) -> &::std::option::Option<crate::types::RouteSpanGateAttribute> {
        &self.gate
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn geometry_offset(mut self, input: i32) -> Self {
        self.geometry_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn set_geometry_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.geometry_offset = input;
        self
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn get_geometry_offset(&self) -> &::std::option::Option<i32> {
        &self.geometry_offset
    }
    /// Appends an item to `incidents`.
    ///
    /// To override the contents of this collection use [`set_incidents`](Self::set_incidents).
    ///
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub fn incidents(mut self, input: i32) -> Self {
        let mut v = self.incidents.unwrap_or_default();
        v.push(input);
        self.incidents = ::std::option::Option::Some(v);
        self
    }
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub fn set_incidents(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.incidents = input;
        self
    }
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub fn get_incidents(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.incidents
    }
    /// Appends an item to `names`.
    ///
    /// To override the contents of this collection use [`set_names`](Self::set_names).
    ///
    /// <p>Provides an array of names of the vehicle span in available languages.</p>
    pub fn names(mut self, input: crate::types::LocalizedString) -> Self {
        let mut v = self.names.unwrap_or_default();
        v.push(input);
        self.names = ::std::option::Option::Some(v);
        self
    }
    /// <p>Provides an array of names of the vehicle span in available languages.</p>
    pub fn set_names(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>>) -> Self {
        self.names = input;
        self
    }
    /// <p>Provides an array of names of the vehicle span in available languages.</p>
    pub fn get_names(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>> {
        &self.names
    }
    /// Appends an item to `notices`.
    ///
    /// To override the contents of this collection use [`set_notices`](Self::set_notices).
    ///
    /// <p>Notices are additional information returned that indicate issues that occurred during route calculation.</p>
    pub fn notices(mut self, input: i32) -> Self {
        let mut v = self.notices.unwrap_or_default();
        v.push(input);
        self.notices = ::std::option::Option::Some(v);
        self
    }
    /// <p>Notices are additional information returned that indicate issues that occurred during route calculation.</p>
    pub fn set_notices(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.notices = input;
        self
    }
    /// <p>Notices are additional information returned that indicate issues that occurred during route calculation.</p>
    pub fn get_notices(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.notices
    }
    /// <p>Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.</p>
    pub fn railway_crossing(mut self, input: crate::types::RouteSpanRailwayCrossingAttribute) -> Self {
        self.railway_crossing = ::std::option::Option::Some(input);
        self
    }
    /// <p>Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.</p>
    pub fn set_railway_crossing(mut self, input: ::std::option::Option<crate::types::RouteSpanRailwayCrossingAttribute>) -> Self {
        self.railway_crossing = input;
        self
    }
    /// <p>Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.</p>
    pub fn get_railway_crossing(&self) -> &::std::option::Option<crate::types::RouteSpanRailwayCrossingAttribute> {
        &self.railway_crossing
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.region = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn set_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.region = input;
        self
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn get_region(&self) -> &::std::option::Option<::std::string::String> {
        &self.region
    }
    /// Appends an item to `road_attributes`.
    ///
    /// To override the contents of this collection use [`set_road_attributes`](Self::set_road_attributes).
    ///
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub fn road_attributes(mut self, input: crate::types::RouteSpanRoadAttribute) -> Self {
        let mut v = self.road_attributes.unwrap_or_default();
        v.push(input);
        self.road_attributes = ::std::option::Option::Some(v);
        self
    }
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub fn set_road_attributes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>>) -> Self {
        self.road_attributes = input;
        self
    }
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub fn get_road_attributes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>> {
        &self.road_attributes
    }
    /// Appends an item to `route_numbers`.
    ///
    /// To override the contents of this collection use [`set_route_numbers`](Self::set_route_numbers).
    ///
    /// <p>Designated route name or number corresponding to the span.</p>
    pub fn route_numbers(mut self, input: crate::types::RouteNumber) -> Self {
        let mut v = self.route_numbers.unwrap_or_default();
        v.push(input);
        self.route_numbers = ::std::option::Option::Some(v);
        self
    }
    /// <p>Designated route name or number corresponding to the span.</p>
    pub fn set_route_numbers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>>) -> Self {
        self.route_numbers = input;
        self
    }
    /// <p>Designated route name or number corresponding to the span.</p>
    pub fn get_route_numbers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>> {
        &self.route_numbers
    }
    /// Appends an item to `scooter_access`.
    ///
    /// To override the contents of this collection use [`set_scooter_access`](Self::set_scooter_access).
    ///
    /// <p>Access attributes for a scooter corresponding to the span.</p>
    pub fn scooter_access(mut self, input: crate::types::RouteSpanScooterAccessAttribute) -> Self {
        let mut v = self.scooter_access.unwrap_or_default();
        v.push(input);
        self.scooter_access = ::std::option::Option::Some(v);
        self
    }
    /// <p>Access attributes for a scooter corresponding to the span.</p>
    pub fn set_scooter_access(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanScooterAccessAttribute>>) -> Self {
        self.scooter_access = input;
        self
    }
    /// <p>Access attributes for a scooter corresponding to the span.</p>
    pub fn get_scooter_access(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteSpanScooterAccessAttribute>> {
        &self.scooter_access
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn speed_limit(mut self, input: crate::types::RouteSpanSpeedLimitDetails) -> Self {
        self.speed_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn set_speed_limit(mut self, input: ::std::option::Option<crate::types::RouteSpanSpeedLimitDetails>) -> Self {
        self.speed_limit = input;
        self
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn get_speed_limit(&self) -> &::std::option::Option<crate::types::RouteSpanSpeedLimitDetails> {
        &self.speed_limit
    }
    /// Appends an item to `toll_systems`.
    ///
    /// To override the contents of this collection use [`set_toll_systems`](Self::set_toll_systems).
    ///
    /// <p>Toll systems are authorities that collect payments for the toll.</p>
    pub fn toll_systems(mut self, input: i32) -> Self {
        let mut v = self.toll_systems.unwrap_or_default();
        v.push(input);
        self.toll_systems = ::std::option::Option::Some(v);
        self
    }
    /// <p>Toll systems are authorities that collect payments for the toll.</p>
    pub fn set_toll_systems(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.toll_systems = input;
        self
    }
    /// <p>Toll systems are authorities that collect payments for the toll.</p>
    pub fn get_toll_systems(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.toll_systems
    }
    /// Appends an item to `truck_access`.
    ///
    /// To override the contents of this collection use [`set_truck_access`](Self::set_truck_access).
    ///
    /// <p>Access attributes for a truck corresponding to the span.</p>
    pub fn truck_access(mut self, input: crate::types::RouteSpanTruckAccessAttribute) -> Self {
        let mut v = self.truck_access.unwrap_or_default();
        v.push(input);
        self.truck_access = ::std::option::Option::Some(v);
        self
    }
    /// <p>Access attributes for a truck corresponding to the span.</p>
    pub fn set_truck_access(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanTruckAccessAttribute>>) -> Self {
        self.truck_access = input;
        self
    }
    /// <p>Access attributes for a truck corresponding to the span.</p>
    pub fn get_truck_access(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteSpanTruckAccessAttribute>> {
        &self.truck_access
    }
    /// Appends an item to `truck_road_types`.
    ///
    /// To override the contents of this collection use [`set_truck_road_types`](Self::set_truck_road_types).
    ///
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub fn truck_road_types(mut self, input: i32) -> Self {
        let mut v = self.truck_road_types.unwrap_or_default();
        v.push(input);
        self.truck_road_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub fn set_truck_road_types(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.truck_road_types = input;
        self
    }
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub fn get_truck_road_types(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.truck_road_types
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn typical_duration(mut self, input: i64) -> Self {
        self.typical_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_typical_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.typical_duration = input;
        self
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_typical_duration(&self) -> &::std::option::Option<i64> {
        &self.typical_duration
    }
    /// Appends an item to `zones`.
    ///
    /// To override the contents of this collection use [`set_zones`](Self::set_zones).
    ///
    /// <p>Zones corresponding to this leg of the route.</p>
    pub fn zones(mut self, input: i32) -> Self {
        let mut v = self.zones.unwrap_or_default();
        v.push(input);
        self.zones = ::std::option::Option::Some(v);
        self
    }
    /// <p>Zones corresponding to this leg of the route.</p>
    pub fn set_zones(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.zones = input;
        self
    }
    /// <p>Zones corresponding to this leg of the route.</p>
    pub fn get_zones(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.zones
    }
    /// Consumes the builder and constructs a [`RouteVehicleSpan`](crate::types::RouteVehicleSpan).
    pub fn build(self) -> crate::types::RouteVehicleSpan {
        crate::types::RouteVehicleSpan {
            best_case_duration: self.best_case_duration.unwrap_or_default(),
            car_access: self.car_access,
            country: self.country,
            distance: self.distance.unwrap_or_default(),
            duration: self.duration.unwrap_or_default(),
            dynamic_speed: self.dynamic_speed,
            functional_classification: self.functional_classification,
            gate: self.gate,
            geometry_offset: self.geometry_offset,
            incidents: self.incidents,
            names: self.names,
            notices: self.notices,
            railway_crossing: self.railway_crossing,
            region: self.region,
            road_attributes: self.road_attributes,
            route_numbers: self.route_numbers,
            scooter_access: self.scooter_access,
            speed_limit: self.speed_limit,
            toll_systems: self.toll_systems,
            truck_access: self.truck_access,
            truck_road_types: self.truck_road_types,
            typical_duration: self.typical_duration.unwrap_or_default(),
            zones: self.zones,
        }
    }
}
