// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CalculateRouteMatrixOutput {
    /// <p>The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.</p>
    pub error_count: i32,
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub pricing_bucket: ::std::string::String,
    /// <p>The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.</p>
    pub route_matrix: ::std::vec::Vec<::std::vec::Vec<crate::types::RouteMatrixEntry>>,
    /// <p>Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.</p><note>
    /// <p>When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.</p>
    /// </note>
    pub routing_boundary: ::std::option::Option<crate::types::RouteMatrixBoundary>,
    _request_id: Option<String>,
}
impl CalculateRouteMatrixOutput {
    /// <p>The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.</p>
    pub fn error_count(&self) -> i32 {
        self.error_count
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub fn pricing_bucket(&self) -> &str {
        use std::ops::Deref;
        self.pricing_bucket.deref()
    }
    /// <p>The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.</p>
    pub fn route_matrix(&self) -> &[::std::vec::Vec<crate::types::RouteMatrixEntry>] {
        use std::ops::Deref;
        self.route_matrix.deref()
    }
    /// <p>Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.</p><note>
    /// <p>When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.</p>
    /// </note>
    pub fn routing_boundary(&self) -> ::std::option::Option<&crate::types::RouteMatrixBoundary> {
        self.routing_boundary.as_ref()
    }
}
impl ::aws_types::request_id::RequestId for CalculateRouteMatrixOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl CalculateRouteMatrixOutput {
    /// Creates a new builder-style object to manufacture [`CalculateRouteMatrixOutput`](crate::operation::calculate_route_matrix::CalculateRouteMatrixOutput).
    pub fn builder() -> crate::operation::calculate_route_matrix::builders::CalculateRouteMatrixOutputBuilder {
        crate::operation::calculate_route_matrix::builders::CalculateRouteMatrixOutputBuilder::default()
    }
}

/// A builder for [`CalculateRouteMatrixOutput`](crate::operation::calculate_route_matrix::CalculateRouteMatrixOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CalculateRouteMatrixOutputBuilder {
    pub(crate) error_count: ::std::option::Option<i32>,
    pub(crate) pricing_bucket: ::std::option::Option<::std::string::String>,
    pub(crate) route_matrix: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<crate::types::RouteMatrixEntry>>>,
    pub(crate) routing_boundary: ::std::option::Option<crate::types::RouteMatrixBoundary>,
    _request_id: Option<String>,
}
impl CalculateRouteMatrixOutputBuilder {
    /// <p>The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.</p>
    /// This field is required.
    pub fn error_count(mut self, input: i32) -> Self {
        self.error_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.</p>
    pub fn set_error_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.error_count = input;
        self
    }
    /// <p>The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.</p>
    pub fn get_error_count(&self) -> &::std::option::Option<i32> {
        &self.error_count
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    /// This field is required.
    pub fn pricing_bucket(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pricing_bucket = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub fn set_pricing_bucket(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pricing_bucket = input;
        self
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub fn get_pricing_bucket(&self) -> &::std::option::Option<::std::string::String> {
        &self.pricing_bucket
    }
    /// Appends an item to `route_matrix`.
    ///
    /// To override the contents of this collection use [`set_route_matrix`](Self::set_route_matrix).
    ///
    /// <p>The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.</p>
    pub fn route_matrix(mut self, input: ::std::vec::Vec<crate::types::RouteMatrixEntry>) -> Self {
        let mut v = self.route_matrix.unwrap_or_default();
        v.push(input);
        self.route_matrix = ::std::option::Option::Some(v);
        self
    }
    /// <p>The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.</p>
    pub fn set_route_matrix(mut self, input: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<crate::types::RouteMatrixEntry>>>) -> Self {
        self.route_matrix = input;
        self
    }
    /// <p>The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.</p>
    pub fn get_route_matrix(&self) -> &::std::option::Option<::std::vec::Vec<::std::vec::Vec<crate::types::RouteMatrixEntry>>> {
        &self.route_matrix
    }
    /// <p>Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.</p><note>
    /// <p>When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.</p>
    /// </note>
    /// This field is required.
    pub fn routing_boundary(mut self, input: crate::types::RouteMatrixBoundary) -> Self {
        self.routing_boundary = ::std::option::Option::Some(input);
        self
    }
    /// <p>Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.</p><note>
    /// <p>When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.</p>
    /// </note>
    pub fn set_routing_boundary(mut self, input: ::std::option::Option<crate::types::RouteMatrixBoundary>) -> Self {
        self.routing_boundary = input;
        self
    }
    /// <p>Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.</p><note>
    /// <p>When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.</p>
    /// </note>
    pub fn get_routing_boundary(&self) -> &::std::option::Option<crate::types::RouteMatrixBoundary> {
        &self.routing_boundary
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`CalculateRouteMatrixOutput`](crate::operation::calculate_route_matrix::CalculateRouteMatrixOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`error_count`](crate::operation::calculate_route_matrix::builders::CalculateRouteMatrixOutputBuilder::error_count)
    /// - [`pricing_bucket`](crate::operation::calculate_route_matrix::builders::CalculateRouteMatrixOutputBuilder::pricing_bucket)
    /// - [`route_matrix`](crate::operation::calculate_route_matrix::builders::CalculateRouteMatrixOutputBuilder::route_matrix)
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::calculate_route_matrix::CalculateRouteMatrixOutput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::calculate_route_matrix::CalculateRouteMatrixOutput {
            error_count: self.error_count.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "error_count",
                    "error_count was not specified but it is required when building CalculateRouteMatrixOutput",
                )
            })?,
            pricing_bucket: self.pricing_bucket.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "pricing_bucket",
                    "pricing_bucket was not specified but it is required when building CalculateRouteMatrixOutput",
                )
            })?,
            route_matrix: self.route_matrix.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "route_matrix",
                    "route_matrix was not specified but it is required when building CalculateRouteMatrixOutput",
                )
            })?,
            routing_boundary: self.routing_boundary,
            _request_id: self._request_id,
        })
    }
}
