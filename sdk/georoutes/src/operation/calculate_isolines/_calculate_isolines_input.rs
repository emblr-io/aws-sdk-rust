// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CalculateIsolinesInput {
    /// <p>Features that are allowed while calculating an isoline.</p>
    pub allow: ::std::option::Option<crate::types::IsolineAllowOptions>,
    /// <p>Time of arrival at the destination.</p>
    /// <p>Time format: <code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub arrival_time: ::std::option::Option<::std::string::String>,
    /// <p>Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.</p>
    pub avoid: ::std::option::Option<crate::types::IsolineAvoidanceOptions>,
    /// <p>Uses the current time as the time of departure.</p>
    pub depart_now: ::std::option::Option<bool>,
    /// <p>Time of departure from thr origin.</p>
    /// <p>Time format:<code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub departure_time: ::std::option::Option<::std::string::String>,
    /// <p>The final position for the route. In the World Geodetic System (WGS 84) format: <code>\[longitude, latitude\]</code>.</p>
    pub destination: ::std::option::Option<::std::vec::Vec<f64>>,
    /// <p>Destination related options.</p>
    pub destination_options: ::std::option::Option<crate::types::IsolineDestinationOptions>,
    /// <p>The format of the returned IsolineGeometry.</p>
    /// <p>Default Value:<code>FlexiblePolyline</code></p>
    pub isoline_geometry_format: ::std::option::Option<crate::types::GeometryFormat>,
    /// <p>Defines the granularity of the returned Isoline.</p>
    pub isoline_granularity: ::std::option::Option<crate::types::IsolineGranularityOptions>,
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub key: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance.</p>
    /// <p>Default Value: <code>BalancedCalculation</code></p>
    pub optimize_isoline_for: ::std::option::Option<crate::types::IsolineOptimizationObjective>,
    /// <p>Specifies the optimization criteria for calculating a route.</p>
    /// <p>Default Value: <code>FastestRoute</code></p>
    pub optimize_routing_for: ::std::option::Option<crate::types::RoutingObjective>,
    /// <p>The start position for the route.</p>
    pub origin: ::std::option::Option<::std::vec::Vec<f64>>,
    /// <p>Origin related options.</p>
    pub origin_options: ::std::option::Option<crate::types::IsolineOriginOptions>,
    /// <p>Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.</p>
    /// <p>You incur a calculation charge for each threshold. Using a large amount of thresholds in a request can lead you to incur unexpected charges. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/routes-pricing.html`"> Amazon Location's pricing page</a> for more information.</p>
    pub thresholds: ::std::option::Option<crate::types::IsolineThresholds>,
    /// <p>Traffic related options.</p>
    pub traffic: ::std::option::Option<crate::types::IsolineTrafficOptions>,
    /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.</p><note>
    /// <p>The mode <code>Scooter</code> also applies to motorcycles, set to <code>Scooter</code> when wanted to calculate options for motorcycles.</p>
    /// </note>
    /// <p>Default Value: <code>Car</code></p>
    pub travel_mode: ::std::option::Option<crate::types::IsolineTravelMode>,
    /// <p>Travel mode related options for the provided travel mode.</p>
    pub travel_mode_options: ::std::option::Option<crate::types::IsolineTravelModeOptions>,
}
impl CalculateIsolinesInput {
    /// <p>Features that are allowed while calculating an isoline.</p>
    pub fn allow(&self) -> ::std::option::Option<&crate::types::IsolineAllowOptions> {
        self.allow.as_ref()
    }
    /// <p>Time of arrival at the destination.</p>
    /// <p>Time format: <code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn arrival_time(&self) -> ::std::option::Option<&str> {
        self.arrival_time.as_deref()
    }
    /// <p>Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.</p>
    pub fn avoid(&self) -> ::std::option::Option<&crate::types::IsolineAvoidanceOptions> {
        self.avoid.as_ref()
    }
    /// <p>Uses the current time as the time of departure.</p>
    pub fn depart_now(&self) -> ::std::option::Option<bool> {
        self.depart_now
    }
    /// <p>Time of departure from thr origin.</p>
    /// <p>Time format:<code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn departure_time(&self) -> ::std::option::Option<&str> {
        self.departure_time.as_deref()
    }
    /// <p>The final position for the route. In the World Geodetic System (WGS 84) format: <code>\[longitude, latitude\]</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.destination.is_none()`.
    pub fn destination(&self) -> &[f64] {
        self.destination.as_deref().unwrap_or_default()
    }
    /// <p>Destination related options.</p>
    pub fn destination_options(&self) -> ::std::option::Option<&crate::types::IsolineDestinationOptions> {
        self.destination_options.as_ref()
    }
    /// <p>The format of the returned IsolineGeometry.</p>
    /// <p>Default Value:<code>FlexiblePolyline</code></p>
    pub fn isoline_geometry_format(&self) -> ::std::option::Option<&crate::types::GeometryFormat> {
        self.isoline_geometry_format.as_ref()
    }
    /// <p>Defines the granularity of the returned Isoline.</p>
    pub fn isoline_granularity(&self) -> ::std::option::Option<&crate::types::IsolineGranularityOptions> {
        self.isoline_granularity.as_ref()
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn key(&self) -> ::std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance.</p>
    /// <p>Default Value: <code>BalancedCalculation</code></p>
    pub fn optimize_isoline_for(&self) -> ::std::option::Option<&crate::types::IsolineOptimizationObjective> {
        self.optimize_isoline_for.as_ref()
    }
    /// <p>Specifies the optimization criteria for calculating a route.</p>
    /// <p>Default Value: <code>FastestRoute</code></p>
    pub fn optimize_routing_for(&self) -> ::std::option::Option<&crate::types::RoutingObjective> {
        self.optimize_routing_for.as_ref()
    }
    /// <p>The start position for the route.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.origin.is_none()`.
    pub fn origin(&self) -> &[f64] {
        self.origin.as_deref().unwrap_or_default()
    }
    /// <p>Origin related options.</p>
    pub fn origin_options(&self) -> ::std::option::Option<&crate::types::IsolineOriginOptions> {
        self.origin_options.as_ref()
    }
    /// <p>Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.</p>
    /// <p>You incur a calculation charge for each threshold. Using a large amount of thresholds in a request can lead you to incur unexpected charges. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/routes-pricing.html`"> Amazon Location's pricing page</a> for more information.</p>
    pub fn thresholds(&self) -> ::std::option::Option<&crate::types::IsolineThresholds> {
        self.thresholds.as_ref()
    }
    /// <p>Traffic related options.</p>
    pub fn traffic(&self) -> ::std::option::Option<&crate::types::IsolineTrafficOptions> {
        self.traffic.as_ref()
    }
    /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.</p><note>
    /// <p>The mode <code>Scooter</code> also applies to motorcycles, set to <code>Scooter</code> when wanted to calculate options for motorcycles.</p>
    /// </note>
    /// <p>Default Value: <code>Car</code></p>
    pub fn travel_mode(&self) -> ::std::option::Option<&crate::types::IsolineTravelMode> {
        self.travel_mode.as_ref()
    }
    /// <p>Travel mode related options for the provided travel mode.</p>
    pub fn travel_mode_options(&self) -> ::std::option::Option<&crate::types::IsolineTravelModeOptions> {
        self.travel_mode_options.as_ref()
    }
}
impl ::std::fmt::Debug for CalculateIsolinesInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CalculateIsolinesInput");
        formatter.field("allow", &self.allow);
        formatter.field("arrival_time", &self.arrival_time);
        formatter.field("avoid", &self.avoid);
        formatter.field("depart_now", &self.depart_now);
        formatter.field("departure_time", &self.departure_time);
        formatter.field("destination", &"*** Sensitive Data Redacted ***");
        formatter.field("destination_options", &self.destination_options);
        formatter.field("isoline_geometry_format", &self.isoline_geometry_format);
        formatter.field("isoline_granularity", &self.isoline_granularity);
        formatter.field("key", &"*** Sensitive Data Redacted ***");
        formatter.field("optimize_isoline_for", &self.optimize_isoline_for);
        formatter.field("optimize_routing_for", &self.optimize_routing_for);
        formatter.field("origin", &"*** Sensitive Data Redacted ***");
        formatter.field("origin_options", &self.origin_options);
        formatter.field("thresholds", &self.thresholds);
        formatter.field("traffic", &self.traffic);
        formatter.field("travel_mode", &self.travel_mode);
        formatter.field("travel_mode_options", &self.travel_mode_options);
        formatter.finish()
    }
}
impl CalculateIsolinesInput {
    /// Creates a new builder-style object to manufacture [`CalculateIsolinesInput`](crate::operation::calculate_isolines::CalculateIsolinesInput).
    pub fn builder() -> crate::operation::calculate_isolines::builders::CalculateIsolinesInputBuilder {
        crate::operation::calculate_isolines::builders::CalculateIsolinesInputBuilder::default()
    }
}

/// A builder for [`CalculateIsolinesInput`](crate::operation::calculate_isolines::CalculateIsolinesInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct CalculateIsolinesInputBuilder {
    pub(crate) allow: ::std::option::Option<crate::types::IsolineAllowOptions>,
    pub(crate) arrival_time: ::std::option::Option<::std::string::String>,
    pub(crate) avoid: ::std::option::Option<crate::types::IsolineAvoidanceOptions>,
    pub(crate) depart_now: ::std::option::Option<bool>,
    pub(crate) departure_time: ::std::option::Option<::std::string::String>,
    pub(crate) destination: ::std::option::Option<::std::vec::Vec<f64>>,
    pub(crate) destination_options: ::std::option::Option<crate::types::IsolineDestinationOptions>,
    pub(crate) isoline_geometry_format: ::std::option::Option<crate::types::GeometryFormat>,
    pub(crate) isoline_granularity: ::std::option::Option<crate::types::IsolineGranularityOptions>,
    pub(crate) key: ::std::option::Option<::std::string::String>,
    pub(crate) optimize_isoline_for: ::std::option::Option<crate::types::IsolineOptimizationObjective>,
    pub(crate) optimize_routing_for: ::std::option::Option<crate::types::RoutingObjective>,
    pub(crate) origin: ::std::option::Option<::std::vec::Vec<f64>>,
    pub(crate) origin_options: ::std::option::Option<crate::types::IsolineOriginOptions>,
    pub(crate) thresholds: ::std::option::Option<crate::types::IsolineThresholds>,
    pub(crate) traffic: ::std::option::Option<crate::types::IsolineTrafficOptions>,
    pub(crate) travel_mode: ::std::option::Option<crate::types::IsolineTravelMode>,
    pub(crate) travel_mode_options: ::std::option::Option<crate::types::IsolineTravelModeOptions>,
}
impl CalculateIsolinesInputBuilder {
    /// <p>Features that are allowed while calculating an isoline.</p>
    pub fn allow(mut self, input: crate::types::IsolineAllowOptions) -> Self {
        self.allow = ::std::option::Option::Some(input);
        self
    }
    /// <p>Features that are allowed while calculating an isoline.</p>
    pub fn set_allow(mut self, input: ::std::option::Option<crate::types::IsolineAllowOptions>) -> Self {
        self.allow = input;
        self
    }
    /// <p>Features that are allowed while calculating an isoline.</p>
    pub fn get_allow(&self) -> &::std::option::Option<crate::types::IsolineAllowOptions> {
        &self.allow
    }
    /// <p>Time of arrival at the destination.</p>
    /// <p>Time format: <code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn arrival_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arrival_time = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Time of arrival at the destination.</p>
    /// <p>Time format: <code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn set_arrival_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arrival_time = input;
        self
    }
    /// <p>Time of arrival at the destination.</p>
    /// <p>Time format: <code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn get_arrival_time(&self) -> &::std::option::Option<::std::string::String> {
        &self.arrival_time
    }
    /// <p>Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.</p>
    pub fn avoid(mut self, input: crate::types::IsolineAvoidanceOptions) -> Self {
        self.avoid = ::std::option::Option::Some(input);
        self
    }
    /// <p>Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.</p>
    pub fn set_avoid(mut self, input: ::std::option::Option<crate::types::IsolineAvoidanceOptions>) -> Self {
        self.avoid = input;
        self
    }
    /// <p>Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.</p>
    pub fn get_avoid(&self) -> &::std::option::Option<crate::types::IsolineAvoidanceOptions> {
        &self.avoid
    }
    /// <p>Uses the current time as the time of departure.</p>
    pub fn depart_now(mut self, input: bool) -> Self {
        self.depart_now = ::std::option::Option::Some(input);
        self
    }
    /// <p>Uses the current time as the time of departure.</p>
    pub fn set_depart_now(mut self, input: ::std::option::Option<bool>) -> Self {
        self.depart_now = input;
        self
    }
    /// <p>Uses the current time as the time of departure.</p>
    pub fn get_depart_now(&self) -> &::std::option::Option<bool> {
        &self.depart_now
    }
    /// <p>Time of departure from thr origin.</p>
    /// <p>Time format:<code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn departure_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.departure_time = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Time of departure from thr origin.</p>
    /// <p>Time format:<code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn set_departure_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.departure_time = input;
        self
    }
    /// <p>Time of departure from thr origin.</p>
    /// <p>Time format:<code>YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm</code></p>
    /// <p>Examples:</p>
    /// <p><code>2020-04-22T17:57:24Z</code></p>
    /// <p><code>2020-04-22T17:57:24+02:00</code></p>
    pub fn get_departure_time(&self) -> &::std::option::Option<::std::string::String> {
        &self.departure_time
    }
    /// Appends an item to `destination`.
    ///
    /// To override the contents of this collection use [`set_destination`](Self::set_destination).
    ///
    /// <p>The final position for the route. In the World Geodetic System (WGS 84) format: <code>\[longitude, latitude\]</code>.</p>
    pub fn destination(mut self, input: f64) -> Self {
        let mut v = self.destination.unwrap_or_default();
        v.push(input);
        self.destination = ::std::option::Option::Some(v);
        self
    }
    /// <p>The final position for the route. In the World Geodetic System (WGS 84) format: <code>\[longitude, latitude\]</code>.</p>
    pub fn set_destination(mut self, input: ::std::option::Option<::std::vec::Vec<f64>>) -> Self {
        self.destination = input;
        self
    }
    /// <p>The final position for the route. In the World Geodetic System (WGS 84) format: <code>\[longitude, latitude\]</code>.</p>
    pub fn get_destination(&self) -> &::std::option::Option<::std::vec::Vec<f64>> {
        &self.destination
    }
    /// <p>Destination related options.</p>
    pub fn destination_options(mut self, input: crate::types::IsolineDestinationOptions) -> Self {
        self.destination_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Destination related options.</p>
    pub fn set_destination_options(mut self, input: ::std::option::Option<crate::types::IsolineDestinationOptions>) -> Self {
        self.destination_options = input;
        self
    }
    /// <p>Destination related options.</p>
    pub fn get_destination_options(&self) -> &::std::option::Option<crate::types::IsolineDestinationOptions> {
        &self.destination_options
    }
    /// <p>The format of the returned IsolineGeometry.</p>
    /// <p>Default Value:<code>FlexiblePolyline</code></p>
    pub fn isoline_geometry_format(mut self, input: crate::types::GeometryFormat) -> Self {
        self.isoline_geometry_format = ::std::option::Option::Some(input);
        self
    }
    /// <p>The format of the returned IsolineGeometry.</p>
    /// <p>Default Value:<code>FlexiblePolyline</code></p>
    pub fn set_isoline_geometry_format(mut self, input: ::std::option::Option<crate::types::GeometryFormat>) -> Self {
        self.isoline_geometry_format = input;
        self
    }
    /// <p>The format of the returned IsolineGeometry.</p>
    /// <p>Default Value:<code>FlexiblePolyline</code></p>
    pub fn get_isoline_geometry_format(&self) -> &::std::option::Option<crate::types::GeometryFormat> {
        &self.isoline_geometry_format
    }
    /// <p>Defines the granularity of the returned Isoline.</p>
    pub fn isoline_granularity(mut self, input: crate::types::IsolineGranularityOptions) -> Self {
        self.isoline_granularity = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the granularity of the returned Isoline.</p>
    pub fn set_isoline_granularity(mut self, input: ::std::option::Option<crate::types::IsolineGranularityOptions>) -> Self {
        self.isoline_granularity = input;
        self
    }
    /// <p>Defines the granularity of the returned Isoline.</p>
    pub fn get_isoline_granularity(&self) -> &::std::option::Option<crate::types::IsolineGranularityOptions> {
        &self.isoline_granularity
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn set_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.key = input;
        self
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn get_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.key
    }
    /// <p>Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance.</p>
    /// <p>Default Value: <code>BalancedCalculation</code></p>
    pub fn optimize_isoline_for(mut self, input: crate::types::IsolineOptimizationObjective) -> Self {
        self.optimize_isoline_for = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance.</p>
    /// <p>Default Value: <code>BalancedCalculation</code></p>
    pub fn set_optimize_isoline_for(mut self, input: ::std::option::Option<crate::types::IsolineOptimizationObjective>) -> Self {
        self.optimize_isoline_for = input;
        self
    }
    /// <p>Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance.</p>
    /// <p>Default Value: <code>BalancedCalculation</code></p>
    pub fn get_optimize_isoline_for(&self) -> &::std::option::Option<crate::types::IsolineOptimizationObjective> {
        &self.optimize_isoline_for
    }
    /// <p>Specifies the optimization criteria for calculating a route.</p>
    /// <p>Default Value: <code>FastestRoute</code></p>
    pub fn optimize_routing_for(mut self, input: crate::types::RoutingObjective) -> Self {
        self.optimize_routing_for = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the optimization criteria for calculating a route.</p>
    /// <p>Default Value: <code>FastestRoute</code></p>
    pub fn set_optimize_routing_for(mut self, input: ::std::option::Option<crate::types::RoutingObjective>) -> Self {
        self.optimize_routing_for = input;
        self
    }
    /// <p>Specifies the optimization criteria for calculating a route.</p>
    /// <p>Default Value: <code>FastestRoute</code></p>
    pub fn get_optimize_routing_for(&self) -> &::std::option::Option<crate::types::RoutingObjective> {
        &self.optimize_routing_for
    }
    /// Appends an item to `origin`.
    ///
    /// To override the contents of this collection use [`set_origin`](Self::set_origin).
    ///
    /// <p>The start position for the route.</p>
    pub fn origin(mut self, input: f64) -> Self {
        let mut v = self.origin.unwrap_or_default();
        v.push(input);
        self.origin = ::std::option::Option::Some(v);
        self
    }
    /// <p>The start position for the route.</p>
    pub fn set_origin(mut self, input: ::std::option::Option<::std::vec::Vec<f64>>) -> Self {
        self.origin = input;
        self
    }
    /// <p>The start position for the route.</p>
    pub fn get_origin(&self) -> &::std::option::Option<::std::vec::Vec<f64>> {
        &self.origin
    }
    /// <p>Origin related options.</p>
    pub fn origin_options(mut self, input: crate::types::IsolineOriginOptions) -> Self {
        self.origin_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Origin related options.</p>
    pub fn set_origin_options(mut self, input: ::std::option::Option<crate::types::IsolineOriginOptions>) -> Self {
        self.origin_options = input;
        self
    }
    /// <p>Origin related options.</p>
    pub fn get_origin_options(&self) -> &::std::option::Option<crate::types::IsolineOriginOptions> {
        &self.origin_options
    }
    /// <p>Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.</p>
    /// <p>You incur a calculation charge for each threshold. Using a large amount of thresholds in a request can lead you to incur unexpected charges. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/routes-pricing.html`"> Amazon Location's pricing page</a> for more information.</p>
    /// This field is required.
    pub fn thresholds(mut self, input: crate::types::IsolineThresholds) -> Self {
        self.thresholds = ::std::option::Option::Some(input);
        self
    }
    /// <p>Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.</p>
    /// <p>You incur a calculation charge for each threshold. Using a large amount of thresholds in a request can lead you to incur unexpected charges. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/routes-pricing.html`"> Amazon Location's pricing page</a> for more information.</p>
    pub fn set_thresholds(mut self, input: ::std::option::Option<crate::types::IsolineThresholds>) -> Self {
        self.thresholds = input;
        self
    }
    /// <p>Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.</p>
    /// <p>You incur a calculation charge for each threshold. Using a large amount of thresholds in a request can lead you to incur unexpected charges. See <a href="https://docs.aws.amazon.com/location/latest/developerguide/routes-pricing.html`"> Amazon Location's pricing page</a> for more information.</p>
    pub fn get_thresholds(&self) -> &::std::option::Option<crate::types::IsolineThresholds> {
        &self.thresholds
    }
    /// <p>Traffic related options.</p>
    pub fn traffic(mut self, input: crate::types::IsolineTrafficOptions) -> Self {
        self.traffic = ::std::option::Option::Some(input);
        self
    }
    /// <p>Traffic related options.</p>
    pub fn set_traffic(mut self, input: ::std::option::Option<crate::types::IsolineTrafficOptions>) -> Self {
        self.traffic = input;
        self
    }
    /// <p>Traffic related options.</p>
    pub fn get_traffic(&self) -> &::std::option::Option<crate::types::IsolineTrafficOptions> {
        &self.traffic
    }
    /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.</p><note>
    /// <p>The mode <code>Scooter</code> also applies to motorcycles, set to <code>Scooter</code> when wanted to calculate options for motorcycles.</p>
    /// </note>
    /// <p>Default Value: <code>Car</code></p>
    pub fn travel_mode(mut self, input: crate::types::IsolineTravelMode) -> Self {
        self.travel_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.</p><note>
    /// <p>The mode <code>Scooter</code> also applies to motorcycles, set to <code>Scooter</code> when wanted to calculate options for motorcycles.</p>
    /// </note>
    /// <p>Default Value: <code>Car</code></p>
    pub fn set_travel_mode(mut self, input: ::std::option::Option<crate::types::IsolineTravelMode>) -> Self {
        self.travel_mode = input;
        self
    }
    /// <p>Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility.</p><note>
    /// <p>The mode <code>Scooter</code> also applies to motorcycles, set to <code>Scooter</code> when wanted to calculate options for motorcycles.</p>
    /// </note>
    /// <p>Default Value: <code>Car</code></p>
    pub fn get_travel_mode(&self) -> &::std::option::Option<crate::types::IsolineTravelMode> {
        &self.travel_mode
    }
    /// <p>Travel mode related options for the provided travel mode.</p>
    pub fn travel_mode_options(mut self, input: crate::types::IsolineTravelModeOptions) -> Self {
        self.travel_mode_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Travel mode related options for the provided travel mode.</p>
    pub fn set_travel_mode_options(mut self, input: ::std::option::Option<crate::types::IsolineTravelModeOptions>) -> Self {
        self.travel_mode_options = input;
        self
    }
    /// <p>Travel mode related options for the provided travel mode.</p>
    pub fn get_travel_mode_options(&self) -> &::std::option::Option<crate::types::IsolineTravelModeOptions> {
        &self.travel_mode_options
    }
    /// Consumes the builder and constructs a [`CalculateIsolinesInput`](crate::operation::calculate_isolines::CalculateIsolinesInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::calculate_isolines::CalculateIsolinesInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::calculate_isolines::CalculateIsolinesInput {
            allow: self.allow,
            arrival_time: self.arrival_time,
            avoid: self.avoid,
            depart_now: self.depart_now,
            departure_time: self.departure_time,
            destination: self.destination,
            destination_options: self.destination_options,
            isoline_geometry_format: self.isoline_geometry_format,
            isoline_granularity: self.isoline_granularity,
            key: self.key,
            optimize_isoline_for: self.optimize_isoline_for,
            optimize_routing_for: self.optimize_routing_for,
            origin: self.origin,
            origin_options: self.origin_options,
            thresholds: self.thresholds,
            traffic: self.traffic,
            travel_mode: self.travel_mode,
            travel_mode_options: self.travel_mode_options,
        })
    }
}
impl ::std::fmt::Debug for CalculateIsolinesInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CalculateIsolinesInputBuilder");
        formatter.field("allow", &self.allow);
        formatter.field("arrival_time", &self.arrival_time);
        formatter.field("avoid", &self.avoid);
        formatter.field("depart_now", &self.depart_now);
        formatter.field("departure_time", &self.departure_time);
        formatter.field("destination", &"*** Sensitive Data Redacted ***");
        formatter.field("destination_options", &self.destination_options);
        formatter.field("isoline_geometry_format", &self.isoline_geometry_format);
        formatter.field("isoline_granularity", &self.isoline_granularity);
        formatter.field("key", &"*** Sensitive Data Redacted ***");
        formatter.field("optimize_isoline_for", &self.optimize_isoline_for);
        formatter.field("optimize_routing_for", &self.optimize_routing_for);
        formatter.field("origin", &"*** Sensitive Data Redacted ***");
        formatter.field("origin_options", &self.origin_options);
        formatter.field("thresholds", &self.thresholds);
        formatter.field("traffic", &self.traffic);
        formatter.field("travel_mode", &self.travel_mode);
        formatter.field("travel_mode_options", &self.travel_mode_options);
        formatter.finish()
    }
}
