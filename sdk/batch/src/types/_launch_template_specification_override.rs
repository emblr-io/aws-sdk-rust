// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object that represents a launch template to use in place of the default launch template. You must specify either the launch template ID or launch template name in the request, but not both.</p>
/// <p>If security groups are specified using both the <code>securityGroupIds</code> parameter of <code>CreateComputeEnvironment</code> and the launch template, the values in the <code>securityGroupIds</code> parameter of <code>CreateComputeEnvironment</code> will be used.</p>
/// <p>You can define up to ten (10) overrides for each compute environment.</p><note>
/// <p>This object isn't applicable to jobs that are running on Fargate resources.</p>
/// </note> <note>
/// <p>To unset all override templates for a compute environment, you can pass an empty array to the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_UpdateComputeEnvironment.html">UpdateComputeEnvironment.overrides</a> parameter, or not include the <code>overrides</code> parameter when submitting the <code>UpdateComputeEnvironment</code> API operation.</p>
/// </note>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct LaunchTemplateSpecificationOverride {
    /// <p>The ID of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateId</code> you can't specify the <code>launchTemplateName</code> as well.</p>
    pub launch_template_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateName</code> you can't specify the <code>launchTemplateId</code> as well.</p>
    pub launch_template_name: ::std::option::Option<::std::string::String>,
    /// <p>The version number of the launch template, <code>$Default</code>, or <code>$Latest</code>.</p>
    /// <p>If the value is <code>$Default</code>, the default version of the launch template is used. If the value is <code>$Latest</code>, the latest version of the launch template is used.</p><important>
    /// <p>If the AMI ID that's used in a compute environment is from the launch template, the AMI isn't changed when the compute environment is updated. It's only changed if the <code>updateToLatestImageVersion</code> parameter for the compute environment is set to <code>true</code>. During an infrastructure update, if either <code>$Default</code> or <code>$Latest</code> is specified, Batch re-evaluates the launch template version, and it might use a different version of the launch template. This is the case even if the launch template isn't specified in the update. When updating a compute environment, changing the launch template requires an infrastructure update of the compute environment. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/updating-compute-environments.html">Updating compute environments</a> in the <i>Batch User Guide</i>.</p>
    /// </important>
    /// <p>Default: <code>$Default</code></p>
    /// <p>Latest: <code>$Latest</code></p>
    pub version: ::std::option::Option<::std::string::String>,
    /// <p>The instance type or family that this override launch template should be applied to.</p>
    /// <p>This parameter is required when defining a launch template override.</p>
    /// <p>Information included in this parameter must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Must be a valid Amazon EC2 instance type or family.</p></li>
    /// <li>
    /// <p><code>optimal</code> isn't allowed.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> can target only instance types and families that are included within the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-instanceTypes"> <code>ComputeResource.instanceTypes</code> </a> set. <code>targetInstanceTypes</code> doesn't need to include all of the instances from the <code>instanceType</code> set, but at least a subset. For example, if <code>ComputeResource.instanceTypes</code> includes <code>\[m5, g5\]</code>, <code>targetInstanceTypes</code> can include <code>\[m5.2xlarge\]</code> and <code>\[m5.large\]</code> but not <code>\[c5.large\]</code>.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> included within the same launch template override or across launch template overrides can't overlap for the same compute environment. For example, you can't define one launch template override to target an instance family and another define an instance type within this same family.</p></li>
    /// </ul>
    pub target_instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The EKS node initialization process to use. You only need to specify this value if you are using a custom AMI. The default value is <code>EKS_BOOTSTRAP_SH</code>. If <i>imageType</i> is a custom AMI based on EKS_AL2023 or EKS_AL2023_NVIDIA then you must choose <code>EKS_NODEADM</code>.</p>
    pub userdata_type: ::std::option::Option<crate::types::UserdataType>,
}
impl LaunchTemplateSpecificationOverride {
    /// <p>The ID of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateId</code> you can't specify the <code>launchTemplateName</code> as well.</p>
    pub fn launch_template_id(&self) -> ::std::option::Option<&str> {
        self.launch_template_id.as_deref()
    }
    /// <p>The name of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateName</code> you can't specify the <code>launchTemplateId</code> as well.</p>
    pub fn launch_template_name(&self) -> ::std::option::Option<&str> {
        self.launch_template_name.as_deref()
    }
    /// <p>The version number of the launch template, <code>$Default</code>, or <code>$Latest</code>.</p>
    /// <p>If the value is <code>$Default</code>, the default version of the launch template is used. If the value is <code>$Latest</code>, the latest version of the launch template is used.</p><important>
    /// <p>If the AMI ID that's used in a compute environment is from the launch template, the AMI isn't changed when the compute environment is updated. It's only changed if the <code>updateToLatestImageVersion</code> parameter for the compute environment is set to <code>true</code>. During an infrastructure update, if either <code>$Default</code> or <code>$Latest</code> is specified, Batch re-evaluates the launch template version, and it might use a different version of the launch template. This is the case even if the launch template isn't specified in the update. When updating a compute environment, changing the launch template requires an infrastructure update of the compute environment. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/updating-compute-environments.html">Updating compute environments</a> in the <i>Batch User Guide</i>.</p>
    /// </important>
    /// <p>Default: <code>$Default</code></p>
    /// <p>Latest: <code>$Latest</code></p>
    pub fn version(&self) -> ::std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The instance type or family that this override launch template should be applied to.</p>
    /// <p>This parameter is required when defining a launch template override.</p>
    /// <p>Information included in this parameter must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Must be a valid Amazon EC2 instance type or family.</p></li>
    /// <li>
    /// <p><code>optimal</code> isn't allowed.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> can target only instance types and families that are included within the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-instanceTypes"> <code>ComputeResource.instanceTypes</code> </a> set. <code>targetInstanceTypes</code> doesn't need to include all of the instances from the <code>instanceType</code> set, but at least a subset. For example, if <code>ComputeResource.instanceTypes</code> includes <code>\[m5, g5\]</code>, <code>targetInstanceTypes</code> can include <code>\[m5.2xlarge\]</code> and <code>\[m5.large\]</code> but not <code>\[c5.large\]</code>.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> included within the same launch template override or across launch template overrides can't overlap for the same compute environment. For example, you can't define one launch template override to target an instance family and another define an instance type within this same family.</p></li>
    /// </ul>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.target_instance_types.is_none()`.
    pub fn target_instance_types(&self) -> &[::std::string::String] {
        self.target_instance_types.as_deref().unwrap_or_default()
    }
    /// <p>The EKS node initialization process to use. You only need to specify this value if you are using a custom AMI. The default value is <code>EKS_BOOTSTRAP_SH</code>. If <i>imageType</i> is a custom AMI based on EKS_AL2023 or EKS_AL2023_NVIDIA then you must choose <code>EKS_NODEADM</code>.</p>
    pub fn userdata_type(&self) -> ::std::option::Option<&crate::types::UserdataType> {
        self.userdata_type.as_ref()
    }
}
impl LaunchTemplateSpecificationOverride {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateSpecificationOverride`](crate::types::LaunchTemplateSpecificationOverride).
    pub fn builder() -> crate::types::builders::LaunchTemplateSpecificationOverrideBuilder {
        crate::types::builders::LaunchTemplateSpecificationOverrideBuilder::default()
    }
}

/// A builder for [`LaunchTemplateSpecificationOverride`](crate::types::LaunchTemplateSpecificationOverride).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct LaunchTemplateSpecificationOverrideBuilder {
    pub(crate) launch_template_id: ::std::option::Option<::std::string::String>,
    pub(crate) launch_template_name: ::std::option::Option<::std::string::String>,
    pub(crate) version: ::std::option::Option<::std::string::String>,
    pub(crate) target_instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) userdata_type: ::std::option::Option<crate::types::UserdataType>,
}
impl LaunchTemplateSpecificationOverrideBuilder {
    /// <p>The ID of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateId</code> you can't specify the <code>launchTemplateName</code> as well.</p>
    pub fn launch_template_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.launch_template_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateId</code> you can't specify the <code>launchTemplateName</code> as well.</p>
    pub fn set_launch_template_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.launch_template_id = input;
        self
    }
    /// <p>The ID of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateId</code> you can't specify the <code>launchTemplateName</code> as well.</p>
    pub fn get_launch_template_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.launch_template_id
    }
    /// <p>The name of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateName</code> you can't specify the <code>launchTemplateId</code> as well.</p>
    pub fn launch_template_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.launch_template_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateName</code> you can't specify the <code>launchTemplateId</code> as well.</p>
    pub fn set_launch_template_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.launch_template_name = input;
        self
    }
    /// <p>The name of the launch template.</p>
    /// <p><b>Note:</b> If you specify the <code>launchTemplateName</code> you can't specify the <code>launchTemplateId</code> as well.</p>
    pub fn get_launch_template_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.launch_template_name
    }
    /// <p>The version number of the launch template, <code>$Default</code>, or <code>$Latest</code>.</p>
    /// <p>If the value is <code>$Default</code>, the default version of the launch template is used. If the value is <code>$Latest</code>, the latest version of the launch template is used.</p><important>
    /// <p>If the AMI ID that's used in a compute environment is from the launch template, the AMI isn't changed when the compute environment is updated. It's only changed if the <code>updateToLatestImageVersion</code> parameter for the compute environment is set to <code>true</code>. During an infrastructure update, if either <code>$Default</code> or <code>$Latest</code> is specified, Batch re-evaluates the launch template version, and it might use a different version of the launch template. This is the case even if the launch template isn't specified in the update. When updating a compute environment, changing the launch template requires an infrastructure update of the compute environment. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/updating-compute-environments.html">Updating compute environments</a> in the <i>Batch User Guide</i>.</p>
    /// </important>
    /// <p>Default: <code>$Default</code></p>
    /// <p>Latest: <code>$Latest</code></p>
    pub fn version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version number of the launch template, <code>$Default</code>, or <code>$Latest</code>.</p>
    /// <p>If the value is <code>$Default</code>, the default version of the launch template is used. If the value is <code>$Latest</code>, the latest version of the launch template is used.</p><important>
    /// <p>If the AMI ID that's used in a compute environment is from the launch template, the AMI isn't changed when the compute environment is updated. It's only changed if the <code>updateToLatestImageVersion</code> parameter for the compute environment is set to <code>true</code>. During an infrastructure update, if either <code>$Default</code> or <code>$Latest</code> is specified, Batch re-evaluates the launch template version, and it might use a different version of the launch template. This is the case even if the launch template isn't specified in the update. When updating a compute environment, changing the launch template requires an infrastructure update of the compute environment. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/updating-compute-environments.html">Updating compute environments</a> in the <i>Batch User Guide</i>.</p>
    /// </important>
    /// <p>Default: <code>$Default</code></p>
    /// <p>Latest: <code>$Latest</code></p>
    pub fn set_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// <p>The version number of the launch template, <code>$Default</code>, or <code>$Latest</code>.</p>
    /// <p>If the value is <code>$Default</code>, the default version of the launch template is used. If the value is <code>$Latest</code>, the latest version of the launch template is used.</p><important>
    /// <p>If the AMI ID that's used in a compute environment is from the launch template, the AMI isn't changed when the compute environment is updated. It's only changed if the <code>updateToLatestImageVersion</code> parameter for the compute environment is set to <code>true</code>. During an infrastructure update, if either <code>$Default</code> or <code>$Latest</code> is specified, Batch re-evaluates the launch template version, and it might use a different version of the launch template. This is the case even if the launch template isn't specified in the update. When updating a compute environment, changing the launch template requires an infrastructure update of the compute environment. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/updating-compute-environments.html">Updating compute environments</a> in the <i>Batch User Guide</i>.</p>
    /// </important>
    /// <p>Default: <code>$Default</code></p>
    /// <p>Latest: <code>$Latest</code></p>
    pub fn get_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.version
    }
    /// Appends an item to `target_instance_types`.
    ///
    /// To override the contents of this collection use [`set_target_instance_types`](Self::set_target_instance_types).
    ///
    /// <p>The instance type or family that this override launch template should be applied to.</p>
    /// <p>This parameter is required when defining a launch template override.</p>
    /// <p>Information included in this parameter must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Must be a valid Amazon EC2 instance type or family.</p></li>
    /// <li>
    /// <p><code>optimal</code> isn't allowed.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> can target only instance types and families that are included within the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-instanceTypes"> <code>ComputeResource.instanceTypes</code> </a> set. <code>targetInstanceTypes</code> doesn't need to include all of the instances from the <code>instanceType</code> set, but at least a subset. For example, if <code>ComputeResource.instanceTypes</code> includes <code>\[m5, g5\]</code>, <code>targetInstanceTypes</code> can include <code>\[m5.2xlarge\]</code> and <code>\[m5.large\]</code> but not <code>\[c5.large\]</code>.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> included within the same launch template override or across launch template overrides can't overlap for the same compute environment. For example, you can't define one launch template override to target an instance family and another define an instance type within this same family.</p></li>
    /// </ul>
    pub fn target_instance_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.target_instance_types.unwrap_or_default();
        v.push(input.into());
        self.target_instance_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The instance type or family that this override launch template should be applied to.</p>
    /// <p>This parameter is required when defining a launch template override.</p>
    /// <p>Information included in this parameter must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Must be a valid Amazon EC2 instance type or family.</p></li>
    /// <li>
    /// <p><code>optimal</code> isn't allowed.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> can target only instance types and families that are included within the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-instanceTypes"> <code>ComputeResource.instanceTypes</code> </a> set. <code>targetInstanceTypes</code> doesn't need to include all of the instances from the <code>instanceType</code> set, but at least a subset. For example, if <code>ComputeResource.instanceTypes</code> includes <code>\[m5, g5\]</code>, <code>targetInstanceTypes</code> can include <code>\[m5.2xlarge\]</code> and <code>\[m5.large\]</code> but not <code>\[c5.large\]</code>.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> included within the same launch template override or across launch template overrides can't overlap for the same compute environment. For example, you can't define one launch template override to target an instance family and another define an instance type within this same family.</p></li>
    /// </ul>
    pub fn set_target_instance_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.target_instance_types = input;
        self
    }
    /// <p>The instance type or family that this override launch template should be applied to.</p>
    /// <p>This parameter is required when defining a launch template override.</p>
    /// <p>Information included in this parameter must meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Must be a valid Amazon EC2 instance type or family.</p></li>
    /// <li>
    /// <p><code>optimal</code> isn't allowed.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> can target only instance types and families that are included within the <a href="https://docs.aws.amazon.com/batch/latest/APIReference/API_ComputeResource.html#Batch-Type-ComputeResource-instanceTypes"> <code>ComputeResource.instanceTypes</code> </a> set. <code>targetInstanceTypes</code> doesn't need to include all of the instances from the <code>instanceType</code> set, but at least a subset. For example, if <code>ComputeResource.instanceTypes</code> includes <code>\[m5, g5\]</code>, <code>targetInstanceTypes</code> can include <code>\[m5.2xlarge\]</code> and <code>\[m5.large\]</code> but not <code>\[c5.large\]</code>.</p></li>
    /// <li>
    /// <p><code>targetInstanceTypes</code> included within the same launch template override or across launch template overrides can't overlap for the same compute environment. For example, you can't define one launch template override to target an instance family and another define an instance type within this same family.</p></li>
    /// </ul>
    pub fn get_target_instance_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.target_instance_types
    }
    /// <p>The EKS node initialization process to use. You only need to specify this value if you are using a custom AMI. The default value is <code>EKS_BOOTSTRAP_SH</code>. If <i>imageType</i> is a custom AMI based on EKS_AL2023 or EKS_AL2023_NVIDIA then you must choose <code>EKS_NODEADM</code>.</p>
    pub fn userdata_type(mut self, input: crate::types::UserdataType) -> Self {
        self.userdata_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The EKS node initialization process to use. You only need to specify this value if you are using a custom AMI. The default value is <code>EKS_BOOTSTRAP_SH</code>. If <i>imageType</i> is a custom AMI based on EKS_AL2023 or EKS_AL2023_NVIDIA then you must choose <code>EKS_NODEADM</code>.</p>
    pub fn set_userdata_type(mut self, input: ::std::option::Option<crate::types::UserdataType>) -> Self {
        self.userdata_type = input;
        self
    }
    /// <p>The EKS node initialization process to use. You only need to specify this value if you are using a custom AMI. The default value is <code>EKS_BOOTSTRAP_SH</code>. If <i>imageType</i> is a custom AMI based on EKS_AL2023 or EKS_AL2023_NVIDIA then you must choose <code>EKS_NODEADM</code>.</p>
    pub fn get_userdata_type(&self) -> &::std::option::Option<crate::types::UserdataType> {
        &self.userdata_type
    }
    /// Consumes the builder and constructs a [`LaunchTemplateSpecificationOverride`](crate::types::LaunchTemplateSpecificationOverride).
    pub fn build(self) -> crate::types::LaunchTemplateSpecificationOverride {
        crate::types::LaunchTemplateSpecificationOverride {
            launch_template_id: self.launch_template_id,
            launch_template_name: self.launch_template_name,
            version: self.version,
            target_instance_types: self.target_instance_types,
            userdata_type: self.userdata_type,
        }
    }
}
