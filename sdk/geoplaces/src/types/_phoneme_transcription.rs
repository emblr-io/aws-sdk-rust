// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>How to pronounce the various components of the address or place.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct PhonemeTranscription {
    /// <p>Value which indicates how to pronounce the value.</p>
    pub value: ::std::option::Option<::std::string::String>,
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub language: ::std::option::Option<::std::string::String>,
    /// <p>Boolean which indicates if it the preferred pronunciation.</p>
    pub preferred: ::std::option::Option<bool>,
}
impl PhonemeTranscription {
    /// <p>Value which indicates how to pronounce the value.</p>
    pub fn value(&self) -> ::std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn language(&self) -> ::std::option::Option<&str> {
        self.language.as_deref()
    }
    /// <p>Boolean which indicates if it the preferred pronunciation.</p>
    pub fn preferred(&self) -> ::std::option::Option<bool> {
        self.preferred
    }
}
impl ::std::fmt::Debug for PhonemeTranscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("PhonemeTranscription");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.field("language", &self.language);
        formatter.field("preferred", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl PhonemeTranscription {
    /// Creates a new builder-style object to manufacture [`PhonemeTranscription`](crate::types::PhonemeTranscription).
    pub fn builder() -> crate::types::builders::PhonemeTranscriptionBuilder {
        crate::types::builders::PhonemeTranscriptionBuilder::default()
    }
}

/// A builder for [`PhonemeTranscription`](crate::types::PhonemeTranscription).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct PhonemeTranscriptionBuilder {
    pub(crate) value: ::std::option::Option<::std::string::String>,
    pub(crate) language: ::std::option::Option<::std::string::String>,
    pub(crate) preferred: ::std::option::Option<bool>,
}
impl PhonemeTranscriptionBuilder {
    /// <p>Value which indicates how to pronounce the value.</p>
    pub fn value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.value = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Value which indicates how to pronounce the value.</p>
    pub fn set_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.value = input;
        self
    }
    /// <p>Value which indicates how to pronounce the value.</p>
    pub fn get_value(&self) -> &::std::option::Option<::std::string::String> {
        &self.value
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn language(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.language = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn set_language(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.language = input;
        self
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn get_language(&self) -> &::std::option::Option<::std::string::String> {
        &self.language
    }
    /// <p>Boolean which indicates if it the preferred pronunciation.</p>
    pub fn preferred(mut self, input: bool) -> Self {
        self.preferred = ::std::option::Option::Some(input);
        self
    }
    /// <p>Boolean which indicates if it the preferred pronunciation.</p>
    pub fn set_preferred(mut self, input: ::std::option::Option<bool>) -> Self {
        self.preferred = input;
        self
    }
    /// <p>Boolean which indicates if it the preferred pronunciation.</p>
    pub fn get_preferred(&self) -> &::std::option::Option<bool> {
        &self.preferred
    }
    /// Consumes the builder and constructs a [`PhonemeTranscription`](crate::types::PhonemeTranscription).
    pub fn build(self) -> crate::types::PhonemeTranscription {
        crate::types::PhonemeTranscription {
            value: self.value,
            language: self.language,
            preferred: self.preferred,
        }
    }
}
impl ::std::fmt::Debug for PhonemeTranscriptionBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("PhonemeTranscriptionBuilder");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.field("language", &self.language);
        formatter.field("preferred", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
