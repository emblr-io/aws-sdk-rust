// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Components of a street.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct StreetComponents {
    /// <p>Base name part of the street name.</p>
    /// <p>Example: Younge from the "Younge street".</p>
    pub base_name: ::std::option::Option<::std::string::String>,
    /// <p>Street type part of the street name.</p>
    /// <p>Example: <code>"avenue"</code>.</p>
    pub r#type: ::std::option::Option<::std::string::String>,
    /// <p>Defines if the street type is before or after the base name.</p>
    pub type_placement: ::std::option::Option<crate::types::TypePlacement>,
    /// <p>Defines a separator character such as <code>""</code> or <code>" "</code> between the base name and type.</p>
    pub type_separator: ::std::option::Option<::std::string::String>,
    /// <p>A prefix is a directional identifier that precedes, but is not included in, the base name of a road.</p>
    /// <p>Example: E for East.</p>
    pub prefix: ::std::option::Option<::std::string::String>,
    /// <p>A suffix is a directional identifier that follows, but is not included in, the base name of a road.</p>
    /// <p>Example W for West.</p>
    pub suffix: ::std::option::Option<::std::string::String>,
    /// <p>Indicates the official directional identifiers assigned to highways.</p>
    pub direction: ::std::option::Option<::std::string::String>,
    /// <p>A <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub language: ::std::option::Option<::std::string::String>,
}
impl StreetComponents {
    /// <p>Base name part of the street name.</p>
    /// <p>Example: Younge from the "Younge street".</p>
    pub fn base_name(&self) -> ::std::option::Option<&str> {
        self.base_name.as_deref()
    }
    /// <p>Street type part of the street name.</p>
    /// <p>Example: <code>"avenue"</code>.</p>
    pub fn r#type(&self) -> ::std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Defines if the street type is before or after the base name.</p>
    pub fn type_placement(&self) -> ::std::option::Option<&crate::types::TypePlacement> {
        self.type_placement.as_ref()
    }
    /// <p>Defines a separator character such as <code>""</code> or <code>" "</code> between the base name and type.</p>
    pub fn type_separator(&self) -> ::std::option::Option<&str> {
        self.type_separator.as_deref()
    }
    /// <p>A prefix is a directional identifier that precedes, but is not included in, the base name of a road.</p>
    /// <p>Example: E for East.</p>
    pub fn prefix(&self) -> ::std::option::Option<&str> {
        self.prefix.as_deref()
    }
    /// <p>A suffix is a directional identifier that follows, but is not included in, the base name of a road.</p>
    /// <p>Example W for West.</p>
    pub fn suffix(&self) -> ::std::option::Option<&str> {
        self.suffix.as_deref()
    }
    /// <p>Indicates the official directional identifiers assigned to highways.</p>
    pub fn direction(&self) -> ::std::option::Option<&str> {
        self.direction.as_deref()
    }
    /// <p>A <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn language(&self) -> ::std::option::Option<&str> {
        self.language.as_deref()
    }
}
impl ::std::fmt::Debug for StreetComponents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("StreetComponents");
        formatter.field("base_name", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &"*** Sensitive Data Redacted ***");
        formatter.field("type_placement", &self.type_placement);
        formatter.field("type_separator", &self.type_separator);
        formatter.field("prefix", &"*** Sensitive Data Redacted ***");
        formatter.field("suffix", &"*** Sensitive Data Redacted ***");
        formatter.field("direction", &"*** Sensitive Data Redacted ***");
        formatter.field("language", &self.language);
        formatter.finish()
    }
}
impl StreetComponents {
    /// Creates a new builder-style object to manufacture [`StreetComponents`](crate::types::StreetComponents).
    pub fn builder() -> crate::types::builders::StreetComponentsBuilder {
        crate::types::builders::StreetComponentsBuilder::default()
    }
}

/// A builder for [`StreetComponents`](crate::types::StreetComponents).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct StreetComponentsBuilder {
    pub(crate) base_name: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<::std::string::String>,
    pub(crate) type_placement: ::std::option::Option<crate::types::TypePlacement>,
    pub(crate) type_separator: ::std::option::Option<::std::string::String>,
    pub(crate) prefix: ::std::option::Option<::std::string::String>,
    pub(crate) suffix: ::std::option::Option<::std::string::String>,
    pub(crate) direction: ::std::option::Option<::std::string::String>,
    pub(crate) language: ::std::option::Option<::std::string::String>,
}
impl StreetComponentsBuilder {
    /// <p>Base name part of the street name.</p>
    /// <p>Example: Younge from the "Younge street".</p>
    pub fn base_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.base_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Base name part of the street name.</p>
    /// <p>Example: Younge from the "Younge street".</p>
    pub fn set_base_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.base_name = input;
        self
    }
    /// <p>Base name part of the street name.</p>
    /// <p>Example: Younge from the "Younge street".</p>
    pub fn get_base_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.base_name
    }
    /// <p>Street type part of the street name.</p>
    /// <p>Example: <code>"avenue"</code>.</p>
    pub fn r#type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.r#type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Street type part of the street name.</p>
    /// <p>Example: <code>"avenue"</code>.</p>
    pub fn set_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>Street type part of the street name.</p>
    /// <p>Example: <code>"avenue"</code>.</p>
    pub fn get_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.r#type
    }
    /// <p>Defines if the street type is before or after the base name.</p>
    pub fn type_placement(mut self, input: crate::types::TypePlacement) -> Self {
        self.type_placement = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines if the street type is before or after the base name.</p>
    pub fn set_type_placement(mut self, input: ::std::option::Option<crate::types::TypePlacement>) -> Self {
        self.type_placement = input;
        self
    }
    /// <p>Defines if the street type is before or after the base name.</p>
    pub fn get_type_placement(&self) -> &::std::option::Option<crate::types::TypePlacement> {
        &self.type_placement
    }
    /// <p>Defines a separator character such as <code>""</code> or <code>" "</code> between the base name and type.</p>
    pub fn type_separator(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.type_separator = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Defines a separator character such as <code>""</code> or <code>" "</code> between the base name and type.</p>
    pub fn set_type_separator(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.type_separator = input;
        self
    }
    /// <p>Defines a separator character such as <code>""</code> or <code>" "</code> between the base name and type.</p>
    pub fn get_type_separator(&self) -> &::std::option::Option<::std::string::String> {
        &self.type_separator
    }
    /// <p>A prefix is a directional identifier that precedes, but is not included in, the base name of a road.</p>
    /// <p>Example: E for East.</p>
    pub fn prefix(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.prefix = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A prefix is a directional identifier that precedes, but is not included in, the base name of a road.</p>
    /// <p>Example: E for East.</p>
    pub fn set_prefix(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.prefix = input;
        self
    }
    /// <p>A prefix is a directional identifier that precedes, but is not included in, the base name of a road.</p>
    /// <p>Example: E for East.</p>
    pub fn get_prefix(&self) -> &::std::option::Option<::std::string::String> {
        &self.prefix
    }
    /// <p>A suffix is a directional identifier that follows, but is not included in, the base name of a road.</p>
    /// <p>Example W for West.</p>
    pub fn suffix(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.suffix = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A suffix is a directional identifier that follows, but is not included in, the base name of a road.</p>
    /// <p>Example W for West.</p>
    pub fn set_suffix(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.suffix = input;
        self
    }
    /// <p>A suffix is a directional identifier that follows, but is not included in, the base name of a road.</p>
    /// <p>Example W for West.</p>
    pub fn get_suffix(&self) -> &::std::option::Option<::std::string::String> {
        &self.suffix
    }
    /// <p>Indicates the official directional identifiers assigned to highways.</p>
    pub fn direction(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.direction = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates the official directional identifiers assigned to highways.</p>
    pub fn set_direction(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.direction = input;
        self
    }
    /// <p>Indicates the official directional identifiers assigned to highways.</p>
    pub fn get_direction(&self) -> &::std::option::Option<::std::string::String> {
        &self.direction
    }
    /// <p>A <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn language(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.language = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn set_language(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.language = input;
        self
    }
    /// <p>A <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn get_language(&self) -> &::std::option::Option<::std::string::String> {
        &self.language
    }
    /// Consumes the builder and constructs a [`StreetComponents`](crate::types::StreetComponents).
    pub fn build(self) -> crate::types::StreetComponents {
        crate::types::StreetComponents {
            base_name: self.base_name,
            r#type: self.r#type,
            type_placement: self.type_placement,
            type_separator: self.type_separator,
            prefix: self.prefix,
            suffix: self.suffix,
            direction: self.direction,
            language: self.language,
        }
    }
}
impl ::std::fmt::Debug for StreetComponentsBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("StreetComponentsBuilder");
        formatter.field("base_name", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &"*** Sensitive Data Redacted ***");
        formatter.field("type_placement", &self.type_placement);
        formatter.field("type_separator", &self.type_separator);
        formatter.field("prefix", &"*** Sensitive Data Redacted ***");
        formatter.field("suffix", &"*** Sensitive Data Redacted ***");
        formatter.field("direction", &"*** Sensitive Data Redacted ***");
        formatter.field("language", &self.language);
        formatter.finish()
    }
}
