// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The node group update configuration. An Amazon EKS managed node group updates by replacing nodes with new nodes of newer AMI versions in parallel. You choose the <i>maximum unavailable</i> and the <i>update strategy</i>.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NodegroupUpdateConfig {
    /// <p>The maximum number of nodes unavailable at once during a version update. Nodes are updated in parallel. This value or <code>maxUnavailablePercentage</code> is required to have a value.The maximum number is 100.</p>
    pub max_unavailable: ::std::option::Option<i32>,
    /// <p>The maximum percentage of nodes unavailable during a version update. This percentage of nodes are updated in parallel, up to 100 nodes at once. This value or <code>maxUnavailable</code> is required to have a value.</p>
    pub max_unavailable_percentage: ::std::option::Option<i32>,
    /// <p>The configuration for the behavior to follow during a node group version update of this managed node group. You choose between two possible strategies for replacing nodes during an <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateNodegroupVersion.html"> <code>UpdateNodegroupVersion</code> </a> action.</p>
    /// <p>An Amazon EKS managed node group updates by replacing nodes with new nodes of newer AMI versions in parallel. The <i>update strategy</i> changes the managed node update behavior of the managed node group for each quantity. The <i>default</i> strategy has guardrails to protect you from misconfiguration and launches the new instances first, before terminating the old instances. The <i>minimal</i> strategy removes the guardrails and terminates the old instances before launching the new instances. This minimal strategy is useful in scenarios where you are constrained to resources or costs (for example, with hardware accelerators such as GPUs).</p>
    pub update_strategy: ::std::option::Option<crate::types::NodegroupUpdateStrategies>,
}
impl NodegroupUpdateConfig {
    /// <p>The maximum number of nodes unavailable at once during a version update. Nodes are updated in parallel. This value or <code>maxUnavailablePercentage</code> is required to have a value.The maximum number is 100.</p>
    pub fn max_unavailable(&self) -> ::std::option::Option<i32> {
        self.max_unavailable
    }
    /// <p>The maximum percentage of nodes unavailable during a version update. This percentage of nodes are updated in parallel, up to 100 nodes at once. This value or <code>maxUnavailable</code> is required to have a value.</p>
    pub fn max_unavailable_percentage(&self) -> ::std::option::Option<i32> {
        self.max_unavailable_percentage
    }
    /// <p>The configuration for the behavior to follow during a node group version update of this managed node group. You choose between two possible strategies for replacing nodes during an <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateNodegroupVersion.html"> <code>UpdateNodegroupVersion</code> </a> action.</p>
    /// <p>An Amazon EKS managed node group updates by replacing nodes with new nodes of newer AMI versions in parallel. The <i>update strategy</i> changes the managed node update behavior of the managed node group for each quantity. The <i>default</i> strategy has guardrails to protect you from misconfiguration and launches the new instances first, before terminating the old instances. The <i>minimal</i> strategy removes the guardrails and terminates the old instances before launching the new instances. This minimal strategy is useful in scenarios where you are constrained to resources or costs (for example, with hardware accelerators such as GPUs).</p>
    pub fn update_strategy(&self) -> ::std::option::Option<&crate::types::NodegroupUpdateStrategies> {
        self.update_strategy.as_ref()
    }
}
impl NodegroupUpdateConfig {
    /// Creates a new builder-style object to manufacture [`NodegroupUpdateConfig`](crate::types::NodegroupUpdateConfig).
    pub fn builder() -> crate::types::builders::NodegroupUpdateConfigBuilder {
        crate::types::builders::NodegroupUpdateConfigBuilder::default()
    }
}

/// A builder for [`NodegroupUpdateConfig`](crate::types::NodegroupUpdateConfig).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct NodegroupUpdateConfigBuilder {
    pub(crate) max_unavailable: ::std::option::Option<i32>,
    pub(crate) max_unavailable_percentage: ::std::option::Option<i32>,
    pub(crate) update_strategy: ::std::option::Option<crate::types::NodegroupUpdateStrategies>,
}
impl NodegroupUpdateConfigBuilder {
    /// <p>The maximum number of nodes unavailable at once during a version update. Nodes are updated in parallel. This value or <code>maxUnavailablePercentage</code> is required to have a value.The maximum number is 100.</p>
    pub fn max_unavailable(mut self, input: i32) -> Self {
        self.max_unavailable = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of nodes unavailable at once during a version update. Nodes are updated in parallel. This value or <code>maxUnavailablePercentage</code> is required to have a value.The maximum number is 100.</p>
    pub fn set_max_unavailable(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_unavailable = input;
        self
    }
    /// <p>The maximum number of nodes unavailable at once during a version update. Nodes are updated in parallel. This value or <code>maxUnavailablePercentage</code> is required to have a value.The maximum number is 100.</p>
    pub fn get_max_unavailable(&self) -> &::std::option::Option<i32> {
        &self.max_unavailable
    }
    /// <p>The maximum percentage of nodes unavailable during a version update. This percentage of nodes are updated in parallel, up to 100 nodes at once. This value or <code>maxUnavailable</code> is required to have a value.</p>
    pub fn max_unavailable_percentage(mut self, input: i32) -> Self {
        self.max_unavailable_percentage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum percentage of nodes unavailable during a version update. This percentage of nodes are updated in parallel, up to 100 nodes at once. This value or <code>maxUnavailable</code> is required to have a value.</p>
    pub fn set_max_unavailable_percentage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_unavailable_percentage = input;
        self
    }
    /// <p>The maximum percentage of nodes unavailable during a version update. This percentage of nodes are updated in parallel, up to 100 nodes at once. This value or <code>maxUnavailable</code> is required to have a value.</p>
    pub fn get_max_unavailable_percentage(&self) -> &::std::option::Option<i32> {
        &self.max_unavailable_percentage
    }
    /// <p>The configuration for the behavior to follow during a node group version update of this managed node group. You choose between two possible strategies for replacing nodes during an <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateNodegroupVersion.html"> <code>UpdateNodegroupVersion</code> </a> action.</p>
    /// <p>An Amazon EKS managed node group updates by replacing nodes with new nodes of newer AMI versions in parallel. The <i>update strategy</i> changes the managed node update behavior of the managed node group for each quantity. The <i>default</i> strategy has guardrails to protect you from misconfiguration and launches the new instances first, before terminating the old instances. The <i>minimal</i> strategy removes the guardrails and terminates the old instances before launching the new instances. This minimal strategy is useful in scenarios where you are constrained to resources or costs (for example, with hardware accelerators such as GPUs).</p>
    pub fn update_strategy(mut self, input: crate::types::NodegroupUpdateStrategies) -> Self {
        self.update_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration for the behavior to follow during a node group version update of this managed node group. You choose between two possible strategies for replacing nodes during an <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateNodegroupVersion.html"> <code>UpdateNodegroupVersion</code> </a> action.</p>
    /// <p>An Amazon EKS managed node group updates by replacing nodes with new nodes of newer AMI versions in parallel. The <i>update strategy</i> changes the managed node update behavior of the managed node group for each quantity. The <i>default</i> strategy has guardrails to protect you from misconfiguration and launches the new instances first, before terminating the old instances. The <i>minimal</i> strategy removes the guardrails and terminates the old instances before launching the new instances. This minimal strategy is useful in scenarios where you are constrained to resources or costs (for example, with hardware accelerators such as GPUs).</p>
    pub fn set_update_strategy(mut self, input: ::std::option::Option<crate::types::NodegroupUpdateStrategies>) -> Self {
        self.update_strategy = input;
        self
    }
    /// <p>The configuration for the behavior to follow during a node group version update of this managed node group. You choose between two possible strategies for replacing nodes during an <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateNodegroupVersion.html"> <code>UpdateNodegroupVersion</code> </a> action.</p>
    /// <p>An Amazon EKS managed node group updates by replacing nodes with new nodes of newer AMI versions in parallel. The <i>update strategy</i> changes the managed node update behavior of the managed node group for each quantity. The <i>default</i> strategy has guardrails to protect you from misconfiguration and launches the new instances first, before terminating the old instances. The <i>minimal</i> strategy removes the guardrails and terminates the old instances before launching the new instances. This minimal strategy is useful in scenarios where you are constrained to resources or costs (for example, with hardware accelerators such as GPUs).</p>
    pub fn get_update_strategy(&self) -> &::std::option::Option<crate::types::NodegroupUpdateStrategies> {
        &self.update_strategy
    }
    /// Consumes the builder and constructs a [`NodegroupUpdateConfig`](crate::types::NodegroupUpdateConfig).
    pub fn build(self) -> crate::types::NodegroupUpdateConfig {
        crate::types::NodegroupUpdateConfig {
            max_unavailable: self.max_unavailable,
            max_unavailable_percentage: self.max_unavailable_percentage,
            update_strategy: self.update_strategy,
        }
    }
}
