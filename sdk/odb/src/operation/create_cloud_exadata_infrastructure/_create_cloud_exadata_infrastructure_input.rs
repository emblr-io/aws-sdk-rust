// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateCloudExadataInfrastructureInput {
    /// <p>A user-friendly name for the Exadata infrastructure.</p>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The model name of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub shape: ::std::option::Option<::std::string::String>,
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>us-east-1a</code></p>
    pub availability_zone: ::std::option::Option<::std::string::String>,
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>use1-az1</code></p>
    pub availability_zone_id: ::std::option::Option<::std::string::String>,
    /// <p>The list of resource tags to apply to the Exadata infrastructure.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub compute_count: ::std::option::Option<i32>,
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub customer_contacts_to_send_to_oci: ::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>>,
    /// <p>The maintenance window configuration for the Exadata Cloud infrastructure.</p>
    /// <p>This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.</p>
    pub maintenance_window: ::std::option::Option<crate::types::MaintenanceWindow>,
    /// <p>The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub storage_count: ::std::option::Option<i32>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub database_server_type: ::std::option::Option<::std::string::String>,
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub storage_server_type: ::std::option::Option<::std::string::String>,
}
impl CreateCloudExadataInfrastructureInput {
    /// <p>A user-friendly name for the Exadata infrastructure.</p>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The model name of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn shape(&self) -> ::std::option::Option<&str> {
        self.shape.as_deref()
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>us-east-1a</code></p>
    pub fn availability_zone(&self) -> ::std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>use1-az1</code></p>
    pub fn availability_zone_id(&self) -> ::std::option::Option<&str> {
        self.availability_zone_id.as_deref()
    }
    /// <p>The list of resource tags to apply to the Exadata infrastructure.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn compute_count(&self) -> ::std::option::Option<i32> {
        self.compute_count
    }
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.customer_contacts_to_send_to_oci.is_none()`.
    pub fn customer_contacts_to_send_to_oci(&self) -> &[crate::types::CustomerContact] {
        self.customer_contacts_to_send_to_oci.as_deref().unwrap_or_default()
    }
    /// <p>The maintenance window configuration for the Exadata Cloud infrastructure.</p>
    /// <p>This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.</p>
    pub fn maintenance_window(&self) -> ::std::option::Option<&crate::types::MaintenanceWindow> {
        self.maintenance_window.as_ref()
    }
    /// <p>The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn storage_count(&self) -> ::std::option::Option<i32> {
        self.storage_count
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn database_server_type(&self) -> ::std::option::Option<&str> {
        self.database_server_type.as_deref()
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn storage_server_type(&self) -> ::std::option::Option<&str> {
        self.storage_server_type.as_deref()
    }
}
impl CreateCloudExadataInfrastructureInput {
    /// Creates a new builder-style object to manufacture [`CreateCloudExadataInfrastructureInput`](crate::operation::create_cloud_exadata_infrastructure::CreateCloudExadataInfrastructureInput).
    pub fn builder() -> crate::operation::create_cloud_exadata_infrastructure::builders::CreateCloudExadataInfrastructureInputBuilder {
        crate::operation::create_cloud_exadata_infrastructure::builders::CreateCloudExadataInfrastructureInputBuilder::default()
    }
}

/// A builder for [`CreateCloudExadataInfrastructureInput`](crate::operation::create_cloud_exadata_infrastructure::CreateCloudExadataInfrastructureInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateCloudExadataInfrastructureInputBuilder {
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) shape: ::std::option::Option<::std::string::String>,
    pub(crate) availability_zone: ::std::option::Option<::std::string::String>,
    pub(crate) availability_zone_id: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) compute_count: ::std::option::Option<i32>,
    pub(crate) customer_contacts_to_send_to_oci: ::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>>,
    pub(crate) maintenance_window: ::std::option::Option<crate::types::MaintenanceWindow>,
    pub(crate) storage_count: ::std::option::Option<i32>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) database_server_type: ::std::option::Option<::std::string::String>,
    pub(crate) storage_server_type: ::std::option::Option<::std::string::String>,
}
impl CreateCloudExadataInfrastructureInputBuilder {
    /// <p>A user-friendly name for the Exadata infrastructure.</p>
    /// This field is required.
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A user-friendly name for the Exadata infrastructure.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>A user-friendly name for the Exadata infrastructure.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The model name of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    /// This field is required.
    pub fn shape(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.shape = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The model name of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_shape(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.shape = input;
        self
    }
    /// <p>The model name of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_shape(&self) -> &::std::option::Option<::std::string::String> {
        &self.shape
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>us-east-1a</code></p>
    pub fn availability_zone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>us-east-1a</code></p>
    pub fn set_availability_zone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone = input;
        self
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>us-east-1a</code></p>
    pub fn get_availability_zone(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>use1-az1</code></p>
    pub fn availability_zone_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>use1-az1</code></p>
    pub fn set_availability_zone_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone_id = input;
        self
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    /// <p>This operation requires that you specify a value for either <code>availabilityZone</code> or <code>availabilityZoneId</code>.</p>
    /// <p>Example: <code>use1-az1</code></p>
    pub fn get_availability_zone_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone_id
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The list of resource tags to apply to the Exadata infrastructure.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The list of resource tags to apply to the Exadata infrastructure.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The list of resource tags to apply to the Exadata infrastructure.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    /// This field is required.
    pub fn compute_count(mut self, input: i32) -> Self {
        self.compute_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_compute_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compute_count = input;
        self
    }
    /// <p>The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_compute_count(&self) -> &::std::option::Option<i32> {
        &self.compute_count
    }
    /// Appends an item to `customer_contacts_to_send_to_oci`.
    ///
    /// To override the contents of this collection use [`set_customer_contacts_to_send_to_oci`](Self::set_customer_contacts_to_send_to_oci).
    ///
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub fn customer_contacts_to_send_to_oci(mut self, input: crate::types::CustomerContact) -> Self {
        let mut v = self.customer_contacts_to_send_to_oci.unwrap_or_default();
        v.push(input);
        self.customer_contacts_to_send_to_oci = ::std::option::Option::Some(v);
        self
    }
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub fn set_customer_contacts_to_send_to_oci(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>>) -> Self {
        self.customer_contacts_to_send_to_oci = input;
        self
    }
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub fn get_customer_contacts_to_send_to_oci(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>> {
        &self.customer_contacts_to_send_to_oci
    }
    /// <p>The maintenance window configuration for the Exadata Cloud infrastructure.</p>
    /// <p>This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.</p>
    pub fn maintenance_window(mut self, input: crate::types::MaintenanceWindow) -> Self {
        self.maintenance_window = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maintenance window configuration for the Exadata Cloud infrastructure.</p>
    /// <p>This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.</p>
    pub fn set_maintenance_window(mut self, input: ::std::option::Option<crate::types::MaintenanceWindow>) -> Self {
        self.maintenance_window = input;
        self
    }
    /// <p>The maintenance window configuration for the Exadata Cloud infrastructure.</p>
    /// <p>This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.</p>
    pub fn get_maintenance_window(&self) -> &::std::option::Option<crate::types::MaintenanceWindow> {
        &self.maintenance_window
    }
    /// <p>The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    /// This field is required.
    pub fn storage_count(mut self, input: i32) -> Self {
        self.storage_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_storage_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.storage_count = input;
        self
    }
    /// <p>The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_storage_count(&self) -> &::std::option::Option<i32> {
        &self.storage_count
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn database_server_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database_server_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_database_server_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database_server_type = input;
        self
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_database_server_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.database_server_type
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn storage_server_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.storage_server_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_storage_server_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.storage_server_type = input;
        self
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_storage_server_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.storage_server_type
    }
    /// Consumes the builder and constructs a [`CreateCloudExadataInfrastructureInput`](crate::operation::create_cloud_exadata_infrastructure::CreateCloudExadataInfrastructureInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_cloud_exadata_infrastructure::CreateCloudExadataInfrastructureInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(
            crate::operation::create_cloud_exadata_infrastructure::CreateCloudExadataInfrastructureInput {
                display_name: self.display_name,
                shape: self.shape,
                availability_zone: self.availability_zone,
                availability_zone_id: self.availability_zone_id,
                tags: self.tags,
                compute_count: self.compute_count,
                customer_contacts_to_send_to_oci: self.customer_contacts_to_send_to_oci,
                maintenance_window: self.maintenance_window,
                storage_count: self.storage_count,
                client_token: self.client_token,
                database_server_type: self.database_server_type,
                storage_server_type: self.storage_server_type,
            },
        )
    }
}
