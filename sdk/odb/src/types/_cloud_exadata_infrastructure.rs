// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about an Exadata infrastructure.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CloudExadataInfrastructure {
    /// <p>The unique identifier for the Exadata infrastructure.</p>
    pub cloud_exadata_infrastructure_id: ::std::string::String,
    /// <p>The user-friendly name for the Exadata infrastructure.</p>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The current status of the Exadata infrastructure.</p>
    pub status: ::std::option::Option<crate::types::ResourceStatus>,
    /// <p>Additional information about the status of the Exadata infrastructure.</p>
    pub status_reason: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the Exadata infrastructure.</p>
    pub cloud_exadata_infrastructure_arn: ::std::option::Option<::std::string::String>,
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub activated_storage_count: ::std::option::Option<i32>,
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub additional_storage_count: ::std::option::Option<i32>,
    /// <p>The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.</p>
    pub available_storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    pub availability_zone: ::std::option::Option<::std::string::String>,
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    pub availability_zone_id: ::std::option::Option<::std::string::String>,
    /// <p>The number of database servers for the Exadata infrastructure.</p>
    pub compute_count: ::std::option::Option<i32>,
    /// <p>The total number of CPU cores that are allocated to the Exadata infrastructure.</p>
    pub cpu_count: ::std::option::Option<i32>,
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub customer_contacts_to_send_to_oci: ::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>>,
    /// <p>The size of the Exadata infrastructure's data disk group, in terabytes (TB).</p>
    pub data_storage_size_in_tbs: ::std::option::Option<f64>,
    /// <p>The size of the Exadata infrastructure's local node storage, in gigabytes (GB).</p>
    pub db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The software version of the database servers (dom0) in the Exadata infrastructure.</p>
    pub db_server_version: ::std::option::Option<::std::string::String>,
    /// <p>The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.</p>
    pub last_maintenance_run_id: ::std::option::Option<::std::string::String>,
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub maintenance_window: ::std::option::Option<crate::types::MaintenanceWindow>,
    /// <p>The total number of CPU cores available on the Exadata infrastructure.</p>
    pub max_cpu_count: ::std::option::Option<i32>,
    /// <p>The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.</p>
    pub max_data_storage_in_tbs: ::std::option::Option<f64>,
    /// <p>The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub max_db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub max_memory_in_gbs: ::std::option::Option<i32>,
    /// <p>The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.</p>
    pub memory_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The monthly software version of the database servers installed on the Exadata infrastructure.</p>
    pub monthly_db_server_version: ::std::option::Option<::std::string::String>,
    /// <p>The monthly software version of the storage servers installed on the Exadata infrastructure.</p>
    pub monthly_storage_server_version: ::std::option::Option<::std::string::String>,
    /// <p>The OCID of the next maintenance run for the Exadata infrastructure.</p>
    pub next_maintenance_run_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the OCI resource anchor for the Exadata infrastructure.</p>
    pub oci_resource_anchor_name: ::std::option::Option<::std::string::String>,
    /// <p>The HTTPS link to the Exadata infrastructure in OCI.</p>
    pub oci_url: ::std::option::Option<::std::string::String>,
    /// <p>The OCID of the Exadata infrastructure.</p>
    pub ocid: ::std::option::Option<::std::string::String>,
    /// <p>The model name of the Exadata infrastructure.</p>
    pub shape: ::std::option::Option<::std::string::String>,
    /// <p>The number of storage servers that are activated for the Exadata infrastructure.</p>
    pub storage_count: ::std::option::Option<i32>,
    /// <p>The software version of the storage servers on the Exadata infrastructure.</p>
    pub storage_server_version: ::std::option::Option<::std::string::String>,
    /// <p>The date and time when the Exadata infrastructure was created.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.</p>
    pub total_storage_size_in_gbs: ::std::option::Option<i32>,
    /// <p>The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.</p>
    pub percent_progress: ::std::option::Option<f32>,
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub database_server_type: ::std::option::Option<::std::string::String>,
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub storage_server_type: ::std::option::Option<::std::string::String>,
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub compute_model: ::std::option::Option<crate::types::ComputeModel>,
}
impl CloudExadataInfrastructure {
    /// <p>The unique identifier for the Exadata infrastructure.</p>
    pub fn cloud_exadata_infrastructure_id(&self) -> &str {
        use std::ops::Deref;
        self.cloud_exadata_infrastructure_id.deref()
    }
    /// <p>The user-friendly name for the Exadata infrastructure.</p>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The current status of the Exadata infrastructure.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::ResourceStatus> {
        self.status.as_ref()
    }
    /// <p>Additional information about the status of the Exadata infrastructure.</p>
    pub fn status_reason(&self) -> ::std::option::Option<&str> {
        self.status_reason.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the Exadata infrastructure.</p>
    pub fn cloud_exadata_infrastructure_arn(&self) -> ::std::option::Option<&str> {
        self.cloud_exadata_infrastructure_arn.as_deref()
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn activated_storage_count(&self) -> ::std::option::Option<i32> {
        self.activated_storage_count
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn additional_storage_count(&self) -> ::std::option::Option<i32> {
        self.additional_storage_count
    }
    /// <p>The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.</p>
    pub fn available_storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.available_storage_size_in_gbs
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    pub fn availability_zone(&self) -> ::std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    pub fn availability_zone_id(&self) -> ::std::option::Option<&str> {
        self.availability_zone_id.as_deref()
    }
    /// <p>The number of database servers for the Exadata infrastructure.</p>
    pub fn compute_count(&self) -> ::std::option::Option<i32> {
        self.compute_count
    }
    /// <p>The total number of CPU cores that are allocated to the Exadata infrastructure.</p>
    pub fn cpu_count(&self) -> ::std::option::Option<i32> {
        self.cpu_count
    }
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.customer_contacts_to_send_to_oci.is_none()`.
    pub fn customer_contacts_to_send_to_oci(&self) -> &[crate::types::CustomerContact] {
        self.customer_contacts_to_send_to_oci.as_deref().unwrap_or_default()
    }
    /// <p>The size of the Exadata infrastructure's data disk group, in terabytes (TB).</p>
    pub fn data_storage_size_in_tbs(&self) -> ::std::option::Option<f64> {
        self.data_storage_size_in_tbs
    }
    /// <p>The size of the Exadata infrastructure's local node storage, in gigabytes (GB).</p>
    pub fn db_node_storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.db_node_storage_size_in_gbs
    }
    /// <p>The software version of the database servers (dom0) in the Exadata infrastructure.</p>
    pub fn db_server_version(&self) -> ::std::option::Option<&str> {
        self.db_server_version.as_deref()
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.</p>
    pub fn last_maintenance_run_id(&self) -> ::std::option::Option<&str> {
        self.last_maintenance_run_id.as_deref()
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn maintenance_window(&self) -> ::std::option::Option<&crate::types::MaintenanceWindow> {
        self.maintenance_window.as_ref()
    }
    /// <p>The total number of CPU cores available on the Exadata infrastructure.</p>
    pub fn max_cpu_count(&self) -> ::std::option::Option<i32> {
        self.max_cpu_count
    }
    /// <p>The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.</p>
    pub fn max_data_storage_in_tbs(&self) -> ::std::option::Option<f64> {
        self.max_data_storage_in_tbs
    }
    /// <p>The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn max_db_node_storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.max_db_node_storage_size_in_gbs
    }
    /// <p>The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn max_memory_in_gbs(&self) -> ::std::option::Option<i32> {
        self.max_memory_in_gbs
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.</p>
    pub fn memory_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.memory_size_in_gbs
    }
    /// <p>The monthly software version of the database servers installed on the Exadata infrastructure.</p>
    pub fn monthly_db_server_version(&self) -> ::std::option::Option<&str> {
        self.monthly_db_server_version.as_deref()
    }
    /// <p>The monthly software version of the storage servers installed on the Exadata infrastructure.</p>
    pub fn monthly_storage_server_version(&self) -> ::std::option::Option<&str> {
        self.monthly_storage_server_version.as_deref()
    }
    /// <p>The OCID of the next maintenance run for the Exadata infrastructure.</p>
    pub fn next_maintenance_run_id(&self) -> ::std::option::Option<&str> {
        self.next_maintenance_run_id.as_deref()
    }
    /// <p>The name of the OCI resource anchor for the Exadata infrastructure.</p>
    pub fn oci_resource_anchor_name(&self) -> ::std::option::Option<&str> {
        self.oci_resource_anchor_name.as_deref()
    }
    /// <p>The HTTPS link to the Exadata infrastructure in OCI.</p>
    pub fn oci_url(&self) -> ::std::option::Option<&str> {
        self.oci_url.as_deref()
    }
    /// <p>The OCID of the Exadata infrastructure.</p>
    pub fn ocid(&self) -> ::std::option::Option<&str> {
        self.ocid.as_deref()
    }
    /// <p>The model name of the Exadata infrastructure.</p>
    pub fn shape(&self) -> ::std::option::Option<&str> {
        self.shape.as_deref()
    }
    /// <p>The number of storage servers that are activated for the Exadata infrastructure.</p>
    pub fn storage_count(&self) -> ::std::option::Option<i32> {
        self.storage_count
    }
    /// <p>The software version of the storage servers on the Exadata infrastructure.</p>
    pub fn storage_server_version(&self) -> ::std::option::Option<&str> {
        self.storage_server_version.as_deref()
    }
    /// <p>The date and time when the Exadata infrastructure was created.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.</p>
    pub fn total_storage_size_in_gbs(&self) -> ::std::option::Option<i32> {
        self.total_storage_size_in_gbs
    }
    /// <p>The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.</p>
    pub fn percent_progress(&self) -> ::std::option::Option<f32> {
        self.percent_progress
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn database_server_type(&self) -> ::std::option::Option<&str> {
        self.database_server_type.as_deref()
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn storage_server_type(&self) -> ::std::option::Option<&str> {
        self.storage_server_type.as_deref()
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn compute_model(&self) -> ::std::option::Option<&crate::types::ComputeModel> {
        self.compute_model.as_ref()
    }
}
impl CloudExadataInfrastructure {
    /// Creates a new builder-style object to manufacture [`CloudExadataInfrastructure`](crate::types::CloudExadataInfrastructure).
    pub fn builder() -> crate::types::builders::CloudExadataInfrastructureBuilder {
        crate::types::builders::CloudExadataInfrastructureBuilder::default()
    }
}

/// A builder for [`CloudExadataInfrastructure`](crate::types::CloudExadataInfrastructure).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CloudExadataInfrastructureBuilder {
    pub(crate) cloud_exadata_infrastructure_id: ::std::option::Option<::std::string::String>,
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ResourceStatus>,
    pub(crate) status_reason: ::std::option::Option<::std::string::String>,
    pub(crate) cloud_exadata_infrastructure_arn: ::std::option::Option<::std::string::String>,
    pub(crate) activated_storage_count: ::std::option::Option<i32>,
    pub(crate) additional_storage_count: ::std::option::Option<i32>,
    pub(crate) available_storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) availability_zone: ::std::option::Option<::std::string::String>,
    pub(crate) availability_zone_id: ::std::option::Option<::std::string::String>,
    pub(crate) compute_count: ::std::option::Option<i32>,
    pub(crate) cpu_count: ::std::option::Option<i32>,
    pub(crate) customer_contacts_to_send_to_oci: ::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>>,
    pub(crate) data_storage_size_in_tbs: ::std::option::Option<f64>,
    pub(crate) db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) db_server_version: ::std::option::Option<::std::string::String>,
    pub(crate) last_maintenance_run_id: ::std::option::Option<::std::string::String>,
    pub(crate) maintenance_window: ::std::option::Option<crate::types::MaintenanceWindow>,
    pub(crate) max_cpu_count: ::std::option::Option<i32>,
    pub(crate) max_data_storage_in_tbs: ::std::option::Option<f64>,
    pub(crate) max_db_node_storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) max_memory_in_gbs: ::std::option::Option<i32>,
    pub(crate) memory_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) monthly_db_server_version: ::std::option::Option<::std::string::String>,
    pub(crate) monthly_storage_server_version: ::std::option::Option<::std::string::String>,
    pub(crate) next_maintenance_run_id: ::std::option::Option<::std::string::String>,
    pub(crate) oci_resource_anchor_name: ::std::option::Option<::std::string::String>,
    pub(crate) oci_url: ::std::option::Option<::std::string::String>,
    pub(crate) ocid: ::std::option::Option<::std::string::String>,
    pub(crate) shape: ::std::option::Option<::std::string::String>,
    pub(crate) storage_count: ::std::option::Option<i32>,
    pub(crate) storage_server_version: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) total_storage_size_in_gbs: ::std::option::Option<i32>,
    pub(crate) percent_progress: ::std::option::Option<f32>,
    pub(crate) database_server_type: ::std::option::Option<::std::string::String>,
    pub(crate) storage_server_type: ::std::option::Option<::std::string::String>,
    pub(crate) compute_model: ::std::option::Option<crate::types::ComputeModel>,
}
impl CloudExadataInfrastructureBuilder {
    /// <p>The unique identifier for the Exadata infrastructure.</p>
    /// This field is required.
    pub fn cloud_exadata_infrastructure_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the Exadata infrastructure.</p>
    pub fn set_cloud_exadata_infrastructure_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_id = input;
        self
    }
    /// <p>The unique identifier for the Exadata infrastructure.</p>
    pub fn get_cloud_exadata_infrastructure_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_exadata_infrastructure_id
    }
    /// <p>The user-friendly name for the Exadata infrastructure.</p>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The user-friendly name for the Exadata infrastructure.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The user-friendly name for the Exadata infrastructure.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The current status of the Exadata infrastructure.</p>
    pub fn status(mut self, input: crate::types::ResourceStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the Exadata infrastructure.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ResourceStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current status of the Exadata infrastructure.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ResourceStatus> {
        &self.status
    }
    /// <p>Additional information about the status of the Exadata infrastructure.</p>
    pub fn status_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Additional information about the status of the Exadata infrastructure.</p>
    pub fn set_status_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status_reason = input;
        self
    }
    /// <p>Additional information about the status of the Exadata infrastructure.</p>
    pub fn get_status_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.status_reason
    }
    /// <p>The Amazon Resource Name (ARN) for the Exadata infrastructure.</p>
    pub fn cloud_exadata_infrastructure_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the Exadata infrastructure.</p>
    pub fn set_cloud_exadata_infrastructure_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cloud_exadata_infrastructure_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the Exadata infrastructure.</p>
    pub fn get_cloud_exadata_infrastructure_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cloud_exadata_infrastructure_arn
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn activated_storage_count(mut self, input: i32) -> Self {
        self.activated_storage_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn set_activated_storage_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.activated_storage_count = input;
        self
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn get_activated_storage_count(&self) -> &::std::option::Option<i32> {
        &self.activated_storage_count
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn additional_storage_count(mut self, input: i32) -> Self {
        self.additional_storage_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn set_additional_storage_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.additional_storage_count = input;
        self
    }
    /// <p>The number of storage servers requested for the Exadata infrastructure.</p>
    pub fn get_additional_storage_count(&self) -> &::std::option::Option<i32> {
        &self.additional_storage_count
    }
    /// <p>The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.</p>
    pub fn available_storage_size_in_gbs(mut self, input: i32) -> Self {
        self.available_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.</p>
    pub fn set_available_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.available_storage_size_in_gbs = input;
        self
    }
    /// <p>The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.</p>
    pub fn get_available_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.available_storage_size_in_gbs
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    pub fn availability_zone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    pub fn set_availability_zone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone = input;
        self
    }
    /// <p>The name of the Availability Zone (AZ) where the Exadata infrastructure is located.</p>
    pub fn get_availability_zone(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    pub fn availability_zone_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    pub fn set_availability_zone_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone_id = input;
        self
    }
    /// <p>The AZ ID of the AZ where the Exadata infrastructure is located.</p>
    pub fn get_availability_zone_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone_id
    }
    /// <p>The number of database servers for the Exadata infrastructure.</p>
    pub fn compute_count(mut self, input: i32) -> Self {
        self.compute_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of database servers for the Exadata infrastructure.</p>
    pub fn set_compute_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compute_count = input;
        self
    }
    /// <p>The number of database servers for the Exadata infrastructure.</p>
    pub fn get_compute_count(&self) -> &::std::option::Option<i32> {
        &self.compute_count
    }
    /// <p>The total number of CPU cores that are allocated to the Exadata infrastructure.</p>
    pub fn cpu_count(mut self, input: i32) -> Self {
        self.cpu_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of CPU cores that are allocated to the Exadata infrastructure.</p>
    pub fn set_cpu_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cpu_count = input;
        self
    }
    /// <p>The total number of CPU cores that are allocated to the Exadata infrastructure.</p>
    pub fn get_cpu_count(&self) -> &::std::option::Option<i32> {
        &self.cpu_count
    }
    /// Appends an item to `customer_contacts_to_send_to_oci`.
    ///
    /// To override the contents of this collection use [`set_customer_contacts_to_send_to_oci`](Self::set_customer_contacts_to_send_to_oci).
    ///
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub fn customer_contacts_to_send_to_oci(mut self, input: crate::types::CustomerContact) -> Self {
        let mut v = self.customer_contacts_to_send_to_oci.unwrap_or_default();
        v.push(input);
        self.customer_contacts_to_send_to_oci = ::std::option::Option::Some(v);
        self
    }
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub fn set_customer_contacts_to_send_to_oci(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>>) -> Self {
        self.customer_contacts_to_send_to_oci = input;
        self
    }
    /// <p>The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.</p>
    pub fn get_customer_contacts_to_send_to_oci(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CustomerContact>> {
        &self.customer_contacts_to_send_to_oci
    }
    /// <p>The size of the Exadata infrastructure's data disk group, in terabytes (TB).</p>
    pub fn data_storage_size_in_tbs(mut self, input: f64) -> Self {
        self.data_storage_size_in_tbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The size of the Exadata infrastructure's data disk group, in terabytes (TB).</p>
    pub fn set_data_storage_size_in_tbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.data_storage_size_in_tbs = input;
        self
    }
    /// <p>The size of the Exadata infrastructure's data disk group, in terabytes (TB).</p>
    pub fn get_data_storage_size_in_tbs(&self) -> &::std::option::Option<f64> {
        &self.data_storage_size_in_tbs
    }
    /// <p>The size of the Exadata infrastructure's local node storage, in gigabytes (GB).</p>
    pub fn db_node_storage_size_in_gbs(mut self, input: i32) -> Self {
        self.db_node_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The size of the Exadata infrastructure's local node storage, in gigabytes (GB).</p>
    pub fn set_db_node_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.db_node_storage_size_in_gbs = input;
        self
    }
    /// <p>The size of the Exadata infrastructure's local node storage, in gigabytes (GB).</p>
    pub fn get_db_node_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.db_node_storage_size_in_gbs
    }
    /// <p>The software version of the database servers (dom0) in the Exadata infrastructure.</p>
    pub fn db_server_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_server_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The software version of the database servers (dom0) in the Exadata infrastructure.</p>
    pub fn set_db_server_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_server_version = input;
        self
    }
    /// <p>The software version of the database servers (dom0) in the Exadata infrastructure.</p>
    pub fn get_db_server_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_server_version
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.</p>
    pub fn last_maintenance_run_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.last_maintenance_run_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.</p>
    pub fn set_last_maintenance_run_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.last_maintenance_run_id = input;
        self
    }
    /// <p>The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.</p>
    pub fn get_last_maintenance_run_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.last_maintenance_run_id
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn maintenance_window(mut self, input: crate::types::MaintenanceWindow) -> Self {
        self.maintenance_window = ::std::option::Option::Some(input);
        self
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn set_maintenance_window(mut self, input: ::std::option::Option<crate::types::MaintenanceWindow>) -> Self {
        self.maintenance_window = input;
        self
    }
    /// <p>The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.</p>
    pub fn get_maintenance_window(&self) -> &::std::option::Option<crate::types::MaintenanceWindow> {
        &self.maintenance_window
    }
    /// <p>The total number of CPU cores available on the Exadata infrastructure.</p>
    pub fn max_cpu_count(mut self, input: i32) -> Self {
        self.max_cpu_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of CPU cores available on the Exadata infrastructure.</p>
    pub fn set_max_cpu_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_cpu_count = input;
        self
    }
    /// <p>The total number of CPU cores available on the Exadata infrastructure.</p>
    pub fn get_max_cpu_count(&self) -> &::std::option::Option<i32> {
        &self.max_cpu_count
    }
    /// <p>The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.</p>
    pub fn max_data_storage_in_tbs(mut self, input: f64) -> Self {
        self.max_data_storage_in_tbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.</p>
    pub fn set_max_data_storage_in_tbs(mut self, input: ::std::option::Option<f64>) -> Self {
        self.max_data_storage_in_tbs = input;
        self
    }
    /// <p>The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.</p>
    pub fn get_max_data_storage_in_tbs(&self) -> &::std::option::Option<f64> {
        &self.max_data_storage_in_tbs
    }
    /// <p>The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn max_db_node_storage_size_in_gbs(mut self, input: i32) -> Self {
        self.max_db_node_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn set_max_db_node_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_db_node_storage_size_in_gbs = input;
        self
    }
    /// <p>The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn get_max_db_node_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.max_db_node_storage_size_in_gbs
    }
    /// <p>The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn max_memory_in_gbs(mut self, input: i32) -> Self {
        self.max_memory_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn set_max_memory_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_memory_in_gbs = input;
        self
    }
    /// <p>The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.</p>
    pub fn get_max_memory_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.max_memory_in_gbs
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.</p>
    pub fn memory_size_in_gbs(mut self, input: i32) -> Self {
        self.memory_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.</p>
    pub fn set_memory_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.memory_size_in_gbs = input;
        self
    }
    /// <p>The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.</p>
    pub fn get_memory_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.memory_size_in_gbs
    }
    /// <p>The monthly software version of the database servers installed on the Exadata infrastructure.</p>
    pub fn monthly_db_server_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.monthly_db_server_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The monthly software version of the database servers installed on the Exadata infrastructure.</p>
    pub fn set_monthly_db_server_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.monthly_db_server_version = input;
        self
    }
    /// <p>The monthly software version of the database servers installed on the Exadata infrastructure.</p>
    pub fn get_monthly_db_server_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.monthly_db_server_version
    }
    /// <p>The monthly software version of the storage servers installed on the Exadata infrastructure.</p>
    pub fn monthly_storage_server_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.monthly_storage_server_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The monthly software version of the storage servers installed on the Exadata infrastructure.</p>
    pub fn set_monthly_storage_server_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.monthly_storage_server_version = input;
        self
    }
    /// <p>The monthly software version of the storage servers installed on the Exadata infrastructure.</p>
    pub fn get_monthly_storage_server_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.monthly_storage_server_version
    }
    /// <p>The OCID of the next maintenance run for the Exadata infrastructure.</p>
    pub fn next_maintenance_run_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_maintenance_run_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The OCID of the next maintenance run for the Exadata infrastructure.</p>
    pub fn set_next_maintenance_run_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_maintenance_run_id = input;
        self
    }
    /// <p>The OCID of the next maintenance run for the Exadata infrastructure.</p>
    pub fn get_next_maintenance_run_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_maintenance_run_id
    }
    /// <p>The name of the OCI resource anchor for the Exadata infrastructure.</p>
    pub fn oci_resource_anchor_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.oci_resource_anchor_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the OCI resource anchor for the Exadata infrastructure.</p>
    pub fn set_oci_resource_anchor_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.oci_resource_anchor_name = input;
        self
    }
    /// <p>The name of the OCI resource anchor for the Exadata infrastructure.</p>
    pub fn get_oci_resource_anchor_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.oci_resource_anchor_name
    }
    /// <p>The HTTPS link to the Exadata infrastructure in OCI.</p>
    pub fn oci_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.oci_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The HTTPS link to the Exadata infrastructure in OCI.</p>
    pub fn set_oci_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.oci_url = input;
        self
    }
    /// <p>The HTTPS link to the Exadata infrastructure in OCI.</p>
    pub fn get_oci_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.oci_url
    }
    /// <p>The OCID of the Exadata infrastructure.</p>
    pub fn ocid(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ocid = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The OCID of the Exadata infrastructure.</p>
    pub fn set_ocid(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ocid = input;
        self
    }
    /// <p>The OCID of the Exadata infrastructure.</p>
    pub fn get_ocid(&self) -> &::std::option::Option<::std::string::String> {
        &self.ocid
    }
    /// <p>The model name of the Exadata infrastructure.</p>
    pub fn shape(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.shape = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The model name of the Exadata infrastructure.</p>
    pub fn set_shape(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.shape = input;
        self
    }
    /// <p>The model name of the Exadata infrastructure.</p>
    pub fn get_shape(&self) -> &::std::option::Option<::std::string::String> {
        &self.shape
    }
    /// <p>The number of storage servers that are activated for the Exadata infrastructure.</p>
    pub fn storage_count(mut self, input: i32) -> Self {
        self.storage_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of storage servers that are activated for the Exadata infrastructure.</p>
    pub fn set_storage_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.storage_count = input;
        self
    }
    /// <p>The number of storage servers that are activated for the Exadata infrastructure.</p>
    pub fn get_storage_count(&self) -> &::std::option::Option<i32> {
        &self.storage_count
    }
    /// <p>The software version of the storage servers on the Exadata infrastructure.</p>
    pub fn storage_server_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.storage_server_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The software version of the storage servers on the Exadata infrastructure.</p>
    pub fn set_storage_server_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.storage_server_version = input;
        self
    }
    /// <p>The software version of the storage servers on the Exadata infrastructure.</p>
    pub fn get_storage_server_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.storage_server_version
    }
    /// <p>The date and time when the Exadata infrastructure was created.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time when the Exadata infrastructure was created.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The date and time when the Exadata infrastructure was created.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.</p>
    pub fn total_storage_size_in_gbs(mut self, input: i32) -> Self {
        self.total_storage_size_in_gbs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.</p>
    pub fn set_total_storage_size_in_gbs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_storage_size_in_gbs = input;
        self
    }
    /// <p>The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.</p>
    pub fn get_total_storage_size_in_gbs(&self) -> &::std::option::Option<i32> {
        &self.total_storage_size_in_gbs
    }
    /// <p>The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.</p>
    pub fn percent_progress(mut self, input: f32) -> Self {
        self.percent_progress = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.</p>
    pub fn set_percent_progress(mut self, input: ::std::option::Option<f32>) -> Self {
        self.percent_progress = input;
        self
    }
    /// <p>The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.</p>
    pub fn get_percent_progress(&self) -> &::std::option::Option<f32> {
        &self.percent_progress
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn database_server_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database_server_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_database_server_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database_server_type = input;
        self
    }
    /// <p>The database server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_database_server_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.database_server_type
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn storage_server_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.storage_server_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn set_storage_server_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.storage_server_type = input;
        self
    }
    /// <p>The storage server model type of the Exadata infrastructure. For the list of valid model names, use the <code>ListDbSystemShapes</code> operation.</p>
    pub fn get_storage_server_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.storage_server_type
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn compute_model(mut self, input: crate::types::ComputeModel) -> Self {
        self.compute_model = ::std::option::Option::Some(input);
        self
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn set_compute_model(mut self, input: ::std::option::Option<crate::types::ComputeModel>) -> Self {
        self.compute_model = input;
        self
    }
    /// <p>The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.</p>
    pub fn get_compute_model(&self) -> &::std::option::Option<crate::types::ComputeModel> {
        &self.compute_model
    }
    /// Consumes the builder and constructs a [`CloudExadataInfrastructure`](crate::types::CloudExadataInfrastructure).
    /// This method will fail if any of the following fields are not set:
    /// - [`cloud_exadata_infrastructure_id`](crate::types::builders::CloudExadataInfrastructureBuilder::cloud_exadata_infrastructure_id)
    pub fn build(self) -> ::std::result::Result<crate::types::CloudExadataInfrastructure, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::CloudExadataInfrastructure {
            cloud_exadata_infrastructure_id: self.cloud_exadata_infrastructure_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "cloud_exadata_infrastructure_id",
                    "cloud_exadata_infrastructure_id was not specified but it is required when building CloudExadataInfrastructure",
                )
            })?,
            display_name: self.display_name,
            status: self.status,
            status_reason: self.status_reason,
            cloud_exadata_infrastructure_arn: self.cloud_exadata_infrastructure_arn,
            activated_storage_count: self.activated_storage_count,
            additional_storage_count: self.additional_storage_count,
            available_storage_size_in_gbs: self.available_storage_size_in_gbs,
            availability_zone: self.availability_zone,
            availability_zone_id: self.availability_zone_id,
            compute_count: self.compute_count,
            cpu_count: self.cpu_count,
            customer_contacts_to_send_to_oci: self.customer_contacts_to_send_to_oci,
            data_storage_size_in_tbs: self.data_storage_size_in_tbs,
            db_node_storage_size_in_gbs: self.db_node_storage_size_in_gbs,
            db_server_version: self.db_server_version,
            last_maintenance_run_id: self.last_maintenance_run_id,
            maintenance_window: self.maintenance_window,
            max_cpu_count: self.max_cpu_count,
            max_data_storage_in_tbs: self.max_data_storage_in_tbs,
            max_db_node_storage_size_in_gbs: self.max_db_node_storage_size_in_gbs,
            max_memory_in_gbs: self.max_memory_in_gbs,
            memory_size_in_gbs: self.memory_size_in_gbs,
            monthly_db_server_version: self.monthly_db_server_version,
            monthly_storage_server_version: self.monthly_storage_server_version,
            next_maintenance_run_id: self.next_maintenance_run_id,
            oci_resource_anchor_name: self.oci_resource_anchor_name,
            oci_url: self.oci_url,
            ocid: self.ocid,
            shape: self.shape,
            storage_count: self.storage_count,
            storage_server_version: self.storage_server_version,
            created_at: self.created_at,
            total_storage_size_in_gbs: self.total_storage_size_in_gbs,
            percent_progress: self.percent_progress,
            database_server_type: self.database_server_type,
            storage_server_type: self.storage_server_type,
            compute_model: self.compute_model,
        })
    }
}
