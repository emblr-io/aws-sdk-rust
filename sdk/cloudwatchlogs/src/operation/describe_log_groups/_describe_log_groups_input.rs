// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DescribeLogGroupsInput {
    /// <p>When <code>includeLinkedAccounts</code> is set to <code>true</code>, use this parameter to specify the list of accounts to search. You can specify as many as 20 account IDs in the array.</p>
    pub account_identifiers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The prefix to match.</p><note>
    /// <p><code>logGroupNamePrefix</code> and <code>logGroupNamePattern</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub log_group_name_prefix: ::std::option::Option<::std::string::String>,
    /// <p>If you specify a string for this parameter, the operation returns only log groups that have names that match the string based on a case-sensitive substring search. For example, if you specify <code>Foo</code>, log groups named <code>FooBar</code>, <code>aws/Foo</code>, and <code>GroupFoo</code> would match, but <code>foo</code>, <code>F/o/o</code> and <code>Froo</code> would not match.</p>
    /// <p>If you specify <code>logGroupNamePattern</code> in your request, then only <code>arn</code>, <code>creationTime</code>, and <code>logGroupName</code> are included in the response.</p><note>
    /// <p><code>logGroupNamePattern</code> and <code>logGroupNamePrefix</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub log_group_name_pattern: ::std::option::Option<::std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: ::std::option::Option<i32>,
    /// <p>If you are using a monitoring account, set this to <code>true</code> to have the operation return log groups in the accounts listed in <code>accountIdentifiers</code>.</p>
    /// <p>If this parameter is set to <code>true</code> and <code>accountIdentifiers</code> contains a null value, the operation returns all log groups in the monitoring account and all log groups in all source accounts that are linked to the monitoring account.</p>
    /// <p>The default for this parameter is <code>false</code>.</p>
    pub include_linked_accounts: ::std::option::Option<bool>,
    /// <p>Use this parameter to limit the results to only those log groups in the specified log group class. If you omit this parameter, log groups of all classes can be returned.</p>
    /// <p>Specifies the log group class for this log group. There are three classes:</p>
    /// <ul>
    /// <li>
    /// <p>The <code>Standard</code> log class supports all CloudWatch Logs features.</p></li>
    /// <li>
    /// <p>The <code>Infrequent Access</code> log class supports a subset of CloudWatch Logs features and incurs lower costs.</p></li>
    /// <li>
    /// <p>Use the <code>Delivery</code> log class only for delivering Lambda logs to store in Amazon S3 or Amazon Data Firehose. Log events in log groups in the Delivery class are kept in CloudWatch Logs for only one day. This log class doesn't offer rich CloudWatch Logs capabilities such as CloudWatch Logs Insights queries.</p></li>
    /// </ul>
    /// <p>For details about the features supported by each class, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html">Log classes</a></p>
    pub log_group_class: ::std::option::Option<crate::types::LogGroupClass>,
    /// <p>Use this array to filter the list of log groups returned. If you specify this parameter, the only other filter that you can choose to specify is <code>includeLinkedAccounts</code>.</p>
    /// <p>If you are using this operation in a monitoring account, you can specify the ARNs of log groups in source accounts and in the monitoring account itself. If you are using this operation in an account that is not a cross-account monitoring account, you can specify only log group names in the same account as the operation.</p>
    pub log_group_identifiers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl DescribeLogGroupsInput {
    /// <p>When <code>includeLinkedAccounts</code> is set to <code>true</code>, use this parameter to specify the list of accounts to search. You can specify as many as 20 account IDs in the array.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.account_identifiers.is_none()`.
    pub fn account_identifiers(&self) -> &[::std::string::String] {
        self.account_identifiers.as_deref().unwrap_or_default()
    }
    /// <p>The prefix to match.</p><note>
    /// <p><code>logGroupNamePrefix</code> and <code>logGroupNamePattern</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn log_group_name_prefix(&self) -> ::std::option::Option<&str> {
        self.log_group_name_prefix.as_deref()
    }
    /// <p>If you specify a string for this parameter, the operation returns only log groups that have names that match the string based on a case-sensitive substring search. For example, if you specify <code>Foo</code>, log groups named <code>FooBar</code>, <code>aws/Foo</code>, and <code>GroupFoo</code> would match, but <code>foo</code>, <code>F/o/o</code> and <code>Froo</code> would not match.</p>
    /// <p>If you specify <code>logGroupNamePattern</code> in your request, then only <code>arn</code>, <code>creationTime</code>, and <code>logGroupName</code> are included in the response.</p><note>
    /// <p><code>logGroupNamePattern</code> and <code>logGroupNamePrefix</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn log_group_name_pattern(&self) -> ::std::option::Option<&str> {
        self.log_group_name_pattern.as_deref()
    }
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub fn limit(&self) -> ::std::option::Option<i32> {
        self.limit
    }
    /// <p>If you are using a monitoring account, set this to <code>true</code> to have the operation return log groups in the accounts listed in <code>accountIdentifiers</code>.</p>
    /// <p>If this parameter is set to <code>true</code> and <code>accountIdentifiers</code> contains a null value, the operation returns all log groups in the monitoring account and all log groups in all source accounts that are linked to the monitoring account.</p>
    /// <p>The default for this parameter is <code>false</code>.</p>
    pub fn include_linked_accounts(&self) -> ::std::option::Option<bool> {
        self.include_linked_accounts
    }
    /// <p>Use this parameter to limit the results to only those log groups in the specified log group class. If you omit this parameter, log groups of all classes can be returned.</p>
    /// <p>Specifies the log group class for this log group. There are three classes:</p>
    /// <ul>
    /// <li>
    /// <p>The <code>Standard</code> log class supports all CloudWatch Logs features.</p></li>
    /// <li>
    /// <p>The <code>Infrequent Access</code> log class supports a subset of CloudWatch Logs features and incurs lower costs.</p></li>
    /// <li>
    /// <p>Use the <code>Delivery</code> log class only for delivering Lambda logs to store in Amazon S3 or Amazon Data Firehose. Log events in log groups in the Delivery class are kept in CloudWatch Logs for only one day. This log class doesn't offer rich CloudWatch Logs capabilities such as CloudWatch Logs Insights queries.</p></li>
    /// </ul>
    /// <p>For details about the features supported by each class, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html">Log classes</a></p>
    pub fn log_group_class(&self) -> ::std::option::Option<&crate::types::LogGroupClass> {
        self.log_group_class.as_ref()
    }
    /// <p>Use this array to filter the list of log groups returned. If you specify this parameter, the only other filter that you can choose to specify is <code>includeLinkedAccounts</code>.</p>
    /// <p>If you are using this operation in a monitoring account, you can specify the ARNs of log groups in source accounts and in the monitoring account itself. If you are using this operation in an account that is not a cross-account monitoring account, you can specify only log group names in the same account as the operation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.log_group_identifiers.is_none()`.
    pub fn log_group_identifiers(&self) -> &[::std::string::String] {
        self.log_group_identifiers.as_deref().unwrap_or_default()
    }
}
impl DescribeLogGroupsInput {
    /// Creates a new builder-style object to manufacture [`DescribeLogGroupsInput`](crate::operation::describe_log_groups::DescribeLogGroupsInput).
    pub fn builder() -> crate::operation::describe_log_groups::builders::DescribeLogGroupsInputBuilder {
        crate::operation::describe_log_groups::builders::DescribeLogGroupsInputBuilder::default()
    }
}

/// A builder for [`DescribeLogGroupsInput`](crate::operation::describe_log_groups::DescribeLogGroupsInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct DescribeLogGroupsInputBuilder {
    pub(crate) account_identifiers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) log_group_name_prefix: ::std::option::Option<::std::string::String>,
    pub(crate) log_group_name_pattern: ::std::option::Option<::std::string::String>,
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
    pub(crate) limit: ::std::option::Option<i32>,
    pub(crate) include_linked_accounts: ::std::option::Option<bool>,
    pub(crate) log_group_class: ::std::option::Option<crate::types::LogGroupClass>,
    pub(crate) log_group_identifiers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl DescribeLogGroupsInputBuilder {
    /// Appends an item to `account_identifiers`.
    ///
    /// To override the contents of this collection use [`set_account_identifiers`](Self::set_account_identifiers).
    ///
    /// <p>When <code>includeLinkedAccounts</code> is set to <code>true</code>, use this parameter to specify the list of accounts to search. You can specify as many as 20 account IDs in the array.</p>
    pub fn account_identifiers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.account_identifiers.unwrap_or_default();
        v.push(input.into());
        self.account_identifiers = ::std::option::Option::Some(v);
        self
    }
    /// <p>When <code>includeLinkedAccounts</code> is set to <code>true</code>, use this parameter to specify the list of accounts to search. You can specify as many as 20 account IDs in the array.</p>
    pub fn set_account_identifiers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.account_identifiers = input;
        self
    }
    /// <p>When <code>includeLinkedAccounts</code> is set to <code>true</code>, use this parameter to specify the list of accounts to search. You can specify as many as 20 account IDs in the array.</p>
    pub fn get_account_identifiers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.account_identifiers
    }
    /// <p>The prefix to match.</p><note>
    /// <p><code>logGroupNamePrefix</code> and <code>logGroupNamePattern</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn log_group_name_prefix(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.log_group_name_prefix = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The prefix to match.</p><note>
    /// <p><code>logGroupNamePrefix</code> and <code>logGroupNamePattern</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn set_log_group_name_prefix(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.log_group_name_prefix = input;
        self
    }
    /// <p>The prefix to match.</p><note>
    /// <p><code>logGroupNamePrefix</code> and <code>logGroupNamePattern</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn get_log_group_name_prefix(&self) -> &::std::option::Option<::std::string::String> {
        &self.log_group_name_prefix
    }
    /// <p>If you specify a string for this parameter, the operation returns only log groups that have names that match the string based on a case-sensitive substring search. For example, if you specify <code>Foo</code>, log groups named <code>FooBar</code>, <code>aws/Foo</code>, and <code>GroupFoo</code> would match, but <code>foo</code>, <code>F/o/o</code> and <code>Froo</code> would not match.</p>
    /// <p>If you specify <code>logGroupNamePattern</code> in your request, then only <code>arn</code>, <code>creationTime</code>, and <code>logGroupName</code> are included in the response.</p><note>
    /// <p><code>logGroupNamePattern</code> and <code>logGroupNamePrefix</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn log_group_name_pattern(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.log_group_name_pattern = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If you specify a string for this parameter, the operation returns only log groups that have names that match the string based on a case-sensitive substring search. For example, if you specify <code>Foo</code>, log groups named <code>FooBar</code>, <code>aws/Foo</code>, and <code>GroupFoo</code> would match, but <code>foo</code>, <code>F/o/o</code> and <code>Froo</code> would not match.</p>
    /// <p>If you specify <code>logGroupNamePattern</code> in your request, then only <code>arn</code>, <code>creationTime</code>, and <code>logGroupName</code> are included in the response.</p><note>
    /// <p><code>logGroupNamePattern</code> and <code>logGroupNamePrefix</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn set_log_group_name_pattern(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.log_group_name_pattern = input;
        self
    }
    /// <p>If you specify a string for this parameter, the operation returns only log groups that have names that match the string based on a case-sensitive substring search. For example, if you specify <code>Foo</code>, log groups named <code>FooBar</code>, <code>aws/Foo</code>, and <code>GroupFoo</code> would match, but <code>foo</code>, <code>F/o/o</code> and <code>Froo</code> would not match.</p>
    /// <p>If you specify <code>logGroupNamePattern</code> in your request, then only <code>arn</code>, <code>creationTime</code>, and <code>logGroupName</code> are included in the response.</p><note>
    /// <p><code>logGroupNamePattern</code> and <code>logGroupNamePrefix</code> are mutually exclusive. Only one of these parameters can be passed.</p>
    /// </note>
    pub fn get_log_group_name_pattern(&self) -> &::std::option::Option<::std::string::String> {
        &self.log_group_name_pattern
    }
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub fn limit(mut self, input: i32) -> Self {
        self.limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub fn set_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.limit = input;
        self
    }
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub fn get_limit(&self) -> &::std::option::Option<i32> {
        &self.limit
    }
    /// <p>If you are using a monitoring account, set this to <code>true</code> to have the operation return log groups in the accounts listed in <code>accountIdentifiers</code>.</p>
    /// <p>If this parameter is set to <code>true</code> and <code>accountIdentifiers</code> contains a null value, the operation returns all log groups in the monitoring account and all log groups in all source accounts that are linked to the monitoring account.</p>
    /// <p>The default for this parameter is <code>false</code>.</p>
    pub fn include_linked_accounts(mut self, input: bool) -> Self {
        self.include_linked_accounts = ::std::option::Option::Some(input);
        self
    }
    /// <p>If you are using a monitoring account, set this to <code>true</code> to have the operation return log groups in the accounts listed in <code>accountIdentifiers</code>.</p>
    /// <p>If this parameter is set to <code>true</code> and <code>accountIdentifiers</code> contains a null value, the operation returns all log groups in the monitoring account and all log groups in all source accounts that are linked to the monitoring account.</p>
    /// <p>The default for this parameter is <code>false</code>.</p>
    pub fn set_include_linked_accounts(mut self, input: ::std::option::Option<bool>) -> Self {
        self.include_linked_accounts = input;
        self
    }
    /// <p>If you are using a monitoring account, set this to <code>true</code> to have the operation return log groups in the accounts listed in <code>accountIdentifiers</code>.</p>
    /// <p>If this parameter is set to <code>true</code> and <code>accountIdentifiers</code> contains a null value, the operation returns all log groups in the monitoring account and all log groups in all source accounts that are linked to the monitoring account.</p>
    /// <p>The default for this parameter is <code>false</code>.</p>
    pub fn get_include_linked_accounts(&self) -> &::std::option::Option<bool> {
        &self.include_linked_accounts
    }
    /// <p>Use this parameter to limit the results to only those log groups in the specified log group class. If you omit this parameter, log groups of all classes can be returned.</p>
    /// <p>Specifies the log group class for this log group. There are three classes:</p>
    /// <ul>
    /// <li>
    /// <p>The <code>Standard</code> log class supports all CloudWatch Logs features.</p></li>
    /// <li>
    /// <p>The <code>Infrequent Access</code> log class supports a subset of CloudWatch Logs features and incurs lower costs.</p></li>
    /// <li>
    /// <p>Use the <code>Delivery</code> log class only for delivering Lambda logs to store in Amazon S3 or Amazon Data Firehose. Log events in log groups in the Delivery class are kept in CloudWatch Logs for only one day. This log class doesn't offer rich CloudWatch Logs capabilities such as CloudWatch Logs Insights queries.</p></li>
    /// </ul>
    /// <p>For details about the features supported by each class, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html">Log classes</a></p>
    pub fn log_group_class(mut self, input: crate::types::LogGroupClass) -> Self {
        self.log_group_class = ::std::option::Option::Some(input);
        self
    }
    /// <p>Use this parameter to limit the results to only those log groups in the specified log group class. If you omit this parameter, log groups of all classes can be returned.</p>
    /// <p>Specifies the log group class for this log group. There are three classes:</p>
    /// <ul>
    /// <li>
    /// <p>The <code>Standard</code> log class supports all CloudWatch Logs features.</p></li>
    /// <li>
    /// <p>The <code>Infrequent Access</code> log class supports a subset of CloudWatch Logs features and incurs lower costs.</p></li>
    /// <li>
    /// <p>Use the <code>Delivery</code> log class only for delivering Lambda logs to store in Amazon S3 or Amazon Data Firehose. Log events in log groups in the Delivery class are kept in CloudWatch Logs for only one day. This log class doesn't offer rich CloudWatch Logs capabilities such as CloudWatch Logs Insights queries.</p></li>
    /// </ul>
    /// <p>For details about the features supported by each class, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html">Log classes</a></p>
    pub fn set_log_group_class(mut self, input: ::std::option::Option<crate::types::LogGroupClass>) -> Self {
        self.log_group_class = input;
        self
    }
    /// <p>Use this parameter to limit the results to only those log groups in the specified log group class. If you omit this parameter, log groups of all classes can be returned.</p>
    /// <p>Specifies the log group class for this log group. There are three classes:</p>
    /// <ul>
    /// <li>
    /// <p>The <code>Standard</code> log class supports all CloudWatch Logs features.</p></li>
    /// <li>
    /// <p>The <code>Infrequent Access</code> log class supports a subset of CloudWatch Logs features and incurs lower costs.</p></li>
    /// <li>
    /// <p>Use the <code>Delivery</code> log class only for delivering Lambda logs to store in Amazon S3 or Amazon Data Firehose. Log events in log groups in the Delivery class are kept in CloudWatch Logs for only one day. This log class doesn't offer rich CloudWatch Logs capabilities such as CloudWatch Logs Insights queries.</p></li>
    /// </ul>
    /// <p>For details about the features supported by each class, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html">Log classes</a></p>
    pub fn get_log_group_class(&self) -> &::std::option::Option<crate::types::LogGroupClass> {
        &self.log_group_class
    }
    /// Appends an item to `log_group_identifiers`.
    ///
    /// To override the contents of this collection use [`set_log_group_identifiers`](Self::set_log_group_identifiers).
    ///
    /// <p>Use this array to filter the list of log groups returned. If you specify this parameter, the only other filter that you can choose to specify is <code>includeLinkedAccounts</code>.</p>
    /// <p>If you are using this operation in a monitoring account, you can specify the ARNs of log groups in source accounts and in the monitoring account itself. If you are using this operation in an account that is not a cross-account monitoring account, you can specify only log group names in the same account as the operation.</p>
    pub fn log_group_identifiers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.log_group_identifiers.unwrap_or_default();
        v.push(input.into());
        self.log_group_identifiers = ::std::option::Option::Some(v);
        self
    }
    /// <p>Use this array to filter the list of log groups returned. If you specify this parameter, the only other filter that you can choose to specify is <code>includeLinkedAccounts</code>.</p>
    /// <p>If you are using this operation in a monitoring account, you can specify the ARNs of log groups in source accounts and in the monitoring account itself. If you are using this operation in an account that is not a cross-account monitoring account, you can specify only log group names in the same account as the operation.</p>
    pub fn set_log_group_identifiers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.log_group_identifiers = input;
        self
    }
    /// <p>Use this array to filter the list of log groups returned. If you specify this parameter, the only other filter that you can choose to specify is <code>includeLinkedAccounts</code>.</p>
    /// <p>If you are using this operation in a monitoring account, you can specify the ARNs of log groups in source accounts and in the monitoring account itself. If you are using this operation in an account that is not a cross-account monitoring account, you can specify only log group names in the same account as the operation.</p>
    pub fn get_log_group_identifiers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.log_group_identifiers
    }
    /// Consumes the builder and constructs a [`DescribeLogGroupsInput`](crate::operation::describe_log_groups::DescribeLogGroupsInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::describe_log_groups::DescribeLogGroupsInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::describe_log_groups::DescribeLogGroupsInput {
            account_identifiers: self.account_identifiers,
            log_group_name_prefix: self.log_group_name_prefix,
            log_group_name_pattern: self.log_group_name_pattern,
            next_token: self.next_token,
            limit: self.limit,
            include_linked_accounts: self.include_linked_accounts,
            log_group_class: self.log_group_class,
            log_group_identifiers: self.log_group_identifiers,
        })
    }
}
