// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct GetCampaignOutput {
    /// <p>The name of the campaign.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The description of the campaign.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of a signal catalog.</p>
    pub signal_catalog_arn: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the vehicle or the fleet targeted by the campaign.</p>
    pub target_arn: ::std::option::Option<::std::string::String>,
    /// <p>The state of the campaign. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, and <code>SUSPENDED</code>.</p>
    pub status: ::std::option::Option<crate::types::CampaignStatus>,
    /// <p>The time, in milliseconds, to deliver a campaign after it was approved.</p>
    pub start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.</p>
    pub expiry_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>How long (in seconds) to collect raw data after a triggering event initiates the collection.</p>
    pub post_trigger_collection_duration: ::std::option::Option<i64>,
    /// <p>Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.</p>
    pub diagnostics_mode: ::std::option::Option<crate::types::DiagnosticsMode>,
    /// <p>Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.</p>
    pub spooling_mode: ::std::option::Option<crate::types::SpoolingMode>,
    /// <p>Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If <code>OFF</code> is specified, the signals aren't compressed. If it's not specified, <code>SNAPPY</code> is used.</p>
    pub compression: ::std::option::Option<crate::types::Compression>,
    /// <p>A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.</p>
    pub priority: ::std::option::Option<i32>,
    /// <p>Information about a list of signals to collect data on.</p>
    pub signals_to_collect: ::std::option::Option<::std::vec::Vec<crate::types::SignalInformation>>,
    /// <p>Information about the data collection scheme associated with the campaign.</p>
    pub collection_scheme: ::std::option::Option<crate::types::CollectionScheme>,
    /// <p>A list of vehicle attributes associated with the campaign.</p>
    pub data_extra_dimensions: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The last time the campaign was modified.</p>
    pub last_modification_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream.</p>
    /// <p>MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices.</p>
    /// <p>Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics.</p>
    /// <p>You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.</p>
    pub data_destination_configs: ::std::option::Option<::std::vec::Vec<crate::types::DataDestinationConfig>>,
    /// <p>The data partitions associated with the signals collected from the vehicle.</p>
    pub data_partitions: ::std::option::Option<::std::vec::Vec<crate::types::DataPartition>>,
    /// <p>Information about a list of signals to fetch data from.</p>
    pub signals_to_fetch: ::std::option::Option<::std::vec::Vec<crate::types::SignalFetchInformation>>,
    _request_id: Option<String>,
}
impl GetCampaignOutput {
    /// <p>The name of the campaign.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The description of the campaign.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ARN of a signal catalog.</p>
    pub fn signal_catalog_arn(&self) -> ::std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>The ARN of the vehicle or the fleet targeted by the campaign.</p>
    pub fn target_arn(&self) -> ::std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The state of the campaign. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, and <code>SUSPENDED</code>.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::CampaignStatus> {
        self.status.as_ref()
    }
    /// <p>The time, in milliseconds, to deliver a campaign after it was approved.</p>
    pub fn start_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.</p>
    pub fn expiry_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.expiry_time.as_ref()
    }
    /// <p>How long (in seconds) to collect raw data after a triggering event initiates the collection.</p>
    pub fn post_trigger_collection_duration(&self) -> ::std::option::Option<i64> {
        self.post_trigger_collection_duration
    }
    /// <p>Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.</p>
    pub fn diagnostics_mode(&self) -> ::std::option::Option<&crate::types::DiagnosticsMode> {
        self.diagnostics_mode.as_ref()
    }
    /// <p>Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.</p>
    pub fn spooling_mode(&self) -> ::std::option::Option<&crate::types::SpoolingMode> {
        self.spooling_mode.as_ref()
    }
    /// <p>Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If <code>OFF</code> is specified, the signals aren't compressed. If it's not specified, <code>SNAPPY</code> is used.</p>
    pub fn compression(&self) -> ::std::option::Option<&crate::types::Compression> {
        self.compression.as_ref()
    }
    /// <p>A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.</p>
    pub fn priority(&self) -> ::std::option::Option<i32> {
        self.priority
    }
    /// <p>Information about a list of signals to collect data on.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.signals_to_collect.is_none()`.
    pub fn signals_to_collect(&self) -> &[crate::types::SignalInformation] {
        self.signals_to_collect.as_deref().unwrap_or_default()
    }
    /// <p>Information about the data collection scheme associated with the campaign.</p>
    pub fn collection_scheme(&self) -> ::std::option::Option<&crate::types::CollectionScheme> {
        self.collection_scheme.as_ref()
    }
    /// <p>A list of vehicle attributes associated with the campaign.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.data_extra_dimensions.is_none()`.
    pub fn data_extra_dimensions(&self) -> &[::std::string::String] {
        self.data_extra_dimensions.as_deref().unwrap_or_default()
    }
    /// <p>The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn creation_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the campaign was modified.</p>
    pub fn last_modification_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
    /// <p>The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream.</p>
    /// <p>MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices.</p>
    /// <p>Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics.</p>
    /// <p>You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.data_destination_configs.is_none()`.
    pub fn data_destination_configs(&self) -> &[crate::types::DataDestinationConfig] {
        self.data_destination_configs.as_deref().unwrap_or_default()
    }
    /// <p>The data partitions associated with the signals collected from the vehicle.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.data_partitions.is_none()`.
    pub fn data_partitions(&self) -> &[crate::types::DataPartition] {
        self.data_partitions.as_deref().unwrap_or_default()
    }
    /// <p>Information about a list of signals to fetch data from.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.signals_to_fetch.is_none()`.
    pub fn signals_to_fetch(&self) -> &[crate::types::SignalFetchInformation] {
        self.signals_to_fetch.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for GetCampaignOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("GetCampaignOutput");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("signal_catalog_arn", &self.signal_catalog_arn);
        formatter.field("target_arn", &self.target_arn);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("expiry_time", &self.expiry_time);
        formatter.field("post_trigger_collection_duration", &self.post_trigger_collection_duration);
        formatter.field("diagnostics_mode", &self.diagnostics_mode);
        formatter.field("spooling_mode", &self.spooling_mode);
        formatter.field("compression", &self.compression);
        formatter.field("priority", &self.priority);
        formatter.field("signals_to_collect", &"*** Sensitive Data Redacted ***");
        formatter.field("collection_scheme", &self.collection_scheme);
        formatter.field("data_extra_dimensions", &"*** Sensitive Data Redacted ***");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modification_time", &self.last_modification_time);
        formatter.field("data_destination_configs", &self.data_destination_configs);
        formatter.field("data_partitions", &self.data_partitions);
        formatter.field("signals_to_fetch", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl ::aws_types::request_id::RequestId for GetCampaignOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetCampaignOutput {
    /// Creates a new builder-style object to manufacture [`GetCampaignOutput`](crate::operation::get_campaign::GetCampaignOutput).
    pub fn builder() -> crate::operation::get_campaign::builders::GetCampaignOutputBuilder {
        crate::operation::get_campaign::builders::GetCampaignOutputBuilder::default()
    }
}

/// A builder for [`GetCampaignOutput`](crate::operation::get_campaign::GetCampaignOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct GetCampaignOutputBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) signal_catalog_arn: ::std::option::Option<::std::string::String>,
    pub(crate) target_arn: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::CampaignStatus>,
    pub(crate) start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) expiry_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) post_trigger_collection_duration: ::std::option::Option<i64>,
    pub(crate) diagnostics_mode: ::std::option::Option<crate::types::DiagnosticsMode>,
    pub(crate) spooling_mode: ::std::option::Option<crate::types::SpoolingMode>,
    pub(crate) compression: ::std::option::Option<crate::types::Compression>,
    pub(crate) priority: ::std::option::Option<i32>,
    pub(crate) signals_to_collect: ::std::option::Option<::std::vec::Vec<crate::types::SignalInformation>>,
    pub(crate) collection_scheme: ::std::option::Option<crate::types::CollectionScheme>,
    pub(crate) data_extra_dimensions: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_modification_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) data_destination_configs: ::std::option::Option<::std::vec::Vec<crate::types::DataDestinationConfig>>,
    pub(crate) data_partitions: ::std::option::Option<::std::vec::Vec<crate::types::DataPartition>>,
    pub(crate) signals_to_fetch: ::std::option::Option<::std::vec::Vec<crate::types::SignalFetchInformation>>,
    _request_id: Option<String>,
}
impl GetCampaignOutputBuilder {
    /// <p>The name of the campaign.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the campaign.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the campaign.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The description of the campaign.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the campaign.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the campaign.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The ARN of a signal catalog.</p>
    pub fn signal_catalog_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.signal_catalog_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of a signal catalog.</p>
    pub fn set_signal_catalog_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.signal_catalog_arn = input;
        self
    }
    /// <p>The ARN of a signal catalog.</p>
    pub fn get_signal_catalog_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.signal_catalog_arn
    }
    /// <p>The ARN of the vehicle or the fleet targeted by the campaign.</p>
    pub fn target_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.target_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the vehicle or the fleet targeted by the campaign.</p>
    pub fn set_target_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.target_arn = input;
        self
    }
    /// <p>The ARN of the vehicle or the fleet targeted by the campaign.</p>
    pub fn get_target_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.target_arn
    }
    /// <p>The state of the campaign. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, and <code>SUSPENDED</code>.</p>
    pub fn status(mut self, input: crate::types::CampaignStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of the campaign. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, and <code>SUSPENDED</code>.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::CampaignStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The state of the campaign. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, and <code>SUSPENDED</code>.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::CampaignStatus> {
        &self.status
    }
    /// <p>The time, in milliseconds, to deliver a campaign after it was approved.</p>
    pub fn start_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time, in milliseconds, to deliver a campaign after it was approved.</p>
    pub fn set_start_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The time, in milliseconds, to deliver a campaign after it was approved.</p>
    pub fn get_start_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.start_time
    }
    /// <p>The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.</p>
    pub fn expiry_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.expiry_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.</p>
    pub fn set_expiry_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.expiry_time = input;
        self
    }
    /// <p>The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.</p>
    pub fn get_expiry_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.expiry_time
    }
    /// <p>How long (in seconds) to collect raw data after a triggering event initiates the collection.</p>
    pub fn post_trigger_collection_duration(mut self, input: i64) -> Self {
        self.post_trigger_collection_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>How long (in seconds) to collect raw data after a triggering event initiates the collection.</p>
    pub fn set_post_trigger_collection_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.post_trigger_collection_duration = input;
        self
    }
    /// <p>How long (in seconds) to collect raw data after a triggering event initiates the collection.</p>
    pub fn get_post_trigger_collection_duration(&self) -> &::std::option::Option<i64> {
        &self.post_trigger_collection_duration
    }
    /// <p>Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.</p>
    pub fn diagnostics_mode(mut self, input: crate::types::DiagnosticsMode) -> Self {
        self.diagnostics_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.</p>
    pub fn set_diagnostics_mode(mut self, input: ::std::option::Option<crate::types::DiagnosticsMode>) -> Self {
        self.diagnostics_mode = input;
        self
    }
    /// <p>Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.</p>
    pub fn get_diagnostics_mode(&self) -> &::std::option::Option<crate::types::DiagnosticsMode> {
        &self.diagnostics_mode
    }
    /// <p>Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.</p>
    pub fn spooling_mode(mut self, input: crate::types::SpoolingMode) -> Self {
        self.spooling_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.</p>
    pub fn set_spooling_mode(mut self, input: ::std::option::Option<crate::types::SpoolingMode>) -> Self {
        self.spooling_mode = input;
        self
    }
    /// <p>Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.</p>
    pub fn get_spooling_mode(&self) -> &::std::option::Option<crate::types::SpoolingMode> {
        &self.spooling_mode
    }
    /// <p>Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If <code>OFF</code> is specified, the signals aren't compressed. If it's not specified, <code>SNAPPY</code> is used.</p>
    pub fn compression(mut self, input: crate::types::Compression) -> Self {
        self.compression = ::std::option::Option::Some(input);
        self
    }
    /// <p>Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If <code>OFF</code> is specified, the signals aren't compressed. If it's not specified, <code>SNAPPY</code> is used.</p>
    pub fn set_compression(mut self, input: ::std::option::Option<crate::types::Compression>) -> Self {
        self.compression = input;
        self
    }
    /// <p>Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If <code>OFF</code> is specified, the signals aren't compressed. If it's not specified, <code>SNAPPY</code> is used.</p>
    pub fn get_compression(&self) -> &::std::option::Option<crate::types::Compression> {
        &self.compression
    }
    /// <p>A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.</p>
    pub fn set_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.priority = input;
        self
    }
    /// <p>A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.</p>
    pub fn get_priority(&self) -> &::std::option::Option<i32> {
        &self.priority
    }
    /// Appends an item to `signals_to_collect`.
    ///
    /// To override the contents of this collection use [`set_signals_to_collect`](Self::set_signals_to_collect).
    ///
    /// <p>Information about a list of signals to collect data on.</p>
    pub fn signals_to_collect(mut self, input: crate::types::SignalInformation) -> Self {
        let mut v = self.signals_to_collect.unwrap_or_default();
        v.push(input);
        self.signals_to_collect = ::std::option::Option::Some(v);
        self
    }
    /// <p>Information about a list of signals to collect data on.</p>
    pub fn set_signals_to_collect(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::SignalInformation>>) -> Self {
        self.signals_to_collect = input;
        self
    }
    /// <p>Information about a list of signals to collect data on.</p>
    pub fn get_signals_to_collect(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SignalInformation>> {
        &self.signals_to_collect
    }
    /// <p>Information about the data collection scheme associated with the campaign.</p>
    pub fn collection_scheme(mut self, input: crate::types::CollectionScheme) -> Self {
        self.collection_scheme = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the data collection scheme associated with the campaign.</p>
    pub fn set_collection_scheme(mut self, input: ::std::option::Option<crate::types::CollectionScheme>) -> Self {
        self.collection_scheme = input;
        self
    }
    /// <p>Information about the data collection scheme associated with the campaign.</p>
    pub fn get_collection_scheme(&self) -> &::std::option::Option<crate::types::CollectionScheme> {
        &self.collection_scheme
    }
    /// Appends an item to `data_extra_dimensions`.
    ///
    /// To override the contents of this collection use [`set_data_extra_dimensions`](Self::set_data_extra_dimensions).
    ///
    /// <p>A list of vehicle attributes associated with the campaign.</p>
    pub fn data_extra_dimensions(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.data_extra_dimensions.unwrap_or_default();
        v.push(input.into());
        self.data_extra_dimensions = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of vehicle attributes associated with the campaign.</p>
    pub fn set_data_extra_dimensions(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.data_extra_dimensions = input;
        self
    }
    /// <p>A list of vehicle attributes associated with the campaign.</p>
    pub fn get_data_extra_dimensions(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.data_extra_dimensions
    }
    /// <p>The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn creation_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.creation_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn set_creation_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.creation_time = input;
        self
    }
    /// <p>The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn get_creation_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.creation_time
    }
    /// <p>The last time the campaign was modified.</p>
    pub fn last_modification_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_modification_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The last time the campaign was modified.</p>
    pub fn set_last_modification_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_modification_time = input;
        self
    }
    /// <p>The last time the campaign was modified.</p>
    pub fn get_last_modification_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_modification_time
    }
    /// Appends an item to `data_destination_configs`.
    ///
    /// To override the contents of this collection use [`set_data_destination_configs`](Self::set_data_destination_configs).
    ///
    /// <p>The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream.</p>
    /// <p>MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices.</p>
    /// <p>Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics.</p>
    /// <p>You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.</p>
    pub fn data_destination_configs(mut self, input: crate::types::DataDestinationConfig) -> Self {
        let mut v = self.data_destination_configs.unwrap_or_default();
        v.push(input);
        self.data_destination_configs = ::std::option::Option::Some(v);
        self
    }
    /// <p>The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream.</p>
    /// <p>MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices.</p>
    /// <p>Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics.</p>
    /// <p>You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.</p>
    pub fn set_data_destination_configs(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DataDestinationConfig>>) -> Self {
        self.data_destination_configs = input;
        self
    }
    /// <p>The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream.</p>
    /// <p>MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices.</p>
    /// <p>Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics.</p>
    /// <p>You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.</p>
    pub fn get_data_destination_configs(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataDestinationConfig>> {
        &self.data_destination_configs
    }
    /// Appends an item to `data_partitions`.
    ///
    /// To override the contents of this collection use [`set_data_partitions`](Self::set_data_partitions).
    ///
    /// <p>The data partitions associated with the signals collected from the vehicle.</p>
    pub fn data_partitions(mut self, input: crate::types::DataPartition) -> Self {
        let mut v = self.data_partitions.unwrap_or_default();
        v.push(input);
        self.data_partitions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The data partitions associated with the signals collected from the vehicle.</p>
    pub fn set_data_partitions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DataPartition>>) -> Self {
        self.data_partitions = input;
        self
    }
    /// <p>The data partitions associated with the signals collected from the vehicle.</p>
    pub fn get_data_partitions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataPartition>> {
        &self.data_partitions
    }
    /// Appends an item to `signals_to_fetch`.
    ///
    /// To override the contents of this collection use [`set_signals_to_fetch`](Self::set_signals_to_fetch).
    ///
    /// <p>Information about a list of signals to fetch data from.</p>
    pub fn signals_to_fetch(mut self, input: crate::types::SignalFetchInformation) -> Self {
        let mut v = self.signals_to_fetch.unwrap_or_default();
        v.push(input);
        self.signals_to_fetch = ::std::option::Option::Some(v);
        self
    }
    /// <p>Information about a list of signals to fetch data from.</p>
    pub fn set_signals_to_fetch(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::SignalFetchInformation>>) -> Self {
        self.signals_to_fetch = input;
        self
    }
    /// <p>Information about a list of signals to fetch data from.</p>
    pub fn get_signals_to_fetch(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SignalFetchInformation>> {
        &self.signals_to_fetch
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetCampaignOutput`](crate::operation::get_campaign::GetCampaignOutput).
    pub fn build(self) -> crate::operation::get_campaign::GetCampaignOutput {
        crate::operation::get_campaign::GetCampaignOutput {
            name: self.name,
            arn: self.arn,
            description: self.description,
            signal_catalog_arn: self.signal_catalog_arn,
            target_arn: self.target_arn,
            status: self.status,
            start_time: self.start_time,
            expiry_time: self.expiry_time,
            post_trigger_collection_duration: self.post_trigger_collection_duration,
            diagnostics_mode: self.diagnostics_mode,
            spooling_mode: self.spooling_mode,
            compression: self.compression,
            priority: self.priority,
            signals_to_collect: self.signals_to_collect,
            collection_scheme: self.collection_scheme,
            data_extra_dimensions: self.data_extra_dimensions,
            creation_time: self.creation_time,
            last_modification_time: self.last_modification_time,
            data_destination_configs: self.data_destination_configs,
            data_partitions: self.data_partitions,
            signals_to_fetch: self.signals_to_fetch,
            _request_id: self._request_id,
        }
    }
}
impl ::std::fmt::Debug for GetCampaignOutputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("GetCampaignOutputBuilder");
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("signal_catalog_arn", &self.signal_catalog_arn);
        formatter.field("target_arn", &self.target_arn);
        formatter.field("status", &self.status);
        formatter.field("start_time", &self.start_time);
        formatter.field("expiry_time", &self.expiry_time);
        formatter.field("post_trigger_collection_duration", &self.post_trigger_collection_duration);
        formatter.field("diagnostics_mode", &self.diagnostics_mode);
        formatter.field("spooling_mode", &self.spooling_mode);
        formatter.field("compression", &self.compression);
        formatter.field("priority", &self.priority);
        formatter.field("signals_to_collect", &"*** Sensitive Data Redacted ***");
        formatter.field("collection_scheme", &self.collection_scheme);
        formatter.field("data_extra_dimensions", &"*** Sensitive Data Redacted ***");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modification_time", &self.last_modification_time);
        formatter.field("data_destination_configs", &self.data_destination_configs);
        formatter.field("data_partitions", &self.data_partitions);
        formatter.field("signals_to_fetch", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
