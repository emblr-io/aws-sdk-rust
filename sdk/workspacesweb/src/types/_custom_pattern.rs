// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The pattern configuration for redacting custom data types in session.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CustomPattern {
    /// <p>The pattern name for the custom pattern.</p>
    pub pattern_name: ::std::string::String,
    /// <p>The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: “/ab+c/gi”.</p>
    pub pattern_regex: ::std::string::String,
    /// <p>The pattern description for the customer pattern.</p>
    pub pattern_description: ::std::option::Option<::std::string::String>,
    /// <p>The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, “/ab+c/gi”</p>
    pub keyword_regex: ::std::option::Option<::std::string::String>,
}
impl CustomPattern {
    /// <p>The pattern name for the custom pattern.</p>
    pub fn pattern_name(&self) -> &str {
        use std::ops::Deref;
        self.pattern_name.deref()
    }
    /// <p>The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: “/ab+c/gi”.</p>
    pub fn pattern_regex(&self) -> &str {
        use std::ops::Deref;
        self.pattern_regex.deref()
    }
    /// <p>The pattern description for the customer pattern.</p>
    pub fn pattern_description(&self) -> ::std::option::Option<&str> {
        self.pattern_description.as_deref()
    }
    /// <p>The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, “/ab+c/gi”</p>
    pub fn keyword_regex(&self) -> ::std::option::Option<&str> {
        self.keyword_regex.as_deref()
    }
}
impl ::std::fmt::Debug for CustomPattern {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CustomPattern");
        formatter.field("pattern_name", &"*** Sensitive Data Redacted ***");
        formatter.field("pattern_regex", &"*** Sensitive Data Redacted ***");
        formatter.field("pattern_description", &"*** Sensitive Data Redacted ***");
        formatter.field("keyword_regex", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl CustomPattern {
    /// Creates a new builder-style object to manufacture [`CustomPattern`](crate::types::CustomPattern).
    pub fn builder() -> crate::types::builders::CustomPatternBuilder {
        crate::types::builders::CustomPatternBuilder::default()
    }
}

/// A builder for [`CustomPattern`](crate::types::CustomPattern).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct CustomPatternBuilder {
    pub(crate) pattern_name: ::std::option::Option<::std::string::String>,
    pub(crate) pattern_regex: ::std::option::Option<::std::string::String>,
    pub(crate) pattern_description: ::std::option::Option<::std::string::String>,
    pub(crate) keyword_regex: ::std::option::Option<::std::string::String>,
}
impl CustomPatternBuilder {
    /// <p>The pattern name for the custom pattern.</p>
    /// This field is required.
    pub fn pattern_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pattern_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pattern name for the custom pattern.</p>
    pub fn set_pattern_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pattern_name = input;
        self
    }
    /// <p>The pattern name for the custom pattern.</p>
    pub fn get_pattern_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.pattern_name
    }
    /// <p>The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: “/ab+c/gi”.</p>
    /// This field is required.
    pub fn pattern_regex(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pattern_regex = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: “/ab+c/gi”.</p>
    pub fn set_pattern_regex(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pattern_regex = input;
        self
    }
    /// <p>The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: “/ab+c/gi”.</p>
    pub fn get_pattern_regex(&self) -> &::std::option::Option<::std::string::String> {
        &self.pattern_regex
    }
    /// <p>The pattern description for the customer pattern.</p>
    pub fn pattern_description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pattern_description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pattern description for the customer pattern.</p>
    pub fn set_pattern_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pattern_description = input;
        self
    }
    /// <p>The pattern description for the customer pattern.</p>
    pub fn get_pattern_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.pattern_description
    }
    /// <p>The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, “/ab+c/gi”</p>
    pub fn keyword_regex(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.keyword_regex = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, “/ab+c/gi”</p>
    pub fn set_keyword_regex(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.keyword_regex = input;
        self
    }
    /// <p>The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, “/ab+c/gi”</p>
    pub fn get_keyword_regex(&self) -> &::std::option::Option<::std::string::String> {
        &self.keyword_regex
    }
    /// Consumes the builder and constructs a [`CustomPattern`](crate::types::CustomPattern).
    /// This method will fail if any of the following fields are not set:
    /// - [`pattern_name`](crate::types::builders::CustomPatternBuilder::pattern_name)
    /// - [`pattern_regex`](crate::types::builders::CustomPatternBuilder::pattern_regex)
    pub fn build(self) -> ::std::result::Result<crate::types::CustomPattern, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::CustomPattern {
            pattern_name: self.pattern_name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "pattern_name",
                    "pattern_name was not specified but it is required when building CustomPattern",
                )
            })?,
            pattern_regex: self.pattern_regex.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "pattern_regex",
                    "pattern_regex was not specified but it is required when building CustomPattern",
                )
            })?,
            pattern_description: self.pattern_description,
            keyword_regex: self.keyword_regex,
        })
    }
}
impl ::std::fmt::Debug for CustomPatternBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CustomPatternBuilder");
        formatter.field("pattern_name", &"*** Sensitive Data Redacted ***");
        formatter.field("pattern_regex", &"*** Sensitive Data Redacted ***");
        formatter.field("pattern_description", &"*** Sensitive Data Redacted ***");
        formatter.field("keyword_regex", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
