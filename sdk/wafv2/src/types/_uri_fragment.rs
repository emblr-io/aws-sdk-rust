// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Inspect fragments of the request URI. You can specify the parts of the URI fragment to inspect and you can narrow the set of URI fragments to inspect by including or excluding specific keys.</p>
/// <p>This is used to indicate the web request component to inspect, in the <code>FieldToMatch</code> specification.</p>
/// <p>Example JSON: <code>"UriFragment": { "MatchPattern": { "All": {} }, "MatchScope": "KEY", "OversizeHandling": "MATCH" }</code></p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct UriFragment {
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p></li>
    /// <li>
    /// <p><code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p></li>
    /// <li>
    /// <p><code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p></li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters.</p>
    /// <p>Example JSON: <code>{ "UriFragment": { "FallbackBehavior": "MATCH"} }</code></p><note>
    /// <p>WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, WAF doesn't apply the fallback behavior. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body">JSON body</a> in the <i>WAF Developer Guide</i>.</p>
    /// </note>
    pub fallback_behavior: ::std::option::Option<crate::types::FallbackBehavior>,
}
impl UriFragment {
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p></li>
    /// <li>
    /// <p><code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p></li>
    /// <li>
    /// <p><code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p></li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters.</p>
    /// <p>Example JSON: <code>{ "UriFragment": { "FallbackBehavior": "MATCH"} }</code></p><note>
    /// <p>WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, WAF doesn't apply the fallback behavior. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body">JSON body</a> in the <i>WAF Developer Guide</i>.</p>
    /// </note>
    pub fn fallback_behavior(&self) -> ::std::option::Option<&crate::types::FallbackBehavior> {
        self.fallback_behavior.as_ref()
    }
}
impl UriFragment {
    /// Creates a new builder-style object to manufacture [`UriFragment`](crate::types::UriFragment).
    pub fn builder() -> crate::types::builders::UriFragmentBuilder {
        crate::types::builders::UriFragmentBuilder::default()
    }
}

/// A builder for [`UriFragment`](crate::types::UriFragment).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct UriFragmentBuilder {
    pub(crate) fallback_behavior: ::std::option::Option<crate::types::FallbackBehavior>,
}
impl UriFragmentBuilder {
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p></li>
    /// <li>
    /// <p><code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p></li>
    /// <li>
    /// <p><code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p></li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters.</p>
    /// <p>Example JSON: <code>{ "UriFragment": { "FallbackBehavior": "MATCH"} }</code></p><note>
    /// <p>WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, WAF doesn't apply the fallback behavior. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body">JSON body</a> in the <i>WAF Developer Guide</i>.</p>
    /// </note>
    pub fn fallback_behavior(mut self, input: crate::types::FallbackBehavior) -> Self {
        self.fallback_behavior = ::std::option::Option::Some(input);
        self
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p></li>
    /// <li>
    /// <p><code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p></li>
    /// <li>
    /// <p><code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p></li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters.</p>
    /// <p>Example JSON: <code>{ "UriFragment": { "FallbackBehavior": "MATCH"} }</code></p><note>
    /// <p>WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, WAF doesn't apply the fallback behavior. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body">JSON body</a> in the <i>WAF Developer Guide</i>.</p>
    /// </note>
    pub fn set_fallback_behavior(mut self, input: ::std::option::Option<crate::types::FallbackBehavior>) -> Self {
        self.fallback_behavior = input;
        self
    }
    /// <p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p></li>
    /// <li>
    /// <p><code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p></li>
    /// <li>
    /// <p><code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p></li>
    /// </ul>
    /// <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters.</p>
    /// <p>Example JSON: <code>{ "UriFragment": { "FallbackBehavior": "MATCH"} }</code></p><note>
    /// <p>WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, WAF doesn't apply the fallback behavior. For more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body">JSON body</a> in the <i>WAF Developer Guide</i>.</p>
    /// </note>
    pub fn get_fallback_behavior(&self) -> &::std::option::Option<crate::types::FallbackBehavior> {
        &self.fallback_behavior
    }
    /// Consumes the builder and constructs a [`UriFragment`](crate::types::UriFragment).
    pub fn build(self) -> crate::types::UriFragment {
        crate::types::UriFragment {
            fallback_behavior: self.fallback_behavior,
        }
    }
}
