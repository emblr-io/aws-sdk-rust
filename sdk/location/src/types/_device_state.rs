// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The device's position, IP address, and Wi-Fi access points.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct DeviceState {
    /// <p>The device identifier.</p>
    pub device_id: ::std::string::String,
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601 </a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub sample_time: ::aws_smithy_types::DateTime,
    /// <p>The last known device position.</p>
    pub position: ::std::vec::Vec<f64>,
    /// <p>Defines the level of certainty of the position.</p>
    pub accuracy: ::std::option::Option<crate::types::PositionalAccuracy>,
    /// <p>The device's Ipv4 address.</p>
    pub ipv4_address: ::std::option::Option<::std::string::String>,
    /// <p>The Wi-Fi access points the device is using.</p>
    pub wi_fi_access_points: ::std::option::Option<::std::vec::Vec<crate::types::WiFiAccessPoint>>,
    /// <p>The cellular network infrastructure that the device is connected to.</p>
    pub cell_signals: ::std::option::Option<crate::types::CellSignals>,
}
impl DeviceState {
    /// <p>The device identifier.</p>
    pub fn device_id(&self) -> &str {
        use std::ops::Deref;
        self.device_id.deref()
    }
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601 </a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub fn sample_time(&self) -> &::aws_smithy_types::DateTime {
        &self.sample_time
    }
    /// <p>The last known device position.</p>
    pub fn position(&self) -> &[f64] {
        use std::ops::Deref;
        self.position.deref()
    }
    /// <p>Defines the level of certainty of the position.</p>
    pub fn accuracy(&self) -> ::std::option::Option<&crate::types::PositionalAccuracy> {
        self.accuracy.as_ref()
    }
    /// <p>The device's Ipv4 address.</p>
    pub fn ipv4_address(&self) -> ::std::option::Option<&str> {
        self.ipv4_address.as_deref()
    }
    /// <p>The Wi-Fi access points the device is using.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.wi_fi_access_points.is_none()`.
    pub fn wi_fi_access_points(&self) -> &[crate::types::WiFiAccessPoint] {
        self.wi_fi_access_points.as_deref().unwrap_or_default()
    }
    /// <p>The cellular network infrastructure that the device is connected to.</p>
    pub fn cell_signals(&self) -> ::std::option::Option<&crate::types::CellSignals> {
        self.cell_signals.as_ref()
    }
}
impl ::std::fmt::Debug for DeviceState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceState");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("position", &"*** Sensitive Data Redacted ***");
        formatter.field("accuracy", &self.accuracy);
        formatter.field("ipv4_address", &self.ipv4_address);
        formatter.field("wi_fi_access_points", &self.wi_fi_access_points);
        formatter.field("cell_signals", &self.cell_signals);
        formatter.finish()
    }
}
impl DeviceState {
    /// Creates a new builder-style object to manufacture [`DeviceState`](crate::types::DeviceState).
    pub fn builder() -> crate::types::builders::DeviceStateBuilder {
        crate::types::builders::DeviceStateBuilder::default()
    }
}

/// A builder for [`DeviceState`](crate::types::DeviceState).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct DeviceStateBuilder {
    pub(crate) device_id: ::std::option::Option<::std::string::String>,
    pub(crate) sample_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) position: ::std::option::Option<::std::vec::Vec<f64>>,
    pub(crate) accuracy: ::std::option::Option<crate::types::PositionalAccuracy>,
    pub(crate) ipv4_address: ::std::option::Option<::std::string::String>,
    pub(crate) wi_fi_access_points: ::std::option::Option<::std::vec::Vec<crate::types::WiFiAccessPoint>>,
    pub(crate) cell_signals: ::std::option::Option<crate::types::CellSignals>,
}
impl DeviceStateBuilder {
    /// <p>The device identifier.</p>
    /// This field is required.
    pub fn device_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.device_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device identifier.</p>
    pub fn set_device_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.device_id = input;
        self
    }
    /// <p>The device identifier.</p>
    pub fn get_device_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.device_id
    }
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601 </a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    /// This field is required.
    pub fn sample_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.sample_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601 </a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub fn set_sample_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.sample_time = input;
        self
    }
    /// <p>The timestamp at which the device's position was determined. Uses <a href="https://www.iso.org/iso-8601-date-and-time-format.html"> ISO 8601 </a> format: <code>YYYY-MM-DDThh:mm:ss.sssZ</code>.</p>
    pub fn get_sample_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.sample_time
    }
    /// Appends an item to `position`.
    ///
    /// To override the contents of this collection use [`set_position`](Self::set_position).
    ///
    /// <p>The last known device position.</p>
    pub fn position(mut self, input: f64) -> Self {
        let mut v = self.position.unwrap_or_default();
        v.push(input);
        self.position = ::std::option::Option::Some(v);
        self
    }
    /// <p>The last known device position.</p>
    pub fn set_position(mut self, input: ::std::option::Option<::std::vec::Vec<f64>>) -> Self {
        self.position = input;
        self
    }
    /// <p>The last known device position.</p>
    pub fn get_position(&self) -> &::std::option::Option<::std::vec::Vec<f64>> {
        &self.position
    }
    /// <p>Defines the level of certainty of the position.</p>
    pub fn accuracy(mut self, input: crate::types::PositionalAccuracy) -> Self {
        self.accuracy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the level of certainty of the position.</p>
    pub fn set_accuracy(mut self, input: ::std::option::Option<crate::types::PositionalAccuracy>) -> Self {
        self.accuracy = input;
        self
    }
    /// <p>Defines the level of certainty of the position.</p>
    pub fn get_accuracy(&self) -> &::std::option::Option<crate::types::PositionalAccuracy> {
        &self.accuracy
    }
    /// <p>The device's Ipv4 address.</p>
    pub fn ipv4_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ipv4_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's Ipv4 address.</p>
    pub fn set_ipv4_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ipv4_address = input;
        self
    }
    /// <p>The device's Ipv4 address.</p>
    pub fn get_ipv4_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.ipv4_address
    }
    /// Appends an item to `wi_fi_access_points`.
    ///
    /// To override the contents of this collection use [`set_wi_fi_access_points`](Self::set_wi_fi_access_points).
    ///
    /// <p>The Wi-Fi access points the device is using.</p>
    pub fn wi_fi_access_points(mut self, input: crate::types::WiFiAccessPoint) -> Self {
        let mut v = self.wi_fi_access_points.unwrap_or_default();
        v.push(input);
        self.wi_fi_access_points = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Wi-Fi access points the device is using.</p>
    pub fn set_wi_fi_access_points(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::WiFiAccessPoint>>) -> Self {
        self.wi_fi_access_points = input;
        self
    }
    /// <p>The Wi-Fi access points the device is using.</p>
    pub fn get_wi_fi_access_points(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WiFiAccessPoint>> {
        &self.wi_fi_access_points
    }
    /// <p>The cellular network infrastructure that the device is connected to.</p>
    pub fn cell_signals(mut self, input: crate::types::CellSignals) -> Self {
        self.cell_signals = ::std::option::Option::Some(input);
        self
    }
    /// <p>The cellular network infrastructure that the device is connected to.</p>
    pub fn set_cell_signals(mut self, input: ::std::option::Option<crate::types::CellSignals>) -> Self {
        self.cell_signals = input;
        self
    }
    /// <p>The cellular network infrastructure that the device is connected to.</p>
    pub fn get_cell_signals(&self) -> &::std::option::Option<crate::types::CellSignals> {
        &self.cell_signals
    }
    /// Consumes the builder and constructs a [`DeviceState`](crate::types::DeviceState).
    /// This method will fail if any of the following fields are not set:
    /// - [`device_id`](crate::types::builders::DeviceStateBuilder::device_id)
    /// - [`sample_time`](crate::types::builders::DeviceStateBuilder::sample_time)
    /// - [`position`](crate::types::builders::DeviceStateBuilder::position)
    pub fn build(self) -> ::std::result::Result<crate::types::DeviceState, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::DeviceState {
            device_id: self.device_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "device_id",
                    "device_id was not specified but it is required when building DeviceState",
                )
            })?,
            sample_time: self.sample_time.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "sample_time",
                    "sample_time was not specified but it is required when building DeviceState",
                )
            })?,
            position: self.position.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "position",
                    "position was not specified but it is required when building DeviceState",
                )
            })?,
            accuracy: self.accuracy,
            ipv4_address: self.ipv4_address,
            wi_fi_access_points: self.wi_fi_access_points,
            cell_signals: self.cell_signals,
        })
    }
}
impl ::std::fmt::Debug for DeviceStateBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("DeviceStateBuilder");
        formatter.field("device_id", &self.device_id);
        formatter.field("sample_time", &self.sample_time);
        formatter.field("position", &"*** Sensitive Data Redacted ***");
        formatter.field("accuracy", &self.accuracy);
        formatter.field("ipv4_address", &self.ipv4_address);
        formatter.field("wi_fi_access_points", &self.wi_fi_access_points);
        formatter.field("cell_signals", &self.cell_signals);
        formatter.finish()
    }
}
