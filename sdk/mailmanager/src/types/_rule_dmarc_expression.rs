// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A DMARC policy expression. The condition matches if the given DMARC policy matches that of the incoming email.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RuleDmarcExpression {
    /// <p>The operator to apply to the DMARC policy of the incoming email.</p>
    pub operator: crate::types::RuleDmarcOperator,
    /// <p>The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.</p>
    pub values: ::std::vec::Vec<crate::types::RuleDmarcPolicy>,
}
impl RuleDmarcExpression {
    /// <p>The operator to apply to the DMARC policy of the incoming email.</p>
    pub fn operator(&self) -> &crate::types::RuleDmarcOperator {
        &self.operator
    }
    /// <p>The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.</p>
    pub fn values(&self) -> &[crate::types::RuleDmarcPolicy] {
        use std::ops::Deref;
        self.values.deref()
    }
}
impl RuleDmarcExpression {
    /// Creates a new builder-style object to manufacture [`RuleDmarcExpression`](crate::types::RuleDmarcExpression).
    pub fn builder() -> crate::types::builders::RuleDmarcExpressionBuilder {
        crate::types::builders::RuleDmarcExpressionBuilder::default()
    }
}

/// A builder for [`RuleDmarcExpression`](crate::types::RuleDmarcExpression).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RuleDmarcExpressionBuilder {
    pub(crate) operator: ::std::option::Option<crate::types::RuleDmarcOperator>,
    pub(crate) values: ::std::option::Option<::std::vec::Vec<crate::types::RuleDmarcPolicy>>,
}
impl RuleDmarcExpressionBuilder {
    /// <p>The operator to apply to the DMARC policy of the incoming email.</p>
    /// This field is required.
    pub fn operator(mut self, input: crate::types::RuleDmarcOperator) -> Self {
        self.operator = ::std::option::Option::Some(input);
        self
    }
    /// <p>The operator to apply to the DMARC policy of the incoming email.</p>
    pub fn set_operator(mut self, input: ::std::option::Option<crate::types::RuleDmarcOperator>) -> Self {
        self.operator = input;
        self
    }
    /// <p>The operator to apply to the DMARC policy of the incoming email.</p>
    pub fn get_operator(&self) -> &::std::option::Option<crate::types::RuleDmarcOperator> {
        &self.operator
    }
    /// Appends an item to `values`.
    ///
    /// To override the contents of this collection use [`set_values`](Self::set_values).
    ///
    /// <p>The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.</p>
    pub fn values(mut self, input: crate::types::RuleDmarcPolicy) -> Self {
        let mut v = self.values.unwrap_or_default();
        v.push(input);
        self.values = ::std::option::Option::Some(v);
        self
    }
    /// <p>The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.</p>
    pub fn set_values(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RuleDmarcPolicy>>) -> Self {
        self.values = input;
        self
    }
    /// <p>The values to use for the given DMARC policy operator. For the operator EQUALS, if multiple values are given, they are evaluated as an OR. That is, if any of the given values match, the condition is deemed to match. For the operator NOT_EQUALS, if multiple values are given, they are evaluated as an AND. That is, only if the email's DMARC policy is not equal to any of the given values, then the condition is deemed to match.</p>
    pub fn get_values(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RuleDmarcPolicy>> {
        &self.values
    }
    /// Consumes the builder and constructs a [`RuleDmarcExpression`](crate::types::RuleDmarcExpression).
    /// This method will fail if any of the following fields are not set:
    /// - [`operator`](crate::types::builders::RuleDmarcExpressionBuilder::operator)
    /// - [`values`](crate::types::builders::RuleDmarcExpressionBuilder::values)
    pub fn build(self) -> ::std::result::Result<crate::types::RuleDmarcExpression, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::RuleDmarcExpression {
            operator: self.operator.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "operator",
                    "operator was not specified but it is required when building RuleDmarcExpression",
                )
            })?,
            values: self.values.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "values",
                    "values was not specified but it is required when building RuleDmarcExpression",
                )
            })?,
        })
    }
}
