// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A rule contains conditions, "unless conditions" and actions. For each envelope recipient of an email, if all conditions match and none of the "unless conditions" match, then all of the actions are executed sequentially. If no conditions are provided, the rule always applies and the actions are implicitly executed. If only "unless conditions" are provided, the rule applies if the email does not match the evaluation of the "unless conditions".</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Rule {
    /// <p>The user-friendly name of the rule.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"</p>
    pub conditions: ::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>>,
    /// <p>The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.</p>
    pub unless: ::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>>,
    /// <p>The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.</p>
    pub actions: ::std::vec::Vec<crate::types::RuleAction>,
}
impl Rule {
    /// <p>The user-friendly name of the rule.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.conditions.is_none()`.
    pub fn conditions(&self) -> &[crate::types::RuleCondition] {
        self.conditions.as_deref().unwrap_or_default()
    }
    /// <p>The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.unless.is_none()`.
    pub fn unless(&self) -> &[crate::types::RuleCondition] {
        self.unless.as_deref().unwrap_or_default()
    }
    /// <p>The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.</p>
    pub fn actions(&self) -> &[crate::types::RuleAction] {
        use std::ops::Deref;
        self.actions.deref()
    }
}
impl Rule {
    /// Creates a new builder-style object to manufacture [`Rule`](crate::types::Rule).
    pub fn builder() -> crate::types::builders::RuleBuilder {
        crate::types::builders::RuleBuilder::default()
    }
}

/// A builder for [`Rule`](crate::types::Rule).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct RuleBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) conditions: ::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>>,
    pub(crate) unless: ::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>>,
    pub(crate) actions: ::std::option::Option<::std::vec::Vec<crate::types::RuleAction>>,
}
impl RuleBuilder {
    /// <p>The user-friendly name of the rule.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The user-friendly name of the rule.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The user-friendly name of the rule.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// Appends an item to `conditions`.
    ///
    /// To override the contents of this collection use [`set_conditions`](Self::set_conditions).
    ///
    /// <p>The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"</p>
    pub fn conditions(mut self, input: crate::types::RuleCondition) -> Self {
        let mut v = self.conditions.unwrap_or_default();
        v.push(input);
        self.conditions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"</p>
    pub fn set_conditions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>>) -> Self {
        self.conditions = input;
        self
    }
    /// <p>The conditions of this rule. All conditions must match the email for the actions to be executed. An empty list of conditions means that all emails match, but are still subject to any "unless conditions"</p>
    pub fn get_conditions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>> {
        &self.conditions
    }
    /// Appends an item to `unless`.
    ///
    /// To override the contents of this collection use [`set_unless`](Self::set_unless).
    ///
    /// <p>The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.</p>
    pub fn unless(mut self, input: crate::types::RuleCondition) -> Self {
        let mut v = self.unless.unwrap_or_default();
        v.push(input);
        self.unless = ::std::option::Option::Some(v);
        self
    }
    /// <p>The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.</p>
    pub fn set_unless(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>>) -> Self {
        self.unless = input;
        self
    }
    /// <p>The "unless conditions" of this rule. None of the conditions can match the email for the actions to be executed. If any of these conditions do match the email, then the actions are not executed.</p>
    pub fn get_unless(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RuleCondition>> {
        &self.unless
    }
    /// Appends an item to `actions`.
    ///
    /// To override the contents of this collection use [`set_actions`](Self::set_actions).
    ///
    /// <p>The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.</p>
    pub fn actions(mut self, input: crate::types::RuleAction) -> Self {
        let mut v = self.actions.unwrap_or_default();
        v.push(input);
        self.actions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.</p>
    pub fn set_actions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RuleAction>>) -> Self {
        self.actions = input;
        self
    }
    /// <p>The list of actions to execute when the conditions match the incoming email, and none of the "unless conditions" match.</p>
    pub fn get_actions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RuleAction>> {
        &self.actions
    }
    /// Consumes the builder and constructs a [`Rule`](crate::types::Rule).
    /// This method will fail if any of the following fields are not set:
    /// - [`actions`](crate::types::builders::RuleBuilder::actions)
    pub fn build(self) -> ::std::result::Result<crate::types::Rule, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::Rule {
            name: self.name,
            conditions: self.conditions,
            unless: self.unless,
            actions: self.actions.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "actions",
                    "actions was not specified but it is required when building Rule",
                )
            })?,
        })
    }
}
