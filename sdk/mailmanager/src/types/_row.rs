// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A result row containing metadata for an archived email message.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct Row {
    /// <p>The unique identifier of the archived message.</p>
    pub archived_message_id: ::std::option::Option<::std::string::String>,
    /// <p>The timestamp of when the email was received.</p>
    pub received_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date the email was sent.</p>
    pub date: ::std::option::Option<::std::string::String>,
    /// <p>The email addresses in the To header.</p>
    pub to: ::std::option::Option<::std::string::String>,
    /// <p>The email address of the sender.</p>
    pub from: ::std::option::Option<::std::string::String>,
    /// <p>The email addresses in the CC header.</p>
    pub cc: ::std::option::Option<::std::string::String>,
    /// <p>The subject header value of the email.</p>
    pub subject: ::std::option::Option<::std::string::String>,
    /// <p>The unique message ID of the email.</p>
    pub message_id: ::std::option::Option<::std::string::String>,
    /// <p>A flag indicating if the email has attachments.</p>
    pub has_attachments: ::std::option::Option<bool>,
    /// <p>The received headers from the email delivery path.</p>
    pub received_headers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The email message ID this is a reply to.</p>
    pub in_reply_to: ::std::option::Option<::std::string::String>,
    /// <p>The user agent that sent the email.</p>
    pub x_mailer: ::std::option::Option<::std::string::String>,
    /// <p>The original user agent that sent the email.</p>
    pub x_original_mailer: ::std::option::Option<::std::string::String>,
    /// <p>The priority level of the email.</p>
    pub x_priority: ::std::option::Option<::std::string::String>,
    /// <p>The ID of the ingress endpoint through which the email was received.</p>
    pub ingress_point_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the host from which the email was received.</p>
    pub sender_hostname: ::std::option::Option<::std::string::String>,
    /// <ul>
    /// <li>
    /// <p>Mail archived with Mail Manager: The IP address of the client that connects to the ingress endpoint.</p></li>
    /// <li>
    /// <p>Mail sent through a configuration set with the archiving option enabled: The IP address of the client that makes the SendEmail API call.</p></li>
    /// </ul>
    pub sender_ip_address: ::std::option::Option<::std::string::String>,
    /// <p>The SMTP envelope information of the email.</p>
    pub envelope: ::std::option::Option<crate::types::Envelope>,
    /// <p>Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.</p>
    pub source_arn: ::std::option::Option<::std::string::String>,
}
impl Row {
    /// <p>The unique identifier of the archived message.</p>
    pub fn archived_message_id(&self) -> ::std::option::Option<&str> {
        self.archived_message_id.as_deref()
    }
    /// <p>The timestamp of when the email was received.</p>
    pub fn received_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.received_timestamp.as_ref()
    }
    /// <p>The date the email was sent.</p>
    pub fn date(&self) -> ::std::option::Option<&str> {
        self.date.as_deref()
    }
    /// <p>The email addresses in the To header.</p>
    pub fn to(&self) -> ::std::option::Option<&str> {
        self.to.as_deref()
    }
    /// <p>The email address of the sender.</p>
    pub fn from(&self) -> ::std::option::Option<&str> {
        self.from.as_deref()
    }
    /// <p>The email addresses in the CC header.</p>
    pub fn cc(&self) -> ::std::option::Option<&str> {
        self.cc.as_deref()
    }
    /// <p>The subject header value of the email.</p>
    pub fn subject(&self) -> ::std::option::Option<&str> {
        self.subject.as_deref()
    }
    /// <p>The unique message ID of the email.</p>
    pub fn message_id(&self) -> ::std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>A flag indicating if the email has attachments.</p>
    pub fn has_attachments(&self) -> ::std::option::Option<bool> {
        self.has_attachments
    }
    /// <p>The received headers from the email delivery path.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.received_headers.is_none()`.
    pub fn received_headers(&self) -> &[::std::string::String] {
        self.received_headers.as_deref().unwrap_or_default()
    }
    /// <p>The email message ID this is a reply to.</p>
    pub fn in_reply_to(&self) -> ::std::option::Option<&str> {
        self.in_reply_to.as_deref()
    }
    /// <p>The user agent that sent the email.</p>
    pub fn x_mailer(&self) -> ::std::option::Option<&str> {
        self.x_mailer.as_deref()
    }
    /// <p>The original user agent that sent the email.</p>
    pub fn x_original_mailer(&self) -> ::std::option::Option<&str> {
        self.x_original_mailer.as_deref()
    }
    /// <p>The priority level of the email.</p>
    pub fn x_priority(&self) -> ::std::option::Option<&str> {
        self.x_priority.as_deref()
    }
    /// <p>The ID of the ingress endpoint through which the email was received.</p>
    pub fn ingress_point_id(&self) -> ::std::option::Option<&str> {
        self.ingress_point_id.as_deref()
    }
    /// <p>The name of the host from which the email was received.</p>
    pub fn sender_hostname(&self) -> ::std::option::Option<&str> {
        self.sender_hostname.as_deref()
    }
    /// <ul>
    /// <li>
    /// <p>Mail archived with Mail Manager: The IP address of the client that connects to the ingress endpoint.</p></li>
    /// <li>
    /// <p>Mail sent through a configuration set with the archiving option enabled: The IP address of the client that makes the SendEmail API call.</p></li>
    /// </ul>
    pub fn sender_ip_address(&self) -> ::std::option::Option<&str> {
        self.sender_ip_address.as_deref()
    }
    /// <p>The SMTP envelope information of the email.</p>
    pub fn envelope(&self) -> ::std::option::Option<&crate::types::Envelope> {
        self.envelope.as_ref()
    }
    /// <p>Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.</p>
    pub fn source_arn(&self) -> ::std::option::Option<&str> {
        self.source_arn.as_deref()
    }
}
impl ::std::fmt::Debug for Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("Row");
        formatter.field("archived_message_id", &self.archived_message_id);
        formatter.field("received_timestamp", &self.received_timestamp);
        formatter.field("date", &self.date);
        formatter.field("to", &self.to);
        formatter.field("from", &self.from);
        formatter.field("cc", &self.cc);
        formatter.field("subject", &self.subject);
        formatter.field("message_id", &self.message_id);
        formatter.field("has_attachments", &self.has_attachments);
        formatter.field("received_headers", &self.received_headers);
        formatter.field("in_reply_to", &self.in_reply_to);
        formatter.field("x_mailer", &self.x_mailer);
        formatter.field("x_original_mailer", &self.x_original_mailer);
        formatter.field("x_priority", &self.x_priority);
        formatter.field("ingress_point_id", &self.ingress_point_id);
        formatter.field("sender_hostname", &self.sender_hostname);
        formatter.field("sender_ip_address", &"*** Sensitive Data Redacted ***");
        formatter.field("envelope", &self.envelope);
        formatter.field("source_arn", &self.source_arn);
        formatter.finish()
    }
}
impl Row {
    /// Creates a new builder-style object to manufacture [`Row`](crate::types::Row).
    pub fn builder() -> crate::types::builders::RowBuilder {
        crate::types::builders::RowBuilder::default()
    }
}

/// A builder for [`Row`](crate::types::Row).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct RowBuilder {
    pub(crate) archived_message_id: ::std::option::Option<::std::string::String>,
    pub(crate) received_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) date: ::std::option::Option<::std::string::String>,
    pub(crate) to: ::std::option::Option<::std::string::String>,
    pub(crate) from: ::std::option::Option<::std::string::String>,
    pub(crate) cc: ::std::option::Option<::std::string::String>,
    pub(crate) subject: ::std::option::Option<::std::string::String>,
    pub(crate) message_id: ::std::option::Option<::std::string::String>,
    pub(crate) has_attachments: ::std::option::Option<bool>,
    pub(crate) received_headers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) in_reply_to: ::std::option::Option<::std::string::String>,
    pub(crate) x_mailer: ::std::option::Option<::std::string::String>,
    pub(crate) x_original_mailer: ::std::option::Option<::std::string::String>,
    pub(crate) x_priority: ::std::option::Option<::std::string::String>,
    pub(crate) ingress_point_id: ::std::option::Option<::std::string::String>,
    pub(crate) sender_hostname: ::std::option::Option<::std::string::String>,
    pub(crate) sender_ip_address: ::std::option::Option<::std::string::String>,
    pub(crate) envelope: ::std::option::Option<crate::types::Envelope>,
    pub(crate) source_arn: ::std::option::Option<::std::string::String>,
}
impl RowBuilder {
    /// <p>The unique identifier of the archived message.</p>
    pub fn archived_message_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.archived_message_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the archived message.</p>
    pub fn set_archived_message_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.archived_message_id = input;
        self
    }
    /// <p>The unique identifier of the archived message.</p>
    pub fn get_archived_message_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.archived_message_id
    }
    /// <p>The timestamp of when the email was received.</p>
    pub fn received_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.received_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp of when the email was received.</p>
    pub fn set_received_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.received_timestamp = input;
        self
    }
    /// <p>The timestamp of when the email was received.</p>
    pub fn get_received_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.received_timestamp
    }
    /// <p>The date the email was sent.</p>
    pub fn date(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.date = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The date the email was sent.</p>
    pub fn set_date(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.date = input;
        self
    }
    /// <p>The date the email was sent.</p>
    pub fn get_date(&self) -> &::std::option::Option<::std::string::String> {
        &self.date
    }
    /// <p>The email addresses in the To header.</p>
    pub fn to(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.to = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The email addresses in the To header.</p>
    pub fn set_to(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.to = input;
        self
    }
    /// <p>The email addresses in the To header.</p>
    pub fn get_to(&self) -> &::std::option::Option<::std::string::String> {
        &self.to
    }
    /// <p>The email address of the sender.</p>
    pub fn from(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.from = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The email address of the sender.</p>
    pub fn set_from(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.from = input;
        self
    }
    /// <p>The email address of the sender.</p>
    pub fn get_from(&self) -> &::std::option::Option<::std::string::String> {
        &self.from
    }
    /// <p>The email addresses in the CC header.</p>
    pub fn cc(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cc = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The email addresses in the CC header.</p>
    pub fn set_cc(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cc = input;
        self
    }
    /// <p>The email addresses in the CC header.</p>
    pub fn get_cc(&self) -> &::std::option::Option<::std::string::String> {
        &self.cc
    }
    /// <p>The subject header value of the email.</p>
    pub fn subject(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.subject = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The subject header value of the email.</p>
    pub fn set_subject(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.subject = input;
        self
    }
    /// <p>The subject header value of the email.</p>
    pub fn get_subject(&self) -> &::std::option::Option<::std::string::String> {
        &self.subject
    }
    /// <p>The unique message ID of the email.</p>
    pub fn message_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique message ID of the email.</p>
    pub fn set_message_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message_id = input;
        self
    }
    /// <p>The unique message ID of the email.</p>
    pub fn get_message_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.message_id
    }
    /// <p>A flag indicating if the email has attachments.</p>
    pub fn has_attachments(mut self, input: bool) -> Self {
        self.has_attachments = ::std::option::Option::Some(input);
        self
    }
    /// <p>A flag indicating if the email has attachments.</p>
    pub fn set_has_attachments(mut self, input: ::std::option::Option<bool>) -> Self {
        self.has_attachments = input;
        self
    }
    /// <p>A flag indicating if the email has attachments.</p>
    pub fn get_has_attachments(&self) -> &::std::option::Option<bool> {
        &self.has_attachments
    }
    /// Appends an item to `received_headers`.
    ///
    /// To override the contents of this collection use [`set_received_headers`](Self::set_received_headers).
    ///
    /// <p>The received headers from the email delivery path.</p>
    pub fn received_headers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.received_headers.unwrap_or_default();
        v.push(input.into());
        self.received_headers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The received headers from the email delivery path.</p>
    pub fn set_received_headers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.received_headers = input;
        self
    }
    /// <p>The received headers from the email delivery path.</p>
    pub fn get_received_headers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.received_headers
    }
    /// <p>The email message ID this is a reply to.</p>
    pub fn in_reply_to(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.in_reply_to = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The email message ID this is a reply to.</p>
    pub fn set_in_reply_to(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.in_reply_to = input;
        self
    }
    /// <p>The email message ID this is a reply to.</p>
    pub fn get_in_reply_to(&self) -> &::std::option::Option<::std::string::String> {
        &self.in_reply_to
    }
    /// <p>The user agent that sent the email.</p>
    pub fn x_mailer(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.x_mailer = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The user agent that sent the email.</p>
    pub fn set_x_mailer(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.x_mailer = input;
        self
    }
    /// <p>The user agent that sent the email.</p>
    pub fn get_x_mailer(&self) -> &::std::option::Option<::std::string::String> {
        &self.x_mailer
    }
    /// <p>The original user agent that sent the email.</p>
    pub fn x_original_mailer(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.x_original_mailer = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The original user agent that sent the email.</p>
    pub fn set_x_original_mailer(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.x_original_mailer = input;
        self
    }
    /// <p>The original user agent that sent the email.</p>
    pub fn get_x_original_mailer(&self) -> &::std::option::Option<::std::string::String> {
        &self.x_original_mailer
    }
    /// <p>The priority level of the email.</p>
    pub fn x_priority(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.x_priority = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The priority level of the email.</p>
    pub fn set_x_priority(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.x_priority = input;
        self
    }
    /// <p>The priority level of the email.</p>
    pub fn get_x_priority(&self) -> &::std::option::Option<::std::string::String> {
        &self.x_priority
    }
    /// <p>The ID of the ingress endpoint through which the email was received.</p>
    pub fn ingress_point_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ingress_point_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the ingress endpoint through which the email was received.</p>
    pub fn set_ingress_point_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ingress_point_id = input;
        self
    }
    /// <p>The ID of the ingress endpoint through which the email was received.</p>
    pub fn get_ingress_point_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.ingress_point_id
    }
    /// <p>The name of the host from which the email was received.</p>
    pub fn sender_hostname(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.sender_hostname = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the host from which the email was received.</p>
    pub fn set_sender_hostname(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.sender_hostname = input;
        self
    }
    /// <p>The name of the host from which the email was received.</p>
    pub fn get_sender_hostname(&self) -> &::std::option::Option<::std::string::String> {
        &self.sender_hostname
    }
    /// <ul>
    /// <li>
    /// <p>Mail archived with Mail Manager: The IP address of the client that connects to the ingress endpoint.</p></li>
    /// <li>
    /// <p>Mail sent through a configuration set with the archiving option enabled: The IP address of the client that makes the SendEmail API call.</p></li>
    /// </ul>
    pub fn sender_ip_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.sender_ip_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <ul>
    /// <li>
    /// <p>Mail archived with Mail Manager: The IP address of the client that connects to the ingress endpoint.</p></li>
    /// <li>
    /// <p>Mail sent through a configuration set with the archiving option enabled: The IP address of the client that makes the SendEmail API call.</p></li>
    /// </ul>
    pub fn set_sender_ip_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.sender_ip_address = input;
        self
    }
    /// <ul>
    /// <li>
    /// <p>Mail archived with Mail Manager: The IP address of the client that connects to the ingress endpoint.</p></li>
    /// <li>
    /// <p>Mail sent through a configuration set with the archiving option enabled: The IP address of the client that makes the SendEmail API call.</p></li>
    /// </ul>
    pub fn get_sender_ip_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.sender_ip_address
    }
    /// <p>The SMTP envelope information of the email.</p>
    pub fn envelope(mut self, input: crate::types::Envelope) -> Self {
        self.envelope = ::std::option::Option::Some(input);
        self
    }
    /// <p>The SMTP envelope information of the email.</p>
    pub fn set_envelope(mut self, input: ::std::option::Option<crate::types::Envelope>) -> Self {
        self.envelope = input;
        self
    }
    /// <p>The SMTP envelope information of the email.</p>
    pub fn get_envelope(&self) -> &::std::option::Option<crate::types::Envelope> {
        &self.envelope
    }
    /// <p>Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.</p>
    pub fn source_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.</p>
    pub fn set_source_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_arn = input;
        self
    }
    /// <p>Specifies the archived email source, identified by either a Rule Set's ARN with an Archive action, or a Configuration Set's Archive ARN.</p>
    pub fn get_source_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_arn
    }
    /// Consumes the builder and constructs a [`Row`](crate::types::Row).
    pub fn build(self) -> crate::types::Row {
        crate::types::Row {
            archived_message_id: self.archived_message_id,
            received_timestamp: self.received_timestamp,
            date: self.date,
            to: self.to,
            from: self.from,
            cc: self.cc,
            subject: self.subject,
            message_id: self.message_id,
            has_attachments: self.has_attachments,
            received_headers: self.received_headers,
            in_reply_to: self.in_reply_to,
            x_mailer: self.x_mailer,
            x_original_mailer: self.x_original_mailer,
            x_priority: self.x_priority,
            ingress_point_id: self.ingress_point_id,
            sender_hostname: self.sender_hostname,
            sender_ip_address: self.sender_ip_address,
            envelope: self.envelope,
            source_arn: self.source_arn,
        }
    }
}
impl ::std::fmt::Debug for RowBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RowBuilder");
        formatter.field("archived_message_id", &self.archived_message_id);
        formatter.field("received_timestamp", &self.received_timestamp);
        formatter.field("date", &self.date);
        formatter.field("to", &self.to);
        formatter.field("from", &self.from);
        formatter.field("cc", &self.cc);
        formatter.field("subject", &self.subject);
        formatter.field("message_id", &self.message_id);
        formatter.field("has_attachments", &self.has_attachments);
        formatter.field("received_headers", &self.received_headers);
        formatter.field("in_reply_to", &self.in_reply_to);
        formatter.field("x_mailer", &self.x_mailer);
        formatter.field("x_original_mailer", &self.x_original_mailer);
        formatter.field("x_priority", &self.x_priority);
        formatter.field("ingress_point_id", &self.ingress_point_id);
        formatter.field("sender_hostname", &self.sender_hostname);
        formatter.field("sender_ip_address", &"*** Sensitive Data Redacted ***");
        formatter.field("envelope", &self.envelope);
        formatter.field("source_arn", &self.source_arn);
        formatter.finish()
    }
}
