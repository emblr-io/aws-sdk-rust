// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CreateMediaCapturePipelineInput {
    /// <p>Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.</p>
    pub source_type: ::std::option::Option<crate::types::MediaPipelineSourceType>,
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    pub source_arn: ::std::option::Option<::std::string::String>,
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket.</p>
    pub sink_type: ::std::option::Option<crate::types::MediaPipelineSinkType>,
    /// <p>The ARN of the sink type.</p>
    pub sink_arn: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.</p>
    pub client_request_token: ::std::option::Option<::std::string::String>,
    /// <p>The configuration for a specified media pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub chime_sdk_meeting_configuration: ::std::option::Option<crate::types::ChimeSdkMeetingConfiguration>,
    /// <p>An object that contains server side encryption parameters to be used by media capture pipeline. The parameters can also be used by media concatenation pipeline taking media capture pipeline as a media source.</p>
    pub sse_aws_key_management_params: ::std::option::Option<crate::types::SseAwsKeyManagementParams>,
    /// <p>The Amazon Resource Name (ARN) of the sink role to be used with <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. Can only interact with <code>S3Bucket</code> sink type. The role must belong to the caller’s account and be able to act on behalf of the caller during the API call. All minimum policy permissions requirements for the caller to perform sink-related actions are the same for <code>SinkIamRoleArn</code>.</p>
    /// <p>Additionally, the role must have permission to <code>kms:GenerateDataKey</code> using KMS key supplied as <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. If media concatenation will be required later, the role must also have permission to <code>kms:Decrypt</code> for the same KMS key.</p>
    pub sink_iam_role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateMediaCapturePipelineInput {
    /// <p>Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.</p>
    pub fn source_type(&self) -> ::std::option::Option<&crate::types::MediaPipelineSourceType> {
        self.source_type.as_ref()
    }
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    pub fn source_arn(&self) -> ::std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket.</p>
    pub fn sink_type(&self) -> ::std::option::Option<&crate::types::MediaPipelineSinkType> {
        self.sink_type.as_ref()
    }
    /// <p>The ARN of the sink type.</p>
    pub fn sink_arn(&self) -> ::std::option::Option<&str> {
        self.sink_arn.as_deref()
    }
    /// <p>The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.</p>
    pub fn client_request_token(&self) -> ::std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The configuration for a specified media pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub fn chime_sdk_meeting_configuration(&self) -> ::std::option::Option<&crate::types::ChimeSdkMeetingConfiguration> {
        self.chime_sdk_meeting_configuration.as_ref()
    }
    /// <p>An object that contains server side encryption parameters to be used by media capture pipeline. The parameters can also be used by media concatenation pipeline taking media capture pipeline as a media source.</p>
    pub fn sse_aws_key_management_params(&self) -> ::std::option::Option<&crate::types::SseAwsKeyManagementParams> {
        self.sse_aws_key_management_params.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the sink role to be used with <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. Can only interact with <code>S3Bucket</code> sink type. The role must belong to the caller’s account and be able to act on behalf of the caller during the API call. All minimum policy permissions requirements for the caller to perform sink-related actions are the same for <code>SinkIamRoleArn</code>.</p>
    /// <p>Additionally, the role must have permission to <code>kms:GenerateDataKey</code> using KMS key supplied as <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. If media concatenation will be required later, the role must also have permission to <code>kms:Decrypt</code> for the same KMS key.</p>
    pub fn sink_iam_role_arn(&self) -> ::std::option::Option<&str> {
        self.sink_iam_role_arn.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for CreateMediaCapturePipelineInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMediaCapturePipelineInput");
        formatter.field("source_type", &self.source_type);
        formatter.field("source_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("sink_type", &self.sink_type);
        formatter.field("sink_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_sdk_meeting_configuration", &self.chime_sdk_meeting_configuration);
        formatter.field("sse_aws_key_management_params", &self.sse_aws_key_management_params);
        formatter.field("sink_iam_role_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
impl CreateMediaCapturePipelineInput {
    /// Creates a new builder-style object to manufacture [`CreateMediaCapturePipelineInput`](crate::operation::create_media_capture_pipeline::CreateMediaCapturePipelineInput).
    pub fn builder() -> crate::operation::create_media_capture_pipeline::builders::CreateMediaCapturePipelineInputBuilder {
        crate::operation::create_media_capture_pipeline::builders::CreateMediaCapturePipelineInputBuilder::default()
    }
}

/// A builder for [`CreateMediaCapturePipelineInput`](crate::operation::create_media_capture_pipeline::CreateMediaCapturePipelineInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct CreateMediaCapturePipelineInputBuilder {
    pub(crate) source_type: ::std::option::Option<crate::types::MediaPipelineSourceType>,
    pub(crate) source_arn: ::std::option::Option<::std::string::String>,
    pub(crate) sink_type: ::std::option::Option<crate::types::MediaPipelineSinkType>,
    pub(crate) sink_arn: ::std::option::Option<::std::string::String>,
    pub(crate) client_request_token: ::std::option::Option<::std::string::String>,
    pub(crate) chime_sdk_meeting_configuration: ::std::option::Option<crate::types::ChimeSdkMeetingConfiguration>,
    pub(crate) sse_aws_key_management_params: ::std::option::Option<crate::types::SseAwsKeyManagementParams>,
    pub(crate) sink_iam_role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateMediaCapturePipelineInputBuilder {
    /// <p>Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.</p>
    /// This field is required.
    pub fn source_type(mut self, input: crate::types::MediaPipelineSourceType) -> Self {
        self.source_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.</p>
    pub fn set_source_type(mut self, input: ::std::option::Option<crate::types::MediaPipelineSourceType>) -> Self {
        self.source_type = input;
        self
    }
    /// <p>Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.</p>
    pub fn get_source_type(&self) -> &::std::option::Option<crate::types::MediaPipelineSourceType> {
        &self.source_type
    }
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    /// This field is required.
    pub fn source_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    pub fn set_source_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_arn = input;
        self
    }
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    pub fn get_source_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_arn
    }
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket.</p>
    /// This field is required.
    pub fn sink_type(mut self, input: crate::types::MediaPipelineSinkType) -> Self {
        self.sink_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket.</p>
    pub fn set_sink_type(mut self, input: ::std::option::Option<crate::types::MediaPipelineSinkType>) -> Self {
        self.sink_type = input;
        self
    }
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket.</p>
    pub fn get_sink_type(&self) -> &::std::option::Option<crate::types::MediaPipelineSinkType> {
        &self.sink_type
    }
    /// <p>The ARN of the sink type.</p>
    /// This field is required.
    pub fn sink_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.sink_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the sink type.</p>
    pub fn set_sink_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.sink_arn = input;
        self
    }
    /// <p>The ARN of the sink type.</p>
    pub fn get_sink_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.sink_arn
    }
    /// <p>The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.</p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_request_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_request_token = input;
        self
    }
    /// <p>The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_request_token
    }
    /// <p>The configuration for a specified media pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub fn chime_sdk_meeting_configuration(mut self, input: crate::types::ChimeSdkMeetingConfiguration) -> Self {
        self.chime_sdk_meeting_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration for a specified media pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub fn set_chime_sdk_meeting_configuration(mut self, input: ::std::option::Option<crate::types::ChimeSdkMeetingConfiguration>) -> Self {
        self.chime_sdk_meeting_configuration = input;
        self
    }
    /// <p>The configuration for a specified media pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub fn get_chime_sdk_meeting_configuration(&self) -> &::std::option::Option<crate::types::ChimeSdkMeetingConfiguration> {
        &self.chime_sdk_meeting_configuration
    }
    /// <p>An object that contains server side encryption parameters to be used by media capture pipeline. The parameters can also be used by media concatenation pipeline taking media capture pipeline as a media source.</p>
    pub fn sse_aws_key_management_params(mut self, input: crate::types::SseAwsKeyManagementParams) -> Self {
        self.sse_aws_key_management_params = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that contains server side encryption parameters to be used by media capture pipeline. The parameters can also be used by media concatenation pipeline taking media capture pipeline as a media source.</p>
    pub fn set_sse_aws_key_management_params(mut self, input: ::std::option::Option<crate::types::SseAwsKeyManagementParams>) -> Self {
        self.sse_aws_key_management_params = input;
        self
    }
    /// <p>An object that contains server side encryption parameters to be used by media capture pipeline. The parameters can also be used by media concatenation pipeline taking media capture pipeline as a media source.</p>
    pub fn get_sse_aws_key_management_params(&self) -> &::std::option::Option<crate::types::SseAwsKeyManagementParams> {
        &self.sse_aws_key_management_params
    }
    /// <p>The Amazon Resource Name (ARN) of the sink role to be used with <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. Can only interact with <code>S3Bucket</code> sink type. The role must belong to the caller’s account and be able to act on behalf of the caller during the API call. All minimum policy permissions requirements for the caller to perform sink-related actions are the same for <code>SinkIamRoleArn</code>.</p>
    /// <p>Additionally, the role must have permission to <code>kms:GenerateDataKey</code> using KMS key supplied as <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. If media concatenation will be required later, the role must also have permission to <code>kms:Decrypt</code> for the same KMS key.</p>
    pub fn sink_iam_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.sink_iam_role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the sink role to be used with <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. Can only interact with <code>S3Bucket</code> sink type. The role must belong to the caller’s account and be able to act on behalf of the caller during the API call. All minimum policy permissions requirements for the caller to perform sink-related actions are the same for <code>SinkIamRoleArn</code>.</p>
    /// <p>Additionally, the role must have permission to <code>kms:GenerateDataKey</code> using KMS key supplied as <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. If media concatenation will be required later, the role must also have permission to <code>kms:Decrypt</code> for the same KMS key.</p>
    pub fn set_sink_iam_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.sink_iam_role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the sink role to be used with <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. Can only interact with <code>S3Bucket</code> sink type. The role must belong to the caller’s account and be able to act on behalf of the caller during the API call. All minimum policy permissions requirements for the caller to perform sink-related actions are the same for <code>SinkIamRoleArn</code>.</p>
    /// <p>Additionally, the role must have permission to <code>kms:GenerateDataKey</code> using KMS key supplied as <code>AwsKmsKeyId</code> in <code>SseAwsKeyManagementParams</code>. If media concatenation will be required later, the role must also have permission to <code>kms:Decrypt</code> for the same KMS key.</p>
    pub fn get_sink_iam_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.sink_iam_role_arn
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tag key-value pairs.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The tag key-value pairs.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tag key-value pairs.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateMediaCapturePipelineInput`](crate::operation::create_media_capture_pipeline::CreateMediaCapturePipelineInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_media_capture_pipeline::CreateMediaCapturePipelineInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::create_media_capture_pipeline::CreateMediaCapturePipelineInput {
            source_type: self.source_type,
            source_arn: self.source_arn,
            sink_type: self.sink_type,
            sink_arn: self.sink_arn,
            client_request_token: self.client_request_token,
            chime_sdk_meeting_configuration: self.chime_sdk_meeting_configuration,
            sse_aws_key_management_params: self.sse_aws_key_management_params,
            sink_iam_role_arn: self.sink_iam_role_arn,
            tags: self.tags,
        })
    }
}
impl ::std::fmt::Debug for CreateMediaCapturePipelineInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMediaCapturePipelineInputBuilder");
        formatter.field("source_type", &self.source_type);
        formatter.field("source_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("sink_type", &self.sink_type);
        formatter.field("sink_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_sdk_meeting_configuration", &self.chime_sdk_meeting_configuration);
        formatter.field("sse_aws_key_management_params", &self.sse_aws_key_management_params);
        formatter.field("sink_iam_role_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
