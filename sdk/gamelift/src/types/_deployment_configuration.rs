// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Set of rules for processing a deployment for a container fleet update.</p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DeploymentConfiguration {
    /// <p>Determines how fleet deployment activity affects active game sessions on the fleet. With protection, a deployment honors game session protection, and delays actions that would interrupt a protected active game session until the game session ends. Without protection, deployment activity can shut down all running tasks, including active game sessions, regardless of game session protection.</p>
    pub protection_strategy: ::std::option::Option<crate::types::DeploymentProtectionStrategy>,
    /// <p>Sets a minimum level of healthy tasks to maintain during deployment activity.</p>
    pub minimum_healthy_percentage: ::std::option::Option<i32>,
    /// <p>Determines what actions to take if a deployment fails. If the fleet is multi-location, this strategy applies across all fleet locations. With a rollback strategy, updated fleet instances are rolled back to the last successful deployment. Alternatively, you can maintain a few impaired containers for the purpose of debugging, while all other tasks return to the last successful deployment.</p>
    pub impairment_strategy: ::std::option::Option<crate::types::DeploymentImpairmentStrategy>,
}
impl DeploymentConfiguration {
    /// <p>Determines how fleet deployment activity affects active game sessions on the fleet. With protection, a deployment honors game session protection, and delays actions that would interrupt a protected active game session until the game session ends. Without protection, deployment activity can shut down all running tasks, including active game sessions, regardless of game session protection.</p>
    pub fn protection_strategy(&self) -> ::std::option::Option<&crate::types::DeploymentProtectionStrategy> {
        self.protection_strategy.as_ref()
    }
    /// <p>Sets a minimum level of healthy tasks to maintain during deployment activity.</p>
    pub fn minimum_healthy_percentage(&self) -> ::std::option::Option<i32> {
        self.minimum_healthy_percentage
    }
    /// <p>Determines what actions to take if a deployment fails. If the fleet is multi-location, this strategy applies across all fleet locations. With a rollback strategy, updated fleet instances are rolled back to the last successful deployment. Alternatively, you can maintain a few impaired containers for the purpose of debugging, while all other tasks return to the last successful deployment.</p>
    pub fn impairment_strategy(&self) -> ::std::option::Option<&crate::types::DeploymentImpairmentStrategy> {
        self.impairment_strategy.as_ref()
    }
}
impl DeploymentConfiguration {
    /// Creates a new builder-style object to manufacture [`DeploymentConfiguration`](crate::types::DeploymentConfiguration).
    pub fn builder() -> crate::types::builders::DeploymentConfigurationBuilder {
        crate::types::builders::DeploymentConfigurationBuilder::default()
    }
}

/// A builder for [`DeploymentConfiguration`](crate::types::DeploymentConfiguration).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct DeploymentConfigurationBuilder {
    pub(crate) protection_strategy: ::std::option::Option<crate::types::DeploymentProtectionStrategy>,
    pub(crate) minimum_healthy_percentage: ::std::option::Option<i32>,
    pub(crate) impairment_strategy: ::std::option::Option<crate::types::DeploymentImpairmentStrategy>,
}
impl DeploymentConfigurationBuilder {
    /// <p>Determines how fleet deployment activity affects active game sessions on the fleet. With protection, a deployment honors game session protection, and delays actions that would interrupt a protected active game session until the game session ends. Without protection, deployment activity can shut down all running tasks, including active game sessions, regardless of game session protection.</p>
    pub fn protection_strategy(mut self, input: crate::types::DeploymentProtectionStrategy) -> Self {
        self.protection_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Determines how fleet deployment activity affects active game sessions on the fleet. With protection, a deployment honors game session protection, and delays actions that would interrupt a protected active game session until the game session ends. Without protection, deployment activity can shut down all running tasks, including active game sessions, regardless of game session protection.</p>
    pub fn set_protection_strategy(mut self, input: ::std::option::Option<crate::types::DeploymentProtectionStrategy>) -> Self {
        self.protection_strategy = input;
        self
    }
    /// <p>Determines how fleet deployment activity affects active game sessions on the fleet. With protection, a deployment honors game session protection, and delays actions that would interrupt a protected active game session until the game session ends. Without protection, deployment activity can shut down all running tasks, including active game sessions, regardless of game session protection.</p>
    pub fn get_protection_strategy(&self) -> &::std::option::Option<crate::types::DeploymentProtectionStrategy> {
        &self.protection_strategy
    }
    /// <p>Sets a minimum level of healthy tasks to maintain during deployment activity.</p>
    pub fn minimum_healthy_percentage(mut self, input: i32) -> Self {
        self.minimum_healthy_percentage = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets a minimum level of healthy tasks to maintain during deployment activity.</p>
    pub fn set_minimum_healthy_percentage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.minimum_healthy_percentage = input;
        self
    }
    /// <p>Sets a minimum level of healthy tasks to maintain during deployment activity.</p>
    pub fn get_minimum_healthy_percentage(&self) -> &::std::option::Option<i32> {
        &self.minimum_healthy_percentage
    }
    /// <p>Determines what actions to take if a deployment fails. If the fleet is multi-location, this strategy applies across all fleet locations. With a rollback strategy, updated fleet instances are rolled back to the last successful deployment. Alternatively, you can maintain a few impaired containers for the purpose of debugging, while all other tasks return to the last successful deployment.</p>
    pub fn impairment_strategy(mut self, input: crate::types::DeploymentImpairmentStrategy) -> Self {
        self.impairment_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Determines what actions to take if a deployment fails. If the fleet is multi-location, this strategy applies across all fleet locations. With a rollback strategy, updated fleet instances are rolled back to the last successful deployment. Alternatively, you can maintain a few impaired containers for the purpose of debugging, while all other tasks return to the last successful deployment.</p>
    pub fn set_impairment_strategy(mut self, input: ::std::option::Option<crate::types::DeploymentImpairmentStrategy>) -> Self {
        self.impairment_strategy = input;
        self
    }
    /// <p>Determines what actions to take if a deployment fails. If the fleet is multi-location, this strategy applies across all fleet locations. With a rollback strategy, updated fleet instances are rolled back to the last successful deployment. Alternatively, you can maintain a few impaired containers for the purpose of debugging, while all other tasks return to the last successful deployment.</p>
    pub fn get_impairment_strategy(&self) -> &::std::option::Option<crate::types::DeploymentImpairmentStrategy> {
        &self.impairment_strategy
    }
    /// Consumes the builder and constructs a [`DeploymentConfiguration`](crate::types::DeploymentConfiguration).
    pub fn build(self) -> crate::types::DeploymentConfiguration {
        crate::types::DeploymentConfiguration {
            protection_strategy: self.protection_strategy,
            minimum_healthy_percentage: self.minimum_healthy_percentage,
            impairment_strategy: self.impairment_strategy,
        }
    }
}
