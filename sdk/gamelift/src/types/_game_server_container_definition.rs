// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the game server container in an existing game server container group. A game server container identifies a container image with your game server build. A game server container is automatically considered essential; if an essential container fails, the entire container group restarts.</p>
/// <p>You can update a container definition and deploy the updates to an existing fleet. When creating or updating a game server container group definition, use the property <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_GameServerContainerDefinitionInput">https://docs.aws.amazon.com/gamelift/latest/apireference/API_GameServerContainerDefinitionInput</a>.</p>
/// <p><b>Part of:</b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ContainerGroupDefinition.html">ContainerGroupDefinition</a></p>
/// <p><b>Returned by:</b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeContainerGroupDefinition.html">DescribeContainerGroupDefinition</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ListContainerGroupDefinitions.html">ListContainerGroupDefinitions</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateContainerGroupDefinition.html">UpdateContainerGroupDefinition</a></p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GameServerContainerDefinition {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub container_name: ::std::option::Option<::std::string::String>,
    /// <p>Indicates that the container relies on the status of other containers in the same container group during startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    /// <p>The URI to the image that Amazon GameLift Servers uses when deploying this container to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub image_uri: ::std::option::Option<::std::string::String>,
    /// <p>The set of ports that are available to bind to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub resolved_image_digest: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub server_sdk_version: ::std::option::Option<::std::string::String>,
}
impl GameServerContainerDefinition {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn container_name(&self) -> ::std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::ContainerDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.mount_points.is_none()`.
    pub fn mount_points(&self) -> &[crate::types::ContainerMountPoint] {
        self.mount_points.as_deref().unwrap_or_default()
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment_override.is_none()`.
    pub fn environment_override(&self) -> &[crate::types::ContainerEnvironment] {
        self.environment_override.as_deref().unwrap_or_default()
    }
    /// <p>The URI to the image that Amazon GameLift Servers uses when deploying this container to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn image_uri(&self) -> ::std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The set of ports that are available to bind to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(&self) -> ::std::option::Option<&crate::types::ContainerPortConfiguration> {
        self.port_configuration.as_ref()
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn resolved_image_digest(&self) -> ::std::option::Option<&str> {
        self.resolved_image_digest.as_deref()
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn server_sdk_version(&self) -> ::std::option::Option<&str> {
        self.server_sdk_version.as_deref()
    }
}
impl GameServerContainerDefinition {
    /// Creates a new builder-style object to manufacture [`GameServerContainerDefinition`](crate::types::GameServerContainerDefinition).
    pub fn builder() -> crate::types::builders::GameServerContainerDefinitionBuilder {
        crate::types::builders::GameServerContainerDefinitionBuilder::default()
    }
}

/// A builder for [`GameServerContainerDefinition`](crate::types::GameServerContainerDefinition).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GameServerContainerDefinitionBuilder {
    pub(crate) container_name: ::std::option::Option<::std::string::String>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    pub(crate) mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    pub(crate) environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    pub(crate) image_uri: ::std::option::Option<::std::string::String>,
    pub(crate) port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    pub(crate) resolved_image_digest: ::std::option::Option<::std::string::String>,
    pub(crate) server_sdk_version: ::std::option::Option<::std::string::String>,
}
impl GameServerContainerDefinitionBuilder {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn container_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.container_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn set_container_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.container_name = input;
        self
    }
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn get_container_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.container_name
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>Indicates that the container relies on the status of other containers in the same container group during startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn depends_on(mut self, input: crate::types::ContainerDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>> {
        &self.depends_on
    }
    /// Appends an item to `mount_points`.
    ///
    /// To override the contents of this collection use [`set_mount_points`](Self::set_mount_points).
    ///
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn mount_points(mut self, input: crate::types::ContainerMountPoint) -> Self {
        let mut v = self.mount_points.unwrap_or_default();
        v.push(input);
        self.mount_points = ::std::option::Option::Some(v);
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn set_mount_points(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>) -> Self {
        self.mount_points = input;
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn get_mount_points(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>> {
        &self.mount_points
    }
    /// Appends an item to `environment_override`.
    ///
    /// To override the contents of this collection use [`set_environment_override`](Self::set_environment_override).
    ///
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn environment_override(mut self, input: crate::types::ContainerEnvironment) -> Self {
        let mut v = self.environment_override.unwrap_or_default();
        v.push(input);
        self.environment_override = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_environment_override(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>) -> Self {
        self.environment_override = input;
        self
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_environment_override(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>> {
        &self.environment_override
    }
    /// <p>The URI to the image that Amazon GameLift Servers uses when deploying this container to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn image_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URI to the image that Amazon GameLift Servers uses when deploying this container to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn set_image_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_uri = input;
        self
    }
    /// <p>The URI to the image that Amazon GameLift Servers uses when deploying this container to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn get_image_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_uri
    }
    /// <p>The set of ports that are available to bind to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(mut self, input: crate::types::ContainerPortConfiguration) -> Self {
        self.port_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The set of ports that are available to bind to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn set_port_configuration(mut self, input: ::std::option::Option<crate::types::ContainerPortConfiguration>) -> Self {
        self.port_configuration = input;
        self
    }
    /// <p>The set of ports that are available to bind to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn get_port_configuration(&self) -> &::std::option::Option<crate::types::ContainerPortConfiguration> {
        &self.port_configuration
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn resolved_image_digest(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resolved_image_digest = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn set_resolved_image_digest(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resolved_image_digest = input;
        self
    }
    /// <p>A unique and immutable identifier for the container image. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn get_resolved_image_digest(&self) -> &::std::option::Option<::std::string::String> {
        &self.resolved_image_digest
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn server_sdk_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.server_sdk_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn set_server_sdk_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.server_sdk_version = input;
        self
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn get_server_sdk_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.server_sdk_version
    }
    /// Consumes the builder and constructs a [`GameServerContainerDefinition`](crate::types::GameServerContainerDefinition).
    pub fn build(self) -> crate::types::GameServerContainerDefinition {
        crate::types::GameServerContainerDefinition {
            container_name: self.container_name,
            depends_on: self.depends_on,
            mount_points: self.mount_points,
            environment_override: self.environment_override,
            image_uri: self.image_uri,
            port_configuration: self.port_configuration,
            resolved_image_digest: self.resolved_image_digest,
            server_sdk_version: self.server_sdk_version,
        }
    }
}
