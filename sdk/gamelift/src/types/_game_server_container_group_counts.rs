// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The number and status of game server container groups that are deployed across a container fleet. Combine this count with the number of server processes that each game server container group runs to learn how many game sessions the fleet is capable of hosting concurrently. For example, if a fleet has 50 game server container groups, and the game server container in each group runs 1 game server process, then the fleet has the capacity to run host 50 game sessions at a time.</p>
/// <p><b>Returned by:</b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html">https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html">https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html</a></p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GameServerContainerGroupCounts {
    /// <p>The number of container groups that are starting up but haven't yet registered.</p>
    pub pending: ::std::option::Option<i32>,
    /// <p>The number of container groups that have active game sessions.</p>
    pub active: ::std::option::Option<i32>,
    /// <p>The number of container groups that have no active game sessions.</p>
    pub idle: ::std::option::Option<i32>,
    /// <p>The number of container groups that are in the process of shutting down.</p>
    pub terminating: ::std::option::Option<i32>,
}
impl GameServerContainerGroupCounts {
    /// <p>The number of container groups that are starting up but haven't yet registered.</p>
    pub fn pending(&self) -> ::std::option::Option<i32> {
        self.pending
    }
    /// <p>The number of container groups that have active game sessions.</p>
    pub fn active(&self) -> ::std::option::Option<i32> {
        self.active
    }
    /// <p>The number of container groups that have no active game sessions.</p>
    pub fn idle(&self) -> ::std::option::Option<i32> {
        self.idle
    }
    /// <p>The number of container groups that are in the process of shutting down.</p>
    pub fn terminating(&self) -> ::std::option::Option<i32> {
        self.terminating
    }
}
impl GameServerContainerGroupCounts {
    /// Creates a new builder-style object to manufacture [`GameServerContainerGroupCounts`](crate::types::GameServerContainerGroupCounts).
    pub fn builder() -> crate::types::builders::GameServerContainerGroupCountsBuilder {
        crate::types::builders::GameServerContainerGroupCountsBuilder::default()
    }
}

/// A builder for [`GameServerContainerGroupCounts`](crate::types::GameServerContainerGroupCounts).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GameServerContainerGroupCountsBuilder {
    pub(crate) pending: ::std::option::Option<i32>,
    pub(crate) active: ::std::option::Option<i32>,
    pub(crate) idle: ::std::option::Option<i32>,
    pub(crate) terminating: ::std::option::Option<i32>,
}
impl GameServerContainerGroupCountsBuilder {
    /// <p>The number of container groups that are starting up but haven't yet registered.</p>
    pub fn pending(mut self, input: i32) -> Self {
        self.pending = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of container groups that are starting up but haven't yet registered.</p>
    pub fn set_pending(mut self, input: ::std::option::Option<i32>) -> Self {
        self.pending = input;
        self
    }
    /// <p>The number of container groups that are starting up but haven't yet registered.</p>
    pub fn get_pending(&self) -> &::std::option::Option<i32> {
        &self.pending
    }
    /// <p>The number of container groups that have active game sessions.</p>
    pub fn active(mut self, input: i32) -> Self {
        self.active = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of container groups that have active game sessions.</p>
    pub fn set_active(mut self, input: ::std::option::Option<i32>) -> Self {
        self.active = input;
        self
    }
    /// <p>The number of container groups that have active game sessions.</p>
    pub fn get_active(&self) -> &::std::option::Option<i32> {
        &self.active
    }
    /// <p>The number of container groups that have no active game sessions.</p>
    pub fn idle(mut self, input: i32) -> Self {
        self.idle = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of container groups that have no active game sessions.</p>
    pub fn set_idle(mut self, input: ::std::option::Option<i32>) -> Self {
        self.idle = input;
        self
    }
    /// <p>The number of container groups that have no active game sessions.</p>
    pub fn get_idle(&self) -> &::std::option::Option<i32> {
        &self.idle
    }
    /// <p>The number of container groups that are in the process of shutting down.</p>
    pub fn terminating(mut self, input: i32) -> Self {
        self.terminating = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of container groups that are in the process of shutting down.</p>
    pub fn set_terminating(mut self, input: ::std::option::Option<i32>) -> Self {
        self.terminating = input;
        self
    }
    /// <p>The number of container groups that are in the process of shutting down.</p>
    pub fn get_terminating(&self) -> &::std::option::Option<i32> {
        &self.terminating
    }
    /// Consumes the builder and constructs a [`GameServerContainerGroupCounts`](crate::types::GameServerContainerGroupCounts).
    pub fn build(self) -> crate::types::GameServerContainerGroupCounts {
        crate::types::GameServerContainerGroupCounts {
            pending: self.pending,
            active: self.active,
            idle: self.idle,
            terminating: self.terminating,
        }
    }
}
