// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the configuration for a container that runs your game server executable. This definition includes container configuration, resources, and start instructions. Use this data type when creating or updating a game server container group definition. For properties of a deployed container, see <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_GameServerContainerDefinition.html">GameServerContainerDefinition</a>. A game server container is automatically considered essential; if an essential container fails, the entire container group restarts.</p>
/// <p><b>Use with: </b> <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_CreateContainerGroupDefinition.html">CreateContainerGroupDefinition</a>, <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateContainerGroupDefinition.html">UpdateContainerGroupDefinition</a></p>
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GameServerContainerDefinitionInput {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub container_name: ::std::option::Option<::std::string::String>,
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift Servers endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub image_uri: ::std::option::Option<::std::string::String>,
    /// <p>A set of ports that Amazon GameLift Servers can assign to processes in a container. The container port configuration must have enough ports for each container process that accepts inbound traffic connections. For example, a game server process requires a container port to allow game clients to connect to it. A container port configuration can have can have one or more container port ranges. Each range specifies starting and ending values as well as the supported network protocol.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps each container port to an externally accessible connection port (see the container fleet property <code>ConnectionPortRange</code>).</p>
    pub port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub server_sdk_version: ::std::option::Option<::std::string::String>,
}
impl GameServerContainerDefinitionInput {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn container_name(&self) -> ::std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::ContainerDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.mount_points.is_none()`.
    pub fn mount_points(&self) -> &[crate::types::ContainerMountPoint] {
        self.mount_points.as_deref().unwrap_or_default()
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment_override.is_none()`.
    pub fn environment_override(&self) -> &[crate::types::ContainerEnvironment] {
        self.environment_override.as_deref().unwrap_or_default()
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift Servers endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub fn image_uri(&self) -> ::std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>A set of ports that Amazon GameLift Servers can assign to processes in a container. The container port configuration must have enough ports for each container process that accepts inbound traffic connections. For example, a game server process requires a container port to allow game clients to connect to it. A container port configuration can have can have one or more container port ranges. Each range specifies starting and ending values as well as the supported network protocol.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps each container port to an externally accessible connection port (see the container fleet property <code>ConnectionPortRange</code>).</p>
    pub fn port_configuration(&self) -> ::std::option::Option<&crate::types::ContainerPortConfiguration> {
        self.port_configuration.as_ref()
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn server_sdk_version(&self) -> ::std::option::Option<&str> {
        self.server_sdk_version.as_deref()
    }
}
impl GameServerContainerDefinitionInput {
    /// Creates a new builder-style object to manufacture [`GameServerContainerDefinitionInput`](crate::types::GameServerContainerDefinitionInput).
    pub fn builder() -> crate::types::builders::GameServerContainerDefinitionInputBuilder {
        crate::types::builders::GameServerContainerDefinitionInputBuilder::default()
    }
}

/// A builder for [`GameServerContainerDefinitionInput`](crate::types::GameServerContainerDefinitionInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GameServerContainerDefinitionInputBuilder {
    pub(crate) container_name: ::std::option::Option<::std::string::String>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
    pub(crate) mount_points: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>,
    pub(crate) environment_override: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    pub(crate) image_uri: ::std::option::Option<::std::string::String>,
    pub(crate) port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    pub(crate) server_sdk_version: ::std::option::Option<::std::string::String>,
}
impl GameServerContainerDefinitionInputBuilder {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    /// This field is required.
    pub fn container_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.container_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn set_container_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.container_name = input;
        self
    }
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn get_container_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.container_name
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub fn depends_on(mut self, input: crate::types::ContainerDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>Establishes dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. For example, you might specify that <i>ContainerB</i> has a <code>START</code> dependency on <i>ContainerA</i>. This dependency means that <i>ContainerB</i> can't start until after <i>ContainerA</i> has started. This dependency is reversed on shutdown, which means that <i>ContainerB</i> must shut down before <i>ContainerA</i> can shut down.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>> {
        &self.depends_on
    }
    /// Appends an item to `mount_points`.
    ///
    /// To override the contents of this collection use [`set_mount_points`](Self::set_mount_points).
    ///
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn mount_points(mut self, input: crate::types::ContainerMountPoint) -> Self {
        let mut v = self.mount_points.unwrap_or_default();
        v.push(input);
        self.mount_points = ::std::option::Option::Some(v);
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn set_mount_points(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>>) -> Self {
        self.mount_points = input;
        self
    }
    /// <p>A mount point that binds a path inside the container to a file or directory on the host system and lets it access the file or directory.</p>
    pub fn get_mount_points(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerMountPoint>> {
        &self.mount_points
    }
    /// Appends an item to `environment_override`.
    ///
    /// To override the contents of this collection use [`set_environment_override`](Self::set_environment_override).
    ///
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn environment_override(mut self, input: crate::types::ContainerEnvironment) -> Self {
        let mut v = self.environment_override.unwrap_or_default();
        v.push(input);
        self.environment_override = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_environment_override(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>) -> Self {
        self.environment_override = input;
        self
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_environment_override(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>> {
        &self.environment_override
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift Servers endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    /// This field is required.
    pub fn image_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift Servers endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub fn set_image_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_uri = input;
        self
    }
    /// <p>The location of the container image to deploy to a container fleet. Provide an image in an Amazon Elastic Container Registry public or private repository. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift Servers endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]@\[digest\]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>\[AWS account\].dkr.ecr.\[AWS region\].amazonaws.com/\[repository ID\]:\[tag\]</code></p></li>
    /// </ul>
    pub fn get_image_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_uri
    }
    /// <p>A set of ports that Amazon GameLift Servers can assign to processes in a container. The container port configuration must have enough ports for each container process that accepts inbound traffic connections. For example, a game server process requires a container port to allow game clients to connect to it. A container port configuration can have can have one or more container port ranges. Each range specifies starting and ending values as well as the supported network protocol.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps each container port to an externally accessible connection port (see the container fleet property <code>ConnectionPortRange</code>).</p>
    /// This field is required.
    pub fn port_configuration(mut self, input: crate::types::ContainerPortConfiguration) -> Self {
        self.port_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>A set of ports that Amazon GameLift Servers can assign to processes in a container. The container port configuration must have enough ports for each container process that accepts inbound traffic connections. For example, a game server process requires a container port to allow game clients to connect to it. A container port configuration can have can have one or more container port ranges. Each range specifies starting and ending values as well as the supported network protocol.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps each container port to an externally accessible connection port (see the container fleet property <code>ConnectionPortRange</code>).</p>
    pub fn set_port_configuration(mut self, input: ::std::option::Option<crate::types::ContainerPortConfiguration>) -> Self {
        self.port_configuration = input;
        self
    }
    /// <p>A set of ports that Amazon GameLift Servers can assign to processes in a container. The container port configuration must have enough ports for each container process that accepts inbound traffic connections. For example, a game server process requires a container port to allow game clients to connect to it. A container port configuration can have can have one or more container port ranges. Each range specifies starting and ending values as well as the supported network protocol.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift Servers maps each container port to an externally accessible connection port (see the container fleet property <code>ConnectionPortRange</code>).</p>
    pub fn get_port_configuration(&self) -> &::std::option::Option<crate::types::ContainerPortConfiguration> {
        &self.port_configuration
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    /// This field is required.
    pub fn server_sdk_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.server_sdk_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn set_server_sdk_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.server_sdk_version = input;
        self
    }
    /// <p>The Amazon GameLift Servers server SDK version that the game server is integrated with. Only game servers using 5.2.0 or higher are compatible with container fleets.</p>
    pub fn get_server_sdk_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.server_sdk_version
    }
    /// Consumes the builder and constructs a [`GameServerContainerDefinitionInput`](crate::types::GameServerContainerDefinitionInput).
    pub fn build(self) -> crate::types::GameServerContainerDefinitionInput {
        crate::types::GameServerContainerDefinitionInput {
            container_name: self.container_name,
            depends_on: self.depends_on,
            mount_points: self.mount_points,
            environment_override: self.environment_override,
            image_uri: self.image_uri,
            port_configuration: self.port_configuration,
            server_sdk_version: self.server_sdk_version,
        }
    }
}
