// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[cfg_attr(feature = "serde-serialize", derive(::serde::Serialize))]
#[cfg_attr(feature = "serde-deserialize", derive(::serde::Deserialize))]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetUnfilteredTableMetadataInput {
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub region: ::std::option::Option<::std::string::String>,
    /// <p>The catalog ID where the table resides.</p>
    pub catalog_id: ::std::option::Option<::std::string::String>,
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub database_name: ::std::option::Option<::std::string::String>,
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub audit_context: ::std::option::Option<crate::types::AuditContext>,
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub supported_permission_types: ::std::option::Option<::std::vec::Vec<crate::types::PermissionType>>,
    /// <p>The resource ARN of the view.</p>
    pub parent_resource_arn: ::std::option::Option<::std::string::String>,
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub root_resource_arn: ::std::option::Option<::std::string::String>,
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub supported_dialect: ::std::option::Option<crate::types::SupportedDialect>,
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub permissions: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>,
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub query_session_context: ::std::option::Option<crate::types::QuerySessionContext>,
}
impl GetUnfilteredTableMetadataInput {
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn region(&self) -> ::std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>The catalog ID where the table resides.</p>
    pub fn catalog_id(&self) -> ::std::option::Option<&str> {
        self.catalog_id.as_deref()
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub fn database_name(&self) -> ::std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn audit_context(&self) -> ::std::option::Option<&crate::types::AuditContext> {
        self.audit_context.as_ref()
    }
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.supported_permission_types.is_none()`.
    pub fn supported_permission_types(&self) -> &[crate::types::PermissionType] {
        self.supported_permission_types.as_deref().unwrap_or_default()
    }
    /// <p>The resource ARN of the view.</p>
    pub fn parent_resource_arn(&self) -> ::std::option::Option<&str> {
        self.parent_resource_arn.as_deref()
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn root_resource_arn(&self) -> ::std::option::Option<&str> {
        self.root_resource_arn.as_deref()
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn supported_dialect(&self) -> ::std::option::Option<&crate::types::SupportedDialect> {
        self.supported_dialect.as_ref()
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.permissions.is_none()`.
    pub fn permissions(&self) -> &[crate::types::Permission] {
        self.permissions.as_deref().unwrap_or_default()
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn query_session_context(&self) -> ::std::option::Option<&crate::types::QuerySessionContext> {
        self.query_session_context.as_ref()
    }
}
impl GetUnfilteredTableMetadataInput {
    /// Creates a new builder-style object to manufacture [`GetUnfilteredTableMetadataInput`](crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataInput).
    pub fn builder() -> crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataInputBuilder {
        crate::operation::get_unfiltered_table_metadata::builders::GetUnfilteredTableMetadataInputBuilder::default()
    }
}

/// A builder for [`GetUnfilteredTableMetadataInput`](crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GetUnfilteredTableMetadataInputBuilder {
    pub(crate) region: ::std::option::Option<::std::string::String>,
    pub(crate) catalog_id: ::std::option::Option<::std::string::String>,
    pub(crate) database_name: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) audit_context: ::std::option::Option<crate::types::AuditContext>,
    pub(crate) supported_permission_types: ::std::option::Option<::std::vec::Vec<crate::types::PermissionType>>,
    pub(crate) parent_resource_arn: ::std::option::Option<::std::string::String>,
    pub(crate) root_resource_arn: ::std::option::Option<::std::string::String>,
    pub(crate) supported_dialect: ::std::option::Option<crate::types::SupportedDialect>,
    pub(crate) permissions: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>,
    pub(crate) query_session_context: ::std::option::Option<crate::types::QuerySessionContext>,
}
impl GetUnfilteredTableMetadataInputBuilder {
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.region = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn set_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.region = input;
        self
    }
    /// <p>Specified only if the base tables belong to a different Amazon Web Services Region.</p>
    pub fn get_region(&self) -> &::std::option::Option<::std::string::String> {
        &self.region
    }
    /// <p>The catalog ID where the table resides.</p>
    /// This field is required.
    pub fn catalog_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.catalog_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The catalog ID where the table resides.</p>
    pub fn set_catalog_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.catalog_id = input;
        self
    }
    /// <p>The catalog ID where the table resides.</p>
    pub fn get_catalog_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.catalog_id
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    /// This field is required.
    pub fn database_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub fn set_database_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database_name = input;
        self
    }
    /// <p>(Required) Specifies the name of a database that contains the table.</p>
    pub fn get_database_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.database_name
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>(Required) Specifies the name of a table for which you are requesting metadata.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn audit_context(mut self, input: crate::types::AuditContext) -> Self {
        self.audit_context = ::std::option::Option::Some(input);
        self
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn set_audit_context(mut self, input: ::std::option::Option<crate::types::AuditContext>) -> Self {
        self.audit_context = input;
        self
    }
    /// <p>A structure containing Lake Formation audit context information.</p>
    pub fn get_audit_context(&self) -> &::std::option::Option<crate::types::AuditContext> {
        &self.audit_context
    }
    /// Appends an item to `supported_permission_types`.
    ///
    /// To override the contents of this collection use [`set_supported_permission_types`](Self::set_supported_permission_types).
    ///
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub fn supported_permission_types(mut self, input: crate::types::PermissionType) -> Self {
        let mut v = self.supported_permission_types.unwrap_or_default();
        v.push(input);
        self.supported_permission_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub fn set_supported_permission_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::PermissionType>>) -> Self {
        self.supported_permission_types = input;
        self
    }
    /// <p>Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the <code>GetUnfilteredTableMetadata</code> API operation. Accepted values are:</p>
    /// <ul>
    /// <li>
    /// <p><code>COLUMN_PERMISSION</code> - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.</p></li>
    /// <li>
    /// <p><code>CELL_FILTER_PERMISSION</code> - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.</p></li>
    /// <li>
    /// <p><code>NESTED_PERMISSION</code> - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.</p></li>
    /// <li>
    /// <p><code>NESTED_CELL_PERMISSION</code> - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.</p></li>
    /// </ul>
    /// <p>Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type.</p>
    /// <p>Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the <code>GetUnfilteredTableMetadata</code> operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.</p>
    pub fn get_supported_permission_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::PermissionType>> {
        &self.supported_permission_types
    }
    /// <p>The resource ARN of the view.</p>
    pub fn parent_resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.parent_resource_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The resource ARN of the view.</p>
    pub fn set_parent_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.parent_resource_arn = input;
        self
    }
    /// <p>The resource ARN of the view.</p>
    pub fn get_parent_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.parent_resource_arn
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn root_resource_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.root_resource_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn set_root_resource_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.root_resource_arn = input;
        self
    }
    /// <p>The resource ARN of the root view in a chain of nested views.</p>
    pub fn get_root_resource_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.root_resource_arn
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn supported_dialect(mut self, input: crate::types::SupportedDialect) -> Self {
        self.supported_dialect = ::std::option::Option::Some(input);
        self
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn set_supported_dialect(mut self, input: ::std::option::Option<crate::types::SupportedDialect>) -> Self {
        self.supported_dialect = input;
        self
    }
    /// <p>A structure specifying the dialect and dialect version used by the query engine.</p>
    pub fn get_supported_dialect(&self) -> &::std::option::Option<crate::types::SupportedDialect> {
        &self.supported_dialect
    }
    /// Appends an item to `permissions`.
    ///
    /// To override the contents of this collection use [`set_permissions`](Self::set_permissions).
    ///
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn permissions(mut self, input: crate::types::Permission) -> Self {
        let mut v = self.permissions.unwrap_or_default();
        v.push(input);
        self.permissions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn set_permissions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Permission>>) -> Self {
        self.permissions = input;
        self
    }
    /// <p>The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.</p>
    pub fn get_permissions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Permission>> {
        &self.permissions
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn query_session_context(mut self, input: crate::types::QuerySessionContext) -> Self {
        self.query_session_context = ::std::option::Option::Some(input);
        self
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn set_query_session_context(mut self, input: ::std::option::Option<crate::types::QuerySessionContext>) -> Self {
        self.query_session_context = input;
        self
    }
    /// <p>A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.</p>
    pub fn get_query_session_context(&self) -> &::std::option::Option<crate::types::QuerySessionContext> {
        &self.query_session_context
    }
    /// Consumes the builder and constructs a [`GetUnfilteredTableMetadataInput`](crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::get_unfiltered_table_metadata::GetUnfilteredTableMetadataInput {
            region: self.region,
            catalog_id: self.catalog_id,
            database_name: self.database_name,
            name: self.name,
            audit_context: self.audit_context,
            supported_permission_types: self.supported_permission_types,
            parent_resource_arn: self.parent_resource_arn,
            root_resource_arn: self.root_resource_arn,
            supported_dialect: self.supported_dialect,
            permissions: self.permissions,
            query_session_context: self.query_session_context,
        })
    }
}
